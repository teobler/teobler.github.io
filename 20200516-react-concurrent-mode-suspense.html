<!DOCTYPE html>


  <html lang="zh-CN" class="light page-post">


<head>
  <meta charset="utf-8">
  <meta http-equiv="content-language" content="zh-CN">
  
  <title>React Concurrent Mode 之 Suspense 实践 | teobler&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="React,Concurrent Mode," />
  

  <meta name="360-site-verification" content="7b29d0e6eb0d7a16d22f9d0961882c3a" />
  <meta name="sogou_site_verification" content="S1EAZKO83i"/>

  <meta name="description" content="自从三大框架成型之后，各个框架都为提升开发者的开发效率作出了不少努力，但是看起来技术革新都到了一个瓶颈。除了 React 引入了一次函数式的思想，感觉已经没有当初从DOM时代到数据驱动时代的惊艳感了。于是 React 将精力放在了用户体验上，想让开发者在不过多耗费精力的情况下，用框架自身去提升用户体验。 于是在最近的几个版本中，React 引入了一个叫做 Concurrent Mode 的东西，同">
<meta name="keywords" content="React,Concurrent Mode">
<meta property="og:type" content="article">
<meta property="og:title" content="React Concurrent Mode 之 Suspense 实践">
<meta property="og:url" content="https://teobler.com/20200516-react-concurrent-mode-suspense.html">
<meta property="og:site_name" content="teobler&#39;s blog">
<meta property="og:description" content="自从三大框架成型之后，各个框架都为提升开发者的开发效率作出了不少努力，但是看起来技术革新都到了一个瓶颈。除了 React 引入了一次函数式的思想，感觉已经没有当初从DOM时代到数据驱动时代的惊艳感了。于是 React 将精力放在了用户体验上，想让开发者在不过多耗费精力的情况下，用框架自身去提升用户体验。 于是在最近的几个版本中，React 引入了一个叫做 Concurrent Mode 的东西，同">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://teobler-image.s3-us-west-1.amazonaws.com/030546.png">
<meta property="og:image" content="https://teobler-image.s3-us-west-1.amazonaws.com/031513.png">
<meta property="og:updated_time" content="2020-05-16T03:06:28.380Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Concurrent Mode 之 Suspense 实践">
<meta name="twitter:description" content="自从三大框架成型之后，各个框架都为提升开发者的开发效率作出了不少努力，但是看起来技术革新都到了一个瓶颈。除了 React 引入了一次函数式的思想，感觉已经没有当初从DOM时代到数据驱动时代的惊艳感了。于是 React 将精力放在了用户体验上，想让开发者在不过多耗费精力的情况下，用框架自身去提升用户体验。 于是在最近的几个版本中，React 引入了一个叫做 Concurrent Mode 的东西，同">
<meta name="twitter:image" content="https://teobler-image.s3-us-west-1.amazonaws.com/030546.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  

  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158204206-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158204206-1');
</script>



  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>


  
  <script src="https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba" id="sozz"></script>



  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <script data-ad-client="ca-pub-8160236896214353" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>

<div id="post-container" class="container">
  <div class="content content-post CENTER">
     <article id="post-20200516-react-concurrent-mode-suspense" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">React Concurrent Mode 之 Suspense 实践</h1>

    <div class="article-meta">
       <div>
          <span>
            <i class="icon-calendar"></i>
            <span>2020.05.16</span>
          </span>

          
            <span class="article-author">
              <i class="icon-user"></i>
              <span>teobler</span>
            </span>
          

          
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </span>



          
            <span>
              <i class="icon-comment"></i>
              <a href="https://teobler.com/20200516-react-concurrent-mode-suspense.html#disqus_thread"></a>
            </span>
          

          
          <i class="fa fa-eye"></i>
            <span id="busuanzi_container_page_pv">
               &nbsp热度 <span id="busuanzi_value_page_pv">
               <i class="fa fa-spinner fa-spin"></i></span>℃
            </span>
          

          
      </div>

      <div>
        <i class="icon-text"></i>
        <span class="post-count">全篇字数: 3.9k</span>
        &nbsp
        <i class="icon-calendar-1"></i>
        <span class="post-count">预计花费: 15分钟</span>
      </div>
      
    </div>
  </header>

  <div class="article-content">
    
      <p>自从三大框架成型之后，各个框架都为提升开发者的开发效率作出了不少努力，但是看起来技术革新都到了一个瓶颈。除了 React 引入了一次函数式的思想，感觉已经没有当初从DOM时代到数据驱动时代的惊艳感了。于是 React 将精力放在了用户体验上，想让开发者在不过多耗费精力的情况下，用框架自身去提升用户体验。</p>
<p>于是在最近的几个版本中，React 引入了一个叫做 <code>Concurrent Mode</code> 的东西，同时还引入了 <code>Suspense</code>，旨在提升用户的访问体验，React 应用在慢慢变大以后会慢慢变得越来越卡，这次的新功能就是想在应用初期就解决这些问题。</p>
<p>虽然现在这些功能还处在实验阶段，React 团队并不建议在生产环境中使用，不过大部分功能已经完成了，而且他们已经用在了新的网站功能中，所以面对这样一个相对成熟的技术，其实我们还是可以来自己玩一下的，接下来我来带领大家看看这是一个什么样的东西吧。</p>
<h2 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h2><h3 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h3><p>那么这个 <code>Concurrent Mode</code> 是个啥呢？</p>
<blockquote>
<p>Concurrent Mode is a set of new features that help React apps stay responsive and gracefully adjust to the user’s device capabilities and network speed.</p>
</blockquote>
<p>在官网的解释中， <code>Concurrent Mode</code> 包含了一系列新功能，这些新功能可以根据用户不同的设备性能和不同的网速进行不同的响应，以使得用户在不同的设备和网速的情况下拥有最好的访问体验。那么问题来了，它是怎么做到这一点的呢？</p>
<h3 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h3><h4 id="可停止的rendering-Interruptible-Rendering"><a href="#可停止的rendering-Interruptible-Rendering" class="headerlink" title="可停止的rendering (Interruptible Rendering)"></a>可停止的rendering (Interruptible Rendering)</h4><p>在通常状况下，React 在 render 的时候是没有办法被打断的（这其中有创建新的 DOM 节点等等），rendering 的过程会一直占用 JS 线程，导致此时浏览器无法对用户的操作进行实时反馈，造成了一种整个页面很卡的感觉。</p>
<p>而在 <code>Concurrent Mode</code> 下，rendering 是可以被打断的，这意味着 React 可以让出主线程给浏览器用于更紧急的用户操作。</p>
<p>想象这样一个通用的场景：用户在一个输入框中检索一些信息，输入框中的文字改变后页面都将重新渲染以展示最新的结果，但是你会发现每一次输入都会卡顿，因为每一次重新渲染都将阻塞主线程，浏览器就将没有办法相应用户在输入框中的输入。当然现在通用的解决办法是用 <code>debouncing</code> 或者 <code>throtting</code>。但是这个方式存在一些问题，首先是页面没有办法实时反应用户的输入，用户会发现可能输入了好多个字符页面才刷新一次，不会实时更新；第二个问题是在性能比较差的设备上还是会出现卡顿的情况。</p>
<p>如果在页面正在 render 时用户输入了新的字符，React 可以暂停 render 让浏览器优先对用户的输入进行更新，然后 React 会在<strong>内存中</strong>渲染最新的页面，等到第一次 render 完成后再直接将最新的页面更新出来，保证用户能看到最新的页面。</p>
<p><img src="https://teobler-image.s3-us-west-1.amazonaws.com/030546.png" alt="image-20200516110545540"></p>
<p>这个过程有点像 git 的多分支，主分支是用户能够看到的并且是可以被暂停的，React 会新起一个分支来做最新的渲染，当主分支的渲染完成后就将新的分支合并过来，得到最新的视图。</p>
<h4 id="可选的加载顺序-Intentional-Loading-Sequences"><a href="#可选的加载顺序-Intentional-Loading-Sequences" class="headerlink" title="可选的加载顺序(Intentional Loading Sequences)"></a>可选的加载顺序(Intentional Loading Sequences)</h4><p>在页面跳转的时候，为了提升用户体验，我们往往会在新的页面中加上 <code>skeleton</code>，这是为了防止要渲染的数据还没有拿到，用户看到一个空白的页面。</p>
<p>在 <code>Concurrent Mode</code> 中，我们可以让 React 在第一个页面多停留一会，此时 React 会在内存中用拿到的数据渲染新的页面，等页面渲染完成后再直接跳转到一个已经完成了的页面上，这个行为要更加符合用户直觉。而且需要说明的是，在第一个页面等待的时间里，用户的任何操作都是可以被捕捉到的，也就是说在等待时间内并不会 block 用户的任何操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下就是，新的 <code>Concurrent Mode</code> 可以让 React 同时在不同的状态下进行并行处理，在并行状态结束后又将所有改变合并起来。这个功能主要聚焦在两点上：</p>
<ul>
<li>对于 CPU 来说（比如创建 DOM 节点），这样的并行意味着优先级更高的更新可以打断 rendering</li>
<li>对于 IO 来说（比如从服务端拿数据），这样的并行意味着 React 可以将先拿到的一部分数据用于在内存中构建 DOM，全部构建完成后在进行一次性的渲染，同时不影响当前页面</li>
</ul>
<p>而对于开发者来说，React 的使用方式并没有太大的变化，你以前怎么写的 React，将来还是怎么写，不会让开发者有断层的感受。下面我们可以通过几个例子来看看具体怎么使用。</p>
<h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><h3 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h3><p>与之前的功能不同的是，<code>Concurrent Mode</code> 需要开发者手动开启（只是使用 <code>Suspense</code> 貌似不用开启，但是我为了下一篇文章的代码，现在就先开启了）。为了方(tou)便(lan)，我们用 cra 创建一个新的项目，为了使用 <code>Concurrent Mode</code> 我们需要做如下修改：</p>
<ul>
<li><p>删除项目中的react版本，该用实验版 <code>npm install react@experimental react-dom@experimental</code></p>
</li>
<li><p>为了正常使用 <strong>TypeScript</strong> 在 <code>react-app-env.d.ts</code> 文件中加入实验版 React 的 type 引用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types="react-dom/experimental" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference types="react/experimental" /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>index.tsx</code> 中开启 <code>Concurrent Mode</code> </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.unstable_createRoot(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>) <span class="keyword">as</span> HTMLElement</span><br><span class="line">).render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Suspense</code> 中如果你需要在拿后端数据时”挂起“你的组件，<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#using-suspense-in-practice" target="_blank" rel="noopener">你需要一个按照 React 要求实现的 “Promise Wrapper”</a>，在这里我选择的是 <a href="https://swr.now.sh/" target="_blank" rel="noopener">swr</a> </p>
<ul>
<li>从后面的结果来看，目前 swr 对于 <code>Suspense</code> 的实现还没有完成，但是已经有一个 pr 了</li>
</ul>
</li>
</ul>
<blockquote>
<p>本文中所有的代码都可以在我的 <a href="https://github.com/teobler/concurrent-mode-demo" target="_blank" rel="noopener">github repo</a> 里找到，建议时间充裕的同学 clone 一份和文章一同食用效果更佳。</p>
</blockquote>
<h3 id="Data-Fetching"><a href="#Data-Fetching" class="headerlink" title="Data Fetching"></a>Data Fetching</h3><p>React 团队在 16.6 中加入了一个新的组件 <code>Suspense</code> ，<code>Suspense</code> 与其说是一个组件，更多的可以说是一种机制。这个组件可以在子节点渲染的时候进行”挂起“，渲染一个你设定好的等待图标之类的组件，等子节点渲染完成后再显示子节点。在 <code>Concurrent Mode</code> 之前，该组件通常用来作懒加载：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProfilePage = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./ProfilePage'</span>)); <span class="comment">// Lazy-loaded</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Show a spinner while the profile is loading</span></span><br><span class="line">&lt;Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">  &lt;ProfilePage /&gt;</span><br><span class="line">&lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>
<p>在最新的 React 版本中，现在 <code>Suspense</code> 组件可以用来”挂起“任何东西，比如可以在从服务端拿数据的时候”挂起“某个组件，比如一个图片，比如一段脚本等等。我们在这里仅仅以从后端拿数据为例。</p>
<p>在传统的数据获取中，往往是组件先 render 然后再去后端获取数据，拿到数据后重新 render 一遍组件，将数据渲染到组件中(Fetch-on-render)。但是这样就会有一些问题，最明显就就是触发<strong>瀑布流</strong> – 第一个组件 render 触发一次网络请求，完了以后 render 第二个组件又触发一次网络请求，但是其实这两个请求可以并发处理。</p>
<p>然后可能有人为了避免这种情况的出现就会来一些技巧，比如我在 render 这两个组件之前先发两次请求，等两次请求都完了我再用数据去 render 组件(Fetch-then-render)。这样的确会解决瀑布流的问题，但是引入了一个新的问题 – 如果第一个请求需要 2s 而第二个请求只需要 500ms，那第二个请求就算已经拿到了数据，也必须等第一个请求完成后才能 render 组件。</p>
<p><code>Suspense</code> 解决了这个问题，它采用了 <code>render-as-you-fetch</code> 的方式。<code>Suspense</code> 会先发起请求，在请求发出的几乎同一时刻就开始组件的渲染，并不会等待请求结果的返回。此时组件会拿到一个特殊的数据结构而不是一个 <code>Promise</code>，而这个数据结构由你选择的 “Promise wrapper” 库（在上文提到过，在我的例子里我用的是 <a href="https://swr.now.sh/" target="_blank" rel="noopener">swr</a>）来提供。由于所需数据还没有准备好，React 会将此组件”挂起“并暂时跳过，继续渲染其他组件，其他组件完成渲染后 React 会渲染离”挂起“组件最近的 <code>Suspense</code> 组件的 fallback。之后等某一个请求成功后，就会继续重新渲染相对应的组件。</p>
<p>在我的例子中我尝试用 <code>Suspense</code> + swr + axios 来实现。</p>
<h4 id="在-parent-中-fetch-data"><a href="#在-parent-中-fetch-data" class="headerlink" title="在 parent 中 fetch data"></a>在 parent 中 fetch data</h4><p>在第一个版本中我尝试在 parent 组件（PageProfile）中先 fetch data，然后在子组件中渲染：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Suspense fallback=&#123;&lt;h1&gt;Loading...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;PageProfile /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PageProfile: React.FC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [id, setId] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; user, postList &#125; = useData(id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function"><span class="params">()</span> =&gt;</span> setId(id + <span class="number">1</span>)&#125;&gt;next&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Profile user=&#123;user&#125; /</span>&gt;</span><br><span class="line">      &lt;ProfileTimeline postList=&#123;postList&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useData = <span class="function">(<span class="params">id: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data: user &#125; = useRequest(</span><br><span class="line">    &#123; baseURL: BASE_API, url: <span class="string">`/api/fake-user/<span class="subst">$&#123;id&#125;</span>`</span>, method: <span class="string">"get"</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      suspense: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> &#123; data: postList &#125; = useRequest(</span><br><span class="line">    &#123; baseURL: BASE_API, url: <span class="string">`/api/fake-list/<span class="subst">$&#123;id&#125;</span>`</span>, method: <span class="string">"get"</span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      suspense: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user,</span><br><span class="line">    postList,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useSWR, &#123; ConfigInterface, responseInterface &#125; <span class="keyword">from</span> <span class="string">"swr"</span>;</span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosError, AxiosRequestConfig, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetRequest = AxiosRequestConfig | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Return&lt;Data, Error&gt;</span><br><span class="line">  <span class="keyword">extends</span> Pick&lt;responseInterface&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;Error&gt;&gt;, "isValidating" | "revalidate" | "error"&gt; &#123;</span><br><span class="line">  data: Data | <span class="literal">undefined</span>;</span><br><span class="line">  response: AxiosResponse&lt;Data&gt; | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Config&lt;Data = unknown, Error = unknown&gt;</span><br><span class="line">  <span class="keyword">extends</span> Omit&lt;ConfigInterface&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;Error&gt;&gt;, "initialData"&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useRequest = &lt;Data = unknown, <span class="built_in">Error</span> = unknown&gt;(</span><br><span class="line">  requestConfig: GetRequest,</span><br><span class="line">  &#123; ...config &#125;: Config&lt;Data, <span class="built_in">Error</span>&gt; = &#123;&#125;,</span><br><span class="line">): Return&lt;Data, <span class="built_in">Error</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data: response, error, isValidating, revalidate &#125; = useSWR&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;<span class="built_in">Error</span>&gt;&gt;(</span><br><span class="line">    requestConfig &amp;&amp; <span class="built_in">JSON</span>.stringify(requestConfig),</span><br><span class="line">    () =&gt; axios(requestConfig!),</span><br><span class="line">    &#123;</span><br><span class="line">      ...config,</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    data: response &amp;&amp; response.data,</span><br><span class="line">    response,</span><br><span class="line">    error,</span><br><span class="line">    isValidating,</span><br><span class="line">    revalidate,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是不知道是不是我的写法有问题，有几个问题我死活没弄明白：</p>
<ul>
<li>为了实现 <code>render-as-you-fetch</code>，文档中有提到过可以尽可能早的 fetch data，从而可以让 render 和 fetch 并行并且缩短拿到 data 的时间（如果我理解没错的话）<ul>
<li>我的想法是先在 parent 组件中 fetch data，然后用两个 <code>Suspense</code> 将 <code>Profile</code> 组件和 <code>ProfileTimeline</code> 组件包起来，然后就能够在拿到相对应的数据（user 和 postList）之后渲染相对应的组件</li>
<li>但是在使用的过程中我发现 ”在哪个组件中 fetch data，就必须用 <code>Suspense</code> 将这个组件包起来，否则就会报错“，所以这里我将整个 <code>PageProfile</code> 包了起来。而这个时候就算我用两个 <code>Suspense</code> 将 <code>Profile</code> 组件和 <code>ProfileTimeline</code> 组件包起来也没办法实现两条加载信息，只会显示最外层的 loading，也就没有办法实现 <code>render-as-you-fetch</code></li>
<li>swr 在这样的写法下会多发一次莫名其妙的请求，目前还没有找到原因<ul>
<li><img src="https://teobler-image.s3-us-west-1.amazonaws.com/031513.png" alt="image-20200515111513161"></li>
<li>图中第一个第二个请求分别是请求的 user 和 postList 数据，但是在完了之后又请求了一次 user</li>
</ul>
</li>
</ul>
</li>
<li>swr 目前还没有实现在 <code>Suspense</code> 模式下避免 waterfall，所以两个请求会依次发出去，等待时间是总和，不过翻看github已经有 <a href="https://github.com/zeit/swr/pull/168" target="_blank" rel="noopener">pr</a> 在解决这个问题了，目前来看处于codereview的阶段</li>
</ul>
<h4 id="在当前组件中-fetch-data"><a href="#在当前组件中-fetch-data" class="headerlink" title="在当前组件中 fetch data"></a>在当前组件中 fetch data</h4><p>为了解决上面的问题，我换了一种写法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [id, setId] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function"><span class="params">()</span> =&gt;</span> setId(id + <span class="number">1</span>)&#125;&gt;next&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;/</span>h1&gt;&#125;&gt;</span><br><span class="line">        &lt;Profile id=&#123;id&#125; /&gt;</span><br><span class="line">        &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ProfileTimeline id=&#123;id&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Suspense&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Profile: React.FC&lt;&#123; id: <span class="built_in">number</span> &#125;&gt; = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data: user &#125; = useRequest(&#123; baseURL: BASE_API, url: <span class="string">`/api/fake-user/<span class="subst">$&#123;id&#125;</span>`</span>, method: <span class="string">"get"</span> &#125;, &#123; suspense: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ProfileTimeline: React.FC&lt;&#123; id: <span class="built_in">number</span> &#125;&gt; = <span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data: postList &#125; = useRequest(</span><br><span class="line">    &#123; baseURL: BASE_API, url: <span class="string">`/api/fake-list/<span class="subst">$&#123;id&#125;</span>`</span>, method: <span class="string">"get"</span> &#125;,</span><br><span class="line">    &#123; suspense: <span class="literal">true</span> &#125;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;postList.data.map(<span class="function">(<span class="params">listData: &#123; id: <span class="built_in">number</span>; text: <span class="built_in">string</span> &#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;listData.id&#125;&gt;&#123;listData.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时我将对应的请求放在子组件内，这样的写法不管是两个组件 loading 的状态，还是网络请求都是正常的了，但是按照我的理解这样的写法是不符合 React 的初衷的，在<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early" target="_blank" rel="noopener">文档</a>中 React 提倡在顶层（比如上层组件）先 kick off 网络请求，然后先不管结果，开始组件的渲染：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resource = fetchProfileData();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileDetails /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileDetails</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = resource.user.read();</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;user.name&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ProfileTimeline() &#123;</span></span><br><span class="line"><span class="regexp">  const posts = resource.posts.read();</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &#123;posts.map(post =&gt; (</span></span><br><span class="line"><span class="regexp">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;/</span>li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是目前这种写法很明显是开始渲染子组件了才发的网络请求。关于这个问题我会等 swr merge完最新的 pr 更新下一个版本后再进行实验。</p>
<h3 id="one-more-thing"><a href="#one-more-thing" class="headerlink" title="one more thing"></a>one more thing</h3><p>除了上面介绍过的以外， <code>Suspense</code> 还给开发者带来了另外一个好处 – 你不用再写 race condition 了。</p>
<p>在之前的请求方式中，首次渲染组件的时候你是拿不到任何数据的，此时你需要写一个类似于这样的判断：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (requestStage !== RequestStage.SUCCESS) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>而在同一个项目中经不同人的手还会有这样的判断：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (requestStage === RequestStage.START) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>而如果请求挂了，你还得这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> requestStage === RequestStage.FAILED ? (</span><br><span class="line">  &lt;SomeComponentYouWantToShow /&gt;</span><br><span class="line">) : (</span><br><span class="line">  &lt;YourComponent /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这堆东西就是一堆模板代码，有些时候还容易脑抽就忘加了，在 <code>Suspense</code> 下，你再也不用写这些东西了，数据没拿到会直接渲染 <code>Suspense</code> 的 fallback，至于请求错误，在外层加一个 <a href="https://reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">error boundary</a> 就行了，这里就不过多展开了，详见<a href="https://reactjs.org/docs/concurrent-mode-suspense.html#handling-errors" target="_blank" rel="noopener">文档</a>。</p>
<p>总的来说 <code>Suspense</code> 的初衷是好的，可以提升用户体验，可能现在各个工具包括 React 本身还处于实验阶段，还多多少少会有一些问题，接下来我会尝试去找找怎么解决这些问题再回来更新。下一篇我会接着躺坑 UI 部分。</p>

    
  </div>
</article>

  </div>
  <aside id="aside-bar">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Concurrent-Mode"><span class="toc-text">Concurrent Mode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WHAT"><span class="toc-text">WHAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOW"><span class="toc-text">HOW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可停止的rendering-Interruptible-Rendering"><span class="toc-text">可停止的rendering (Interruptible Rendering)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可选的加载顺序-Intentional-Loading-Sequences"><span class="toc-text">可选的加载顺序(Intentional Loading Sequences)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Suspense"><span class="toc-text">Suspense</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开始前的准备"><span class="toc-text">开始前的准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Fetching"><span class="toc-text">Data Fetching</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在-parent-中-fetch-data"><span class="toc-text">在 parent 中 fetch data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在当前组件中-fetch-data"><span class="toc-text">在当前组件中 fetch data</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#one-more-thing"><span class="toc-text">one more thing</span></a></li></ol></li></ol>
  </div>


    
  <div id="recent-post" class="recent-post">
    <strong class="recent-post-title">
      近期文章
    </strong>
    <ul class="recent-post-list">
      
         <li class="recent-post-list">
           <a href="/20200523-devtool-performance-networking-auditing-and-node.html" title="(2)你真的会用Chrome devtool吗?" >(2)你真的会用Chrome devtool吗?</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200516-react-concurrent-mode-suspense.html" title="React Concurrent Mode 之 Suspense 实践" >React Concurrent Mode 之 Suspense 实践</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200304-devtool-editing-and-debugging.html" title="(1)你真的会用Chrome devtool吗?" >(1)你真的会用Chrome devtool吗?</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200222-webpack-core-concepts.html" title="Webpack原理(3) — 核心概念" >Webpack原理(3) — 核心概念</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200219-first-in-webpack.html" title="Webpack原理(2) — 加载原理" >Webpack原理(2) — 加载原理</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200211-tdd-with-react-hooks.html" title="用React hooks实现TDD" >用React hooks实现TDD</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20200107-reduce-bundle-size.html" title="如何减小前端代码打包体积" >如何减小前端代码打包体积</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20190906-error-handler.html" title="React中的错误处理" >React中的错误处理</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20190903-compose.html" title="函数式初识(6) - 组合" >函数式初识(6) - 组合</a>
         </li>
      
         <li class="recent-post-list">
           <a href="/20190831-partial-and-currying.html" title="函数式初识(5) - 偏函数和柯里化" >函数式初识(5) - 偏函数和柯里化</a>
         </li>
      
    </ul>
  </div>


  </aside>
</div>




  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/20200304-devtool-editing-and-debugging.html">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/20200523-devtool-performance-networking-auditing-and-node.html">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'teobler';
    
    var disqus_url = 'https://teobler.com/20200516-react-concurrent-mode-suspense.html';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//teobler.disqus.com/count.js" async></script>



    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
