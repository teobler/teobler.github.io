[{"title":"React Concurrent Mode 之 Suspense 实践","url":"https://teobler.com/20200516-react-concurrent-mode-suspense.html","content":"<p>自从三大框架成型之后，各个框架都为提升开发者的开发效率作出了不少努力，但是看起来技术革新都到了一个瓶颈。除了 React 引入了一次函数式的思想，感觉已经没有当初从DOM时代到数据驱动时代的惊艳感了。于是 React 将精力放在了用户体验上，想让开发者在不过多耗费精力的情况下，用框架自身去提升用户体验。</p>\n<p>于是在最近的几个版本中，React 引入了一个叫做 <code>Concurrent Mode</code> 的东西，同时还引入了 <code>Suspense</code>，旨在提升用户的访问体验，React 应用在慢慢变大以后会慢慢变得越来越卡，这次的新功能就是想在应用初期就解决这些问题。</p>\n<p>虽然现在这些功能还处在实验阶段，React 团队并不建议在生产环境中使用，不过大部分功能已经完成了，而且他们已经用在了新的网站功能中，所以面对这样一个相对成熟的技术，其实我们还是可以来自己玩一下的，接下来我来带领大家看看这是一个什么样的东西吧。</p>\n<h2 id=\"Concurrent-Mode\"><a href=\"#Concurrent-Mode\" class=\"headerlink\" title=\"Concurrent Mode\"></a>Concurrent Mode</h2><h3 id=\"WHAT\"><a href=\"#WHAT\" class=\"headerlink\" title=\"WHAT\"></a>WHAT</h3><p>那么这个 <code>Concurrent Mode</code> 是个啥呢？</p>\n<blockquote>\n<p>Concurrent Mode is a set of new features that help React apps stay responsive and gracefully adjust to the user’s device capabilities and network speed.</p>\n</blockquote>\n<p>在官网的解释中， <code>Concurrent Mode</code> 包含了一系列新功能，这些新功能可以根据用户不同的设备性能和不同的网速进行不同的响应，以使得用户在不同的设备和网速的情况下拥有最好的访问体验。那么问题来了，它是怎么做到这一点的呢？</p>\n<h3 id=\"HOW\"><a href=\"#HOW\" class=\"headerlink\" title=\"HOW\"></a>HOW</h3><h4 id=\"可停止的rendering-Interruptible-Rendering\"><a href=\"#可停止的rendering-Interruptible-Rendering\" class=\"headerlink\" title=\"可停止的rendering (Interruptible Rendering)\"></a>可停止的rendering (Interruptible Rendering)</h4><p>在通常状况下，React 在 render 的时候是没有办法被打断的（这其中有创建新的 DOM 节点等等），rendering 的过程会一直占用 JS 线程，导致此时浏览器无法对用户的操作进行实时反馈，造成了一种整个页面很卡的感觉。</p>\n<p>而在 <code>Concurrent Mode</code> 下，rendering 是可以被打断的，这意味着 React 可以让出主线程给浏览器用于更紧急的用户操作。</p>\n<p>想象这样一个通用的场景：用户在一个输入框中检索一些信息，输入框中的文字改变后页面都将重新渲染以展示最新的结果，但是你会发现每一次输入都会卡顿，因为每一次重新渲染都将阻塞主线程，浏览器就将没有办法相应用户在输入框中的输入。当然现在通用的解决办法是用 <code>debouncing</code> 或者 <code>throtting</code>。但是这个方式存在一些问题，首先是页面没有办法实时反应用户的输入，用户会发现可能输入了好多个字符页面才刷新一次，不会实时更新；第二个问题是在性能比较差的设备上还是会出现卡顿的情况。</p>\n<p>如果在页面正在 render 时用户输入了新的字符，React 可以暂停 render 让浏览器优先对用户的输入进行更新，然后 React 会在<strong>内存中</strong>渲染最新的页面，等到第一次 render 完成后再直接将最新的页面更新出来，保证用户能看到最新的页面。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/030546.png\" alt=\"image-20200516110545540\"></p>\n<p>这个过程有点像 git 的多分支，主分支是用户能够看到的并且是可以被暂停的，React 会新起一个分支来做最新的渲染，当主分支的渲染完成后就将新的分支合并过来，得到最新的视图。</p>\n<h4 id=\"可选的加载顺序-Intentional-Loading-Sequences\"><a href=\"#可选的加载顺序-Intentional-Loading-Sequences\" class=\"headerlink\" title=\"可选的加载顺序(Intentional Loading Sequences)\"></a>可选的加载顺序(Intentional Loading Sequences)</h4><p>在页面跳转的时候，为了提升用户体验，我们往往会在新的页面中加上 <code>skeleton</code>，这是为了防止要渲染的数据还没有拿到，用户看到一个空白的页面。</p>\n<p>在 <code>Concurrent Mode</code> 中，我们可以让 React 在第一个页面多停留一会，此时 React 会在内存中用拿到的数据渲染新的页面，等页面渲染完成后再直接跳转到一个已经完成了的页面上，这个行为要更加符合用户直觉。而且需要说明的是，在第一个页面等待的时间里，用户的任何操作都是可以被捕捉到的，也就是说在等待时间内并不会 block 用户的任何操作。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>总结一下就是，新的 <code>Concurrent Mode</code> 可以让 React 同时在不同的状态下进行并行处理，在并行状态结束后又将所有改变合并起来。这个功能主要聚焦在两点上：</p>\n<ul>\n<li>对于 CPU 来说（比如创建 DOM 节点），这样的并行意味着优先级更高的更新可以打断 rendering</li>\n<li>对于 IO 来说（比如从服务端拿数据），这样的并行意味着 React 可以将先拿到的一部分数据用于在内存中构建 DOM，全部构建完成后在进行一次性的渲染，同时不影响当前页面</li>\n</ul>\n<p>而对于开发者来说，React 的使用方式并没有太大的变化，你以前怎么写的 React，将来还是怎么写，不会让开发者有断层的感受。下面我们可以通过几个例子来看看具体怎么使用。</p>\n<h2 id=\"Suspense\"><a href=\"#Suspense\" class=\"headerlink\" title=\"Suspense\"></a>Suspense</h2><h3 id=\"开始前的准备\"><a href=\"#开始前的准备\" class=\"headerlink\" title=\"开始前的准备\"></a>开始前的准备</h3><p>与之前的功能不同的是，<code>Concurrent Mode</code> 需要开发者手动开启（只是使用 <code>Suspense</code> 貌似不用开启，但是我为了下一篇文章的代码，现在就先开启了）。为了方(tou)便(lan)，我们用 cra 创建一个新的项目，为了使用 <code>Concurrent Mode</code> 我们需要做如下修改：</p>\n<ul>\n<li><p>删除项目中的react版本，该用实验版 <code>npm install react@experimental react-dom@experimental</code></p>\n</li>\n<li><p>为了正常使用 <strong>TypeScript</strong> 在 <code>react-app-env.d.ts</code> 文件中加入实验版 React 的 type 引用</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference types=\"react-dom/experimental\" /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference types=\"react/experimental\" /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 <code>index.tsx</code> 中开启 <code>Concurrent Mode</code> </p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.unstable_createRoot(</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"root\"</span>) <span class=\"keyword\">as</span> HTMLElement</span><br><span class=\"line\">).render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 <code>Suspense</code> 中如果你需要在拿后端数据时”挂起“你的组件，<a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#using-suspense-in-practice\" target=\"_blank\" rel=\"noopener\">你需要一个按照 React 要求实现的 “Promise Wrapper”</a>，在这里我选择的是 <a href=\"https://swr.now.sh/\" target=\"_blank\" rel=\"noopener\">swr</a> </p>\n<ul>\n<li>从后面的结果来看，目前 swr 对于 <code>Suspense</code> 的实现还没有完成，但是已经有一个 pr 了</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>本文中所有的代码都可以在我的 <a href=\"https://github.com/teobler/concurrent-mode-demo\" target=\"_blank\" rel=\"noopener\">github repo</a> 里找到，建议时间充裕的同学 clone 一份和文章一同食用效果更佳。</p>\n</blockquote>\n<h3 id=\"Data-Fetching\"><a href=\"#Data-Fetching\" class=\"headerlink\" title=\"Data Fetching\"></a>Data Fetching</h3><p>React 团队在 16.6 中加入了一个新的组件 <code>Suspense</code> ，<code>Suspense</code> 与其说是一个组件，更多的可以说是一种机制。这个组件可以在子节点渲染的时候进行”挂起“，渲染一个你设定好的等待图标之类的组件，等子节点渲染完成后再显示子节点。在 <code>Concurrent Mode</code> 之前，该组件通常用来作懒加载：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ProfilePage = React.lazy(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./ProfilePage'</span>)); <span class=\"comment\">// Lazy-loaded</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Show a spinner while the profile is loading</span></span><br><span class=\"line\">&lt;Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class=\"line\">  &lt;ProfilePage /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在最新的 React 版本中，现在 <code>Suspense</code> 组件可以用来”挂起“任何东西，比如可以在从服务端拿数据的时候”挂起“某个组件，比如一个图片，比如一段脚本等等。我们在这里仅仅以从后端拿数据为例。</p>\n<p>在传统的数据获取中，往往是组件先 render 然后再去后端获取数据，拿到数据后重新 render 一遍组件，将数据渲染到组件中(Fetch-on-render)。但是这样就会有一些问题，最明显就就是触发<strong>瀑布流</strong> – 第一个组件 render 触发一次网络请求，完了以后 render 第二个组件又触发一次网络请求，但是其实这两个请求可以并发处理。</p>\n<p>然后可能有人为了避免这种情况的出现就会来一些技巧，比如我在 render 这两个组件之前先发两次请求，等两次请求都完了我再用数据去 render 组件(Fetch-then-render)。这样的确会解决瀑布流的问题，但是引入了一个新的问题 – 如果第一个请求需要 2s 而第二个请求只需要 500ms，那第二个请求就算已经拿到了数据，也必须等第一个请求完成后才能 render 组件。</p>\n<p><code>Suspense</code> 解决了这个问题，它采用了 <code>render-as-you-fetch</code> 的方式。<code>Suspense</code> 会先发起请求，在请求发出的几乎同一时刻就开始组件的渲染，并不会等待请求结果的返回。此时组件会拿到一个特殊的数据结构而不是一个 <code>Promise</code>，而这个数据结构由你选择的 “Promise wrapper” 库（在上文提到过，在我的例子里我用的是 <a href=\"https://swr.now.sh/\" target=\"_blank\" rel=\"noopener\">swr</a>）来提供。由于所需数据还没有准备好，React 会将此组件”挂起“并暂时跳过，继续渲染其他组件，其他组件完成渲染后 React 会渲染离”挂起“组件最近的 <code>Suspense</code> 组件的 fallback。之后等某一个请求成功后，就会继续重新渲染相对应的组件。</p>\n<p>在我的例子中我尝试用 <code>Suspense</code> + swr + axios 来实现。</p>\n<h4 id=\"在-parent-中-fetch-data\"><a href=\"#在-parent-中-fetch-data\" class=\"headerlink\" title=\"在 parent 中 fetch data\"></a>在 parent 中 fetch data</h4><p>在第一个版本中我尝试在 parent 组件（PageProfile）中先 fetch data，然后在子组件中渲染：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> App: React.FC = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;Suspense fallback=&#123;&lt;h1&gt;Loading...&lt;<span class=\"regexp\">/h1&gt;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;PageProfile /</span>&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Suspense&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> PageProfile: React.FC = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [id, setId] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; user, postList &#125; = useData(id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setId(id + <span class=\"number\">1</span>)&#125;&gt;next&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Profile user=&#123;user&#125; /</span>&gt;</span><br><span class=\"line\">      &lt;ProfileTimeline postList=&#123;postList&#125; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useData = <span class=\"function\">(<span class=\"params\">id: <span class=\"built_in\">number</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; data: user &#125; = useRequest(</span><br><span class=\"line\">    &#123; baseURL: BASE_API, url: <span class=\"string\">`/api/fake-user/<span class=\"subst\">$&#123;id&#125;</span>`</span>, method: <span class=\"string\">\"get\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      suspense: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; data: postList &#125; = useRequest(</span><br><span class=\"line\">    &#123; baseURL: BASE_API, url: <span class=\"string\">`/api/fake-list/<span class=\"subst\">$&#123;id&#125;</span>`</span>, method: <span class=\"string\">\"get\"</span> &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      suspense: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    user,</span><br><span class=\"line\">    postList,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> useSWR, &#123; ConfigInterface, responseInterface &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"swr\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> axios, &#123; AxiosError, AxiosRequestConfig, AxiosResponse &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> GetRequest = AxiosRequestConfig | <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Return&lt;Data, Error&gt;</span><br><span class=\"line\">  <span class=\"keyword\">extends</span> Pick&lt;responseInterface&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;Error&gt;&gt;, \"isValidating\" | \"revalidate\" | \"error\"&gt; &#123;</span><br><span class=\"line\">  data: Data | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  response: AxiosResponse&lt;Data&gt; | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Config&lt;Data = unknown, Error = unknown&gt;</span><br><span class=\"line\">  <span class=\"keyword\">extends</span> Omit&lt;ConfigInterface&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;Error&gt;&gt;, \"initialData\"&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> useRequest = &lt;Data = unknown, <span class=\"built_in\">Error</span> = unknown&gt;(</span><br><span class=\"line\">  requestConfig: GetRequest,</span><br><span class=\"line\">  &#123; ...config &#125;: Config&lt;Data, <span class=\"built_in\">Error</span>&gt; = &#123;&#125;,</span><br><span class=\"line\">): Return&lt;Data, <span class=\"built_in\">Error</span>&gt; =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; data: response, error, isValidating, revalidate &#125; = useSWR&lt;AxiosResponse&lt;Data&gt;, AxiosError&lt;<span class=\"built_in\">Error</span>&gt;&gt;(</span><br><span class=\"line\">    requestConfig &amp;&amp; <span class=\"built_in\">JSON</span>.stringify(requestConfig),</span><br><span class=\"line\">    () =&gt; axios(requestConfig!),</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...config,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    data: response &amp;&amp; response.data,</span><br><span class=\"line\">    response,</span><br><span class=\"line\">    error,</span><br><span class=\"line\">    isValidating,</span><br><span class=\"line\">    revalidate,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是不知道是不是我的写法有问题，有几个问题我死活没弄明白：</p>\n<ul>\n<li>为了实现 <code>render-as-you-fetch</code>，文档中有提到过可以尽可能早的 fetch data，从而可以让 render 和 fetch 并行并且缩短拿到 data 的时间（如果我理解没错的话）<ul>\n<li>我的想法是先在 parent 组件中 fetch data，然后用两个 <code>Suspense</code> 将 <code>Profile</code> 组件和 <code>ProfileTimeline</code> 组件包起来，然后就能够在拿到相对应的数据（user 和 postList）之后渲染相对应的组件</li>\n<li>但是在使用的过程中我发现 ”在哪个组件中 fetch data，就必须用 <code>Suspense</code> 将这个组件包起来，否则就会报错“，所以这里我将整个 <code>PageProfile</code> 包了起来。而这个时候就算我用两个 <code>Suspense</code> 将 <code>Profile</code> 组件和 <code>ProfileTimeline</code> 组件包起来也没办法实现两条加载信息，只会显示最外层的 loading，也就没有办法实现 <code>render-as-you-fetch</code></li>\n<li>swr 在这样的写法下会多发一次莫名其妙的请求，目前还没有找到原因<ul>\n<li><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/031513.png\" alt=\"image-20200515111513161\"></li>\n<li>图中第一个第二个请求分别是请求的 user 和 postList 数据，但是在完了之后又请求了一次 user</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>swr 目前还没有实现在 <code>Suspense</code> 模式下避免 waterfall，所以两个请求会依次发出去，等待时间是总和，不过翻看github已经有 <a href=\"https://github.com/zeit/swr/pull/168\" target=\"_blank\" rel=\"noopener\">pr</a> 在解决这个问题了，目前来看处于codereview的阶段</li>\n</ul>\n<h4 id=\"在当前组件中-fetch-data\"><a href=\"#在当前组件中-fetch-data\" class=\"headerlink\" title=\"在当前组件中 fetch data\"></a>在当前组件中 fetch data</h4><p>为了解决上面的问题，我换了一种写法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> App: React.FC = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [id, setId] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setId(id + <span class=\"number\">1</span>)&#125;&gt;next&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;/</span>h1&gt;&#125;&gt;</span><br><span class=\"line\">        &lt;Profile id=&#123;id&#125; /&gt;</span><br><span class=\"line\">        &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class=\"regexp\">/h1&gt;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">          &lt;ProfileTimeline id=&#123;id&#125; /</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/Suspense&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>Suspense&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Profile: React.FC&lt;&#123; id: <span class=\"built_in\">number</span> &#125;&gt; = <span class=\"function\">(<span class=\"params\">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; data: user &#125; = useRequest(&#123; baseURL: BASE_API, url: <span class=\"string\">`/api/fake-user/<span class=\"subst\">$&#123;id&#125;</span>`</span>, method: <span class=\"string\">\"get\"</span> &#125;, &#123; suspense: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123;user.name&#125;&lt;<span class=\"regexp\">/h1&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ProfileTimeline: React.FC&lt;&#123; id: <span class=\"built_in\">number</span> &#125;&gt; = <span class=\"function\">(<span class=\"params\">&#123; id &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; data: postList &#125; = useRequest(</span><br><span class=\"line\">    &#123; baseURL: BASE_API, url: <span class=\"string\">`/api/fake-list/<span class=\"subst\">$&#123;id&#125;</span>`</span>, method: <span class=\"string\">\"get\"</span> &#125;,</span><br><span class=\"line\">    &#123; suspense: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &#123;postList.data.map(<span class=\"function\">(<span class=\"params\">listData: &#123; id: <span class=\"built_in\">number</span>; text: <span class=\"built_in\">string</span> &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">        &lt;li key=&#123;listData.id&#125;&gt;&#123;listData.text&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/u</span>l&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>此时我将对应的请求放在子组件内，这样的写法不管是两个组件 loading 的状态，还是网络请求都是正常的了，但是按照我的理解这样的写法是不符合 React 的初衷的，在<a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early\" target=\"_blank\" rel=\"noopener\">文档</a>中 React 提倡在顶层（比如上层组件）先 kick off 网络请求，然后先不管结果，开始组件的渲染：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> resource = fetchProfileData();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ProfilePage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;<span class=\"regexp\">/h1&gt;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;ProfileDetails /</span>&gt;</span><br><span class=\"line\">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class=\"regexp\">/h1&gt;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;ProfileTimeline /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/Suspense&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>Suspense&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ProfileDetails</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = resource.user.read();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;&#123;user.name&#125;&lt;<span class=\"regexp\">/h1&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">function ProfileTimeline() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  const posts = resource.posts.read();</span></span><br><span class=\"line\"><span class=\"regexp\">  return (</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &#123;posts.map(post =&gt; (</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;/</span>li&gt;</span><br><span class=\"line\">      ))&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>但是目前这种写法很明显是开始渲染子组件了才发的网络请求。关于这个问题我会等 swr merge完最新的 pr 更新下一个版本后再进行实验。</p>\n<h3 id=\"one-more-thing\"><a href=\"#one-more-thing\" class=\"headerlink\" title=\"one more thing\"></a>one more thing</h3><p>除了上面介绍过的以外， <code>Suspense</code> 还给开发者带来了另外一个好处 – 你不用再写 race condition 了。</p>\n<p>在之前的请求方式中，首次渲染组件的时候你是拿不到任何数据的，此时你需要写一个类似于这样的判断：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (requestStage !== RequestStage.SUCCESS) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>而在同一个项目中经不同人的手还会有这样的判断：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (requestStage === RequestStage.START) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>而如果请求挂了，你还得这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> requestStage === RequestStage.FAILED ? (</span><br><span class=\"line\">  &lt;SomeComponentYouWantToShow /&gt;</span><br><span class=\"line\">) : (</span><br><span class=\"line\">  &lt;YourComponent /&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>这堆东西就是一堆模板代码，有些时候还容易脑抽就忘加了，在 <code>Suspense</code> 下，你再也不用写这些东西了，数据没拿到会直接渲染 <code>Suspense</code> 的 fallback，至于请求错误，在外层加一个 <a href=\"https://reactjs.org/docs/error-boundaries.html\" target=\"_blank\" rel=\"noopener\">error boundary</a> 就行了，这里就不过多展开了，详见<a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html#handling-errors\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<p>总的来说 <code>Suspense</code> 的初衷是好的，可以提升用户体验，可能现在各个工具包括 React 本身还处于实验阶段，还多多少少会有一些问题，接下来我会尝试去找找怎么解决这些问题再回来更新。下一篇我会接着躺坑 UI 部分。</p>\n","categories":["技术"],"tags":["React","Concurrent Mode"]},{"title":"(1)你真的会用Chrome devtool吗?","url":"https://teobler.com/20200304-devtool-editing-and-debugging.html","content":"<p>这是一个介绍Chrome devtool的系列文章，虽然这是一个前端小伙伴们都很熟悉的东西，但是我相信它的很多还不错的功能其实或许你并不知道，这个系列的文章会涉及到: 代码修改、debug、network、audit、monitor等等。</p>\n<p>第一篇我们会介绍如何在devtool中做编辑和debug。</p>\n<h2 id=\"Editing\"><a href=\"#Editing\" class=\"headerlink\" title=\"Editing\"></a>Editing</h2><h3 id=\"编辑HTML和CSS\"><a href=\"#编辑HTML和CSS\" class=\"headerlink\" title=\"编辑HTML和CSS\"></a>编辑HTML和CSS</h3><p>首先是大家熟悉的HTML和Style，在elements的tab下，只需要双击某个元素的内容即可进入编辑模式，这时你可以随意修改其中的内容，同理在其右边的style栏，你可以使用相同的方式修改CSS样式。</p>\n<h3 id=\"保存你自己的调色板\"><a href=\"#保存你自己的调色板\" class=\"headerlink\" title=\"保存你自己的调色板\"></a>保存你自己的调色板</h3><p>在style栏中，点击任意颜色图标，你就可以打开一个调色板，此时再点击第二行的箭头，你就能打开一个预设的调色板保存界面。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/color-palette-popup.png\" alt=\"color-palette-popup\"></p>\n<p>里面预先保存了Material UI的配色方案，你也可以保存你自己的配色方案，这对于自己一个人想要开发一个项目却为配色方案捉急的开发者提供了便利，你可以平时收集一套你自己的配色方案进行保存并随时取用，因为这个调色板还提供了当前网站的配色方案，也就是说你可以打开一个你觉得配色不错的网站保存它的配色。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/default-color-palette.png\" alt=\"default-color-palette\"></p>\n<h3 id=\"滚动某个元素到页面内\"><a href=\"#滚动某个元素到页面内\" class=\"headerlink\" title=\"滚动某个元素到页面内\"></a>滚动某个元素到页面内</h3><p>这个功能对于一些无限滚动的网站开发更有用，比如你在elements tab下找到了你的目标元素，但是你想看看它长得像不像你想象中的样子，没有这个功能的话你就需要一直找，此时你只需要右键那个元素，选择<code>Scroll into view</code>即可。</p>\n<h3 id=\"隐藏和显示元素\"><a href=\"#隐藏和显示元素\" class=\"headerlink\" title=\"隐藏和显示元素\"></a>隐藏和显示元素</h3><p>你可以在某个元素上右键选择隐藏某个元素，其原理是Chrome为其加了一个visibility为hidden的class，右键又可以显示，当然你还可以选择删除，想让它回来的话<code>ctrl/command z</code>即可。</p>\n<h3 id=\"元素状态的改变\"><a href=\"#元素状态的改变\" class=\"headerlink\" title=\"元素状态的改变\"></a>元素状态的改变</h3><p>如图所示，选中某个元素后再点击:hov可以打开一个状态面板，这可以帮助你看清楚不同状态下该元素的CSS样式。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/various-states.png\" alt=\"various-states\"></p>\n<h3 id=\"显性样式\"><a href=\"#显性样式\" class=\"headerlink\" title=\"显性样式\"></a>显性样式</h3><p>在一个复杂的项目中，可能同一个元素上你覆盖了很多个样式，就拿body元素来说，浏览器有一个默认的样式，然后可能你使用了一些reset的样式，同时你在某个文件中还加入了别的样式，如果这个时候你想知道body的样式究竟是哪里来的，如果你用眼睛在styles的tab里面找就会很难。</p>\n<p>这个时候我们可以选择第二个tab <code>Computed</code> 在这个tab里是最终显示在页面上的样式，并且如果你点击某个样式右边的按钮，就会跳转回style tab并把这个生效的样式高亮出来，帮助你快速找出准确的class。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/computed-styles.png\" alt=\"computed-styles\"></p>\n<h3 id=\"查找事件监听\"><a href=\"#查找事件监听\" class=\"headerlink\" title=\"查找事件监听\"></a>查找事件监听</h3><p>这个功能可以找到当前页面中的所有时间监听函数，并且点击右边的超链接可以跳转到对应的代码，这个功能在你“知道某个bug是因为某个监听引起的，但是不知道这个监听函数在哪”的时候很有用。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/event.png\" alt=\"event\"></p>\n<h3 id=\"改变颜色格式\"><a href=\"#改变颜色格式\" class=\"headerlink\" title=\"改变颜色格式\"></a>改变颜色格式</h3><p>在任意颜色上按住shift + 左键可以改变颜色的格式(rgb, hsl, hex)，可以方便的帮助你改变网站的颜色与设计相一致。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/color-format.png\" alt=\"color-format\"></p>\n<h3 id=\"源代码format\"><a href=\"#源代码format\" class=\"headerlink\" title=\"源代码format\"></a>源代码format</h3><p>通常在prod环境的代码都经过压缩，这会导致我们在看源代码的时候所有代码被压缩到同一行导致不可读，这时我们可以点击format按钮使得代码变回在编辑器中的样子。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/pretty-print.png\" alt=\"pretty-print\"></p>\n<h3 id=\"DOM断点\"><a href=\"#DOM断点\" class=\"headerlink\" title=\"DOM断点\"></a>DOM断点</h3><p>有一些代码会影响DOM的渲染，然后如果这些代码产生了相应的bug，比如渲染出来的DOM不是你想的哪样，这时我们可以在DOM上打断点，这时如果DOM发生了改变，Chrome就会跳转的相应的代码的debug界面，是一个方便的debug方式。</p>\n<p>可以选择在 子节点改变 / 属性改变 / 节点被删除 时进行断点调试。</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/DOM-break-on.png\" alt=\"DOM-break-on\"></p>\n<h3 id=\"元素选择历史\"><a href=\"#元素选择历史\" class=\"headerlink\" title=\"元素选择历史\"></a>元素选择历史</h3><p>在HTML的界面，你选中某一个元素，然后打开console界面，输入$0将输出你刚刚选中的元素，$1则是你之前选中的上一个元素，以此类推，这可以帮助你在console页面对这个DOM节点做一些调试，不用你手动选择，同时需要说明的是Chrome的console页面是内置了一部分jQuery的，比如$选择器。</p>\n<p>这里有一个<a href=\"https://masteringdevtools.com/exercises/editing\" target=\"_blank\" rel=\"noopener\">小练习</a>看你能不能用上边的知识完成。</p>\n<h2 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h2><p>第二个我们用的比较多的功能就是debug了，这篇文章我们会介绍如何使用Chrome devtool来进行debug。</p>\n<h3 id=\"断点调试方法\"><a href=\"#断点调试方法\" class=\"headerlink\" title=\"断点调试方法\"></a>断点调试方法</h3><p>第一种debug的方式是当你在本地启动了你的dev server，并且在你想要打断点的代码处写上<code>debugger</code>关键字，那么当你打开devtool访问你的页面并刷新页面时你就能停在<code>debugger</code>的地方。</p>\n<p>第二种方式是打开devtool的sources tab，找到你想debug的文件(cmd + p / cmd + shift + p)，然后在行号上点击，就会加上一个蓝色标记，这时如果你刷新页面也可以进入断点调试。</p>\n<h3 id=\"调试面板结构\"><a href=\"#调试面板结构\" class=\"headerlink\" title=\"调试面板结构\"></a>调试面板结构</h3><p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/debug-panel.png\" alt=\"debug-panel\"></p>\n<ul>\n<li>Watch可以添加变量或者一段代码进行一些运算，这些变量或者运算会随着你的断点的变化而变化进行实时更新，方便进行调试，需要注意的是如果当前断点的上下文中找不到这个变量，会显示<code>undefined</code></li>\n<li>Call Stack就是调用栈，可以看到当前断点的调用信息，点击不同的行，可以跳转到不同的调用处</li>\n<li>Scope显示了当前你可以访问的所有上下文</li>\n<li>Breakpoints显示了你的所有断点，可以方便的在各个断点处跳转，也可以当做开关来用，可以在此处选择忽略哪些断点，或是直接删除不需要的断点</li>\n<li>XHR Breakpoints可以添加网络请求的断点</li>\n<li>DOM Breakpoints就是之前讲过的DOM断点</li>\n<li>同理Event Listener Breakpoints可以在触发相应的事件时产生断点进行调试</li>\n</ul>\n<h3 id=\"跳过黑盒代码\"><a href=\"#跳过黑盒代码\" class=\"headerlink\" title=\"跳过黑盒代码\"></a>跳过黑盒代码</h3><p>有时候我们会想要看看我们的当前的函数调用栈，但是通常来说我们会在我们的app里面引入许多第三方库，比如React，那么在你看调用栈的时候，你就会进入到React的调用栈中，然而我们并不想看React，所以我们可以选择隐藏这些调用栈:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/blackbox-script.png\" alt=\"blackbox-script\"></p>\n<p>或者你嫌麻烦的话，可以直接在devtool的设置里将整个库都给隐藏:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/blackbox-setting.png\" alt=\"blackbox-setting\"></p>\n<h3 id=\"条件断点和XHR断点\"><a href=\"#条件断点和XHR断点\" class=\"headerlink\" title=\"条件断点和XHR断点\"></a>条件断点和XHR断点</h3><p>想象一个场景，我们的某个地方用到了我们代码中的一个通用函数，但是用的时候出问题了，我们想打个断点看看，但是由于这是一个通用的函数，我们刷新页面后这个函数会被调用多次，但是我们只关心其中的某一次，这个时候我们就需要跳过我们不关心的调用，除了一直手动点跳过按钮，还能怎么办呢？</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/condition-breakpoint.png\" alt=\"condition-breakpoint\"></p>\n<p>右键行号，选择<code>conditional breakpoint</code>然后输入你的条件，比如 <code>user.name === &quot;小明&quot;</code>，这时只有当满足相应条件的时候才会断点。</p>\n<p>而假如我们将上面的例子运用在网络请求上，当我们向某个特定的url发送请求时，产生一个断点，我们就可以在右边的<code>XHR/Fetch Breakpoints</code>中添加相应的url。</p>\n<p>不过需要注意的是，此时的断点可能会断在Chrome的源码中或者别的什么地方，我们需要在Call Stack中找到正确的文件。</p>\n","categories":["工具"],"tags":["devtool"]},{"title":"Webpack原理(3) — 核心概念","url":"https://teobler.com/20200222-webpack-core-concepts.html","content":"<h2 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h2><p>我们先来看一张图</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/webpack-entry.png\" alt=\"webpack-entry\"></p>\n<p>从这张图可以看到，最上面的文件就是我们整个app的入口，也是这个文件启动了我们整个app，这就是weback的入口，通常这个文件会依赖我们自己app的其他文件，其他文件又会依赖别的第三方库，这些依赖可能是js，也可能是css，当然右边也展示了我们也会依赖app里面的其他文件。</p>\n<p>在webpack的config文件中，我们使用entry字段来设置这个入口:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tentry: <span class=\"string\">\"./main.js\"</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一句话来总结就是</p>\n<blockquote>\n<p>Entry tells webpack <strong>WHAT</strong>(files) to load for the browser</p>\n</blockquote>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/webpack-output.png\" alt=\"webpack-output\"></p>\n<p>图片中入口文件下方的是入口文件的依赖，上方就是bundle之后的输出，同样的，我们在config文件中可以通过output这个字段来设置相应的配置项: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\toutput: &#123;</span><br><span class=\"line\">\t\tpath: <span class=\"string\">\"./dist\"</span>,</span><br><span class=\"line\">\t\tfilename: <span class=\"string\">\"./bundle.js\"</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个配置就是在告诉webpack编译后的文件应该放在哪里，文件名应该叫什么，一句话总结</p>\n<blockquote>\n<p>Output tells webpack <strong>WHERE</strong> and <strong>HOW</strong> to discribute bundles. It works with Entry.</p>\n</blockquote>\n<h2 id=\"Loaders-amp-Rules\"><a href=\"#Loaders-amp-Rules\" class=\"headerlink\" title=\"Loaders &amp; Rules\"></a>Loaders &amp; Rules</h2><p>需要明白的是，loaders都是一些JS的modules，也就是说都是一些JS的方法(functions)，他们以你app的module作为输入，返回一个修改后的状态，这些loaders会在webpack建立依赖图的时候对每一个文件进行相应的处理:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/webpack-loaders.png\" alt=\"webpack-loaders\"></p>\n<p>比如第一个ts-loader就是在说告诉webpack，任何时候你想要把一个ts文件放入依赖图中，就用ts-loader处理一次，处理过后这个文件就被编译成了js文件，当然，可能这个文件也有别的依赖，会按照相同的方式依次进行处理。</p>\n<p>通常这个字段接收这些参数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\trules: [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 告诉编译器要编译哪些文件</span></span><br><span class=\"line\">\t\t\ttest: regex,</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// loader(s)</span></span><br><span class=\"line\">\t\t\tuse: (<span class=\"built_in\">Array</span> | <span class=\"built_in\">String</span> | <span class=\"built_in\">Function</span>),</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 白名单</span></span><br><span class=\"line\">\t\t\tinclude: <span class=\"built_in\">RegExp</span>[],</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 黑名单</span></span><br><span class=\"line\">\t\t\texclude: <span class=\"built_in\">RegExp</span>[],</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 告诉webpack这条规则是否在其他规则 之前 | 之后 运行</span></span><br><span class=\"line\">\t\t\tenforce: <span class=\"string\">\"pre\"</span> | <span class=\"string\">\"post\"</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Chaining-Loaders\"><a href=\"#Chaining-Loaders\" class=\"headerlink\" title=\"Chaining Loaders\"></a>Chaining Loaders</h3><p>在上面的介绍中可以看到<code>use</code>字段是可以传入一个数组的，比如<code>[&quot;style&quot;, &quot;css&quot;, &quot;less&quot;]</code>但是需要指出的是，这三个loaders是按照从右到左的的顺序来执行的，这个规则将使一个less文件编译成一个css文件，再由css编译成js文件，最后编译成一个能够在浏览器中运行的<code>inline style</code>的js文件。</p>\n<blockquote>\n<p>loaders tells webpack HOW to interpret and translate files. Transformed on a per-file basis before adding to dependency graph</p>\n</blockquote>\n<h2 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h2><p>对于webpack来说，插件是什么：</p>\n<ul>\n<li>一个对象，这个对象上有一个<code>apply</code>属性</li>\n<li>允许你在编译的生命周期里做一些事情(hook)</li>\n<li>webpack有各种各样的内置插件</li>\n</ul>\n<p>一个简单的例子，编译器用这个插件分发事件：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/webpack-plugin.png\" alt=\"webpack-plugin\"></p>\n<p>这个插件被作为一个实例传入了webpack，所以它可以hook进不同的事件中(这里的代码是webpack3的，因为这里只讲概念，所以问题不大)。</p>\n<p>首先这个插件插入编译器后悔监听<code>done</code>这个事件，这个事件会给这个插件传入一个参数，这里是一个<code>state</code>然后插件在这个state的基础上做出一些反应和处理（这里只是在控制台里输出了一个字符），下面的也是同样的，不过这次这个事件换成了<code>failed</code></p>\n<p>可以看到插件的定义是这样的，所以它可以被实例化，于是在webpack的config文件中我们就会这样去使用它:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BellOnBundlerErrorPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"bell-on-error\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tplugins: [</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> BellOnBundlerErrorPlugin(),</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">\"vendors\"</span>),</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有意思的是，webpack的源代码有80%左右都是由plugins组成的，webpack是一个完全由事件驱动的体系结构，这也就可以使用插件迅速为webpack增添新的功能，并且不会破坏原有的功能，同样的也能够删除一些不必要的功能。</p>\n<blockquote>\n<p>Adds additional functionality to Compilations(optimized bundled modules). More powerful more access to CompilerAPI. Does everything else you’d ever want to in webpack.</p>\n</blockquote>\n<p>plugin与loader的最大不同就是loader是通过去访问一个个文件去做一些事情的，但是plugin可以访问webpack的事件生命周期和运行时，并且可以访问所有bundle文件。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>讲了这么多我们总得用概念做点什么</p>\n<blockquote>\n<p>以下代码位于 <code>feature/04010-composing-configs-webpack-merge</code> 分支</p>\n</blockquote>\n<h3 id=\"读取命令行中的参数\"><a href=\"#读取命令行中的参数\" class=\"headerlink\" title=\"读取命令行中的参数\"></a>读取命令行中的参数</h3><p>我们可以将<code>package.json</code>中的命令做一个修改，传入一个env变量，带有一个mode属性: </p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span> &#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"webpack\"</span>: <span class=\"string\">\"webpack\"</span>,</span><br><span class=\"line\">\t<span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"npm run webpack -- --env.mode development\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>webpack.config.js</code>中我们可以这样获取到这个变量:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">env</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(env);</span><br><span class=\"line\">\t<span class=\"comment\">// &#123; mode: \"development\" &#125;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tmode: env.mode,</span><br><span class=\"line\">\t\toutput: &#123;</span><br><span class=\"line\">\t\t\tfilename: <span class=\"string\">\"bundle.js\"</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加插件\"><a href=\"#加插件\" class=\"headerlink\" title=\"加插件\"></a>加插件</h3><p>我们这里以一个很通用并且很重要的插件<code>html-webpack-plugin</code>为例</p>\n<p>首先用<code>yarn add html-webpack-plugin —dev</code>安装插件，然后在config文件中配置:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"html-webpack-plugin\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"params\">env</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(env);</span><br><span class=\"line\">\t<span class=\"comment\">// &#123; mode: \"development\" &#125;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tmode: env.mode,</span><br><span class=\"line\">\t\toutput: &#123;</span><br><span class=\"line\">\t\t\tfilename: <span class=\"string\">\"bundle.js\"</span>,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tplugins: [<span class=\"keyword\">new</span> HtmlWebpackPlugin()],</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后再运行<code>yarn dev</code>，你会发现bundle里面多了一个<code>index.html</code>文件，文件中用script标签把已经打包好的JS代码进行了引入。</p>\n<h3 id=\"设置本地开发服务\"><a href=\"#设置本地开发服务\" class=\"headerlink\" title=\"设置本地开发服务\"></a>设置本地开发服务</h3><p>首先安装server插件<code>yarn add webpack-dev-server --dev</code>,然后修改<code>package.json</code>:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span> &#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"webpack-dev-server\"</span>: <span class=\"string\">\"webpack-dev-server\"</span>,</span><br><span class=\"line\">\t<span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"npm run webpack-dev-server -- --mode development\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后当你运行<code>yarn dev</code>的时候就会默认在本地8080端口启动一个server，在浏览器访问这个端口你就可以看见刚刚生成的html文件了，而且dev server默认开启了watch模式，可以实时更新代码到server上。</p>\n<p>其实大家也能够猜到这个”插件“其实就是启动了一个Express的server，然后webpack在打包的时候直接将生成的文件加载进内存，通过server直接显示在浏览器里。</p>\n<h3 id=\"为不同的环境设置不同的config文件\"><a href=\"#为不同的环境设置不同的config文件\" class=\"headerlink\" title=\"为不同的环境设置不同的config文件\"></a>为不同的环境设置不同的config文件</h3><p>我们可以像代码库中一样通过简单的配置使得webpack在得到不同参数的情况下去require不同的webpack config文件，以达到区分dev环境和prod环境的目的:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"html-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackMerge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> modeConfig = <span class=\"function\"><span class=\"params\">env</span> =&gt;</span> <span class=\"built_in\">require</span>(<span class=\"string\">`./build-utils/webpack.<span class=\"subst\">$&#123;env&#125;</span>`</span>)(env);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">&#123; mode, presets &#125; = &#123; mode: <span class=\"string\">\"production\"</span>, presets: [] &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> webpackMerge(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      mode,</span><br><span class=\"line\">      output: &#123;</span><br><span class=\"line\">        filename: <span class=\"string\">\"bundle.js\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plugins: [<span class=\"keyword\">new</span> HtmlWebpackPlugin(), <span class=\"keyword\">new</span> webpack.ProgressPlugin()]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    modeConfig(mode)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>但是实际的项目往往要复杂得多，一个大型项目往往不止有两个环境，通常来说<code>development mode</code>下应该有CI Dev QA UAT四个环境，<code>production mode</code>对应Prod环境。</p>\n<p>由于在开发时不同的环境又对应不同的config，比如在Dev坏境应该去请求后端的Dev坏境，而不应该去请求QA坏境，这时我们又会引入不同的config文件去实现这一点。</p>\n<p>首先安装<code>config</code>这个包，，然后在根目录下新建一个config目录，新建你需要的config文件，这些文件都是JSON格式的，记得建一个<code>default.json</code>，当其找不到对应的坏境时就会默认读取default文件，文件可以长这个样子:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// default.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"API_BASE_URL\"</span>: <span class=\"string\">\"https://dev.your-project.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"AUTH_URL\"</span>: <span class=\"string\">\"https://dev.your-project.com/auth\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"NODE_ENV\"</span>: <span class=\"string\">\"dev\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//qa.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"API_BASE_URL\"</span>: <span class=\"string\">\"https://qa.your-project.com\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"AUTH_URL\"</span>: <span class=\"string\">\"https://qa.your-project.com/auth\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"NODE_ENV\"</span>: <span class=\"string\">\"qa\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在运行启动命令的时候加上<code>NODE_ENV</code>这个参数，这样你在webpack的config文件中就可以通过<code>process.env.NODE_ENV</code>去获取这个参数，并且在config文件中可以将之前的config文件require进来在代码中进行使用:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"html-webpack-plugin\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpackMerge = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-merge\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> modeConfig = <span class=\"function\"><span class=\"params\">env</span> =&gt;</span> <span class=\"built_in\">require</span>(<span class=\"string\">`./build-utils/webpack.<span class=\"subst\">$&#123;env&#125;</span>`</span>)(env);</span><br><span class=\"line\"><span class=\"keyword\">const</span> envConfig = <span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">require</span>(<span class=\"string\">\"config\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">&#123; mode, presets &#125; = &#123; mode: <span class=\"string\">\"production\"</span>, presets: [] &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> webpackMerge(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      mode,</span><br><span class=\"line\">      output: &#123;</span><br><span class=\"line\">        filename: <span class=\"string\">\"bundle.js\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HtmlWebpackPlugin(), </span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.ProgressPlugin(),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123; <span class=\"attr\">CONFIG</span>: envConfig &#125;),</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    modeConfig(mode)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// axios.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = axios.create(&#123;</span><br><span class=\"line\">  baseURL: CONFIG.API_BASE_URL,</span><br><span class=\"line\">  timeout: <span class=\"number\">10000</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["webpack"]},{"title":"Webpack原理(2) — 加载原理","url":"https://teobler.com/20200219-first-in-webpack.html","content":"<p>webpack的核心目的和功能就是打包JavaScript代码，在时间的推进过程中，其逐渐演化成了一个生态体系，成为前端打包代码和处理开发时候必不可少的一个工具。</p>\n<blockquote>\n<p>本文首发于我的个人博客: <a href=\"https://teobler.com\">https://teobler.com</a>, 转载请注明出处， 文章中提到的所有源代码来自于<a href=\"https://github.com/thelarkinn/webpack-workshop-2018\" target=\"_blank\" rel=\"noopener\">https://github.com/thelarkinn/webpack-workshop-2018</a></p>\n</blockquote>\n<h2 id=\"NPM-scripts\"><a href=\"#NPM-scripts\" class=\"headerlink\" title=\"NPM scripts\"></a>NPM scripts</h2><blockquote>\n<p>以下代码位于<code>feature/01-fem-first-script</code>分支</p>\n</blockquote>\n<h3 id=\"Install-amp-Run\"><a href=\"#Install-amp-Run\" class=\"headerlink\" title=\"Install &amp; Run\"></a>Install &amp; Run</h3><p>首先将代码clone到你本地，然后运行yarn install。既然文章讲的是webpack，那么问题来了，当你运行这个命令的时候，发生了什么？</p>\n<p>在你运行<code>yarn install</code>这个命令的时候，首先会在你的<code>node_modules</code>目录下添加一个<code>.bin</code>文件夹，里面是一些二进制可执行文件(包括webpack它本身)，这些文件可以被<code>node_modules</code>里面你下载的所有packages运行，里面的可执行文件都在<strong>npm这个作用域</strong>下才可执行。</p>\n<p>比如当你直接运行webpack的时候，是会抛错的:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">zsh: <span class=\"built_in\">command</span> not found: webpack</span><br></pre></td></tr></table></figure>\n<p>但是此时如果你在<code>package.json</code>文件中加入下面的代码:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span> &#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"webpack\"</span>: <span class=\"string\">\"webpack\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再运行<code>npm run webpack</code>此时将会以默认设置运行<code>node_modules</code>中的webpack(注：这里需要webpack4及以上版本)，在这个script标签中NPM允许你在其作用域中运行任何合法的script，甚至是<code>bash</code>的script。</p>\n<p>这时其实我们的代码库里面是没有任何webpack的配置的，其默认回去寻找项目中的<code>src</code>目录下的<code>index</code>文件，但是这时webpack会抛出一个warning，推荐你设置环境变量以使用不同环境下的默认设置</p>\n<h3 id=\"Compose-Scripts\"><a href=\"#Compose-Scripts\" class=\"headerlink\" title=\"Compose Scripts\"></a>Compose Scripts</h3><p>NPM script有一个强大的功能是能够将已有的命令合并起来，并且还可以提供额外的参数，比如我们可以加一个新的script去运行之前的webpack并在新的命令里传入参数，避免重复新增和修改之前的script :</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"script\"</span> &#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"webpack\"</span>: <span class=\"string\">\"webpack\"</span>,</span><br><span class=\"line\">\t<span class=\"attr\">\"dev\"</span>: <span class=\"string\">\"npm run webpack -- --mode development\"</span></span><br><span class=\"line\">\t// 这里的 -- 代表将后面的参数传入前面的命令中</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>以下代码位于<code>feature/03-fem-debug-script</code>分支</p>\n</blockquote>\n<h2 id=\"Debugging\"><a href=\"#Debugging\" class=\"headerlink\" title=\"Debugging\"></a>Debugging</h2><p>我不知道各位读者是怎么debug一个Node程序的，至少对于我来说在这之前我完全依赖于<code>console.log</code>，其实node早已经为我们提供了一个方便的方式，只需要在<code>package.json</code>文件中加入一个script:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"script\": &#123;</span><br><span class=\"line\">\t\"debug\": \"node --inspect --inspect-brk /path/to/file/you/want/to/debug\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行这段script，然后打开你的chrome，在地址栏输入<code>chrome://inspect</code>或者在新版本的chrome打开控制台，在左上角有一个Node的logo，点击即可打开Node专用的devtool。</p>\n<p>如果此时我们将文件路径换成<code>./node_modules/webpack/bin/webpack.js</code>的话，我们就可以debug webpack了。你可以再devtool里看到webpcck是怎样被加载的，每一步是如何进行的等等。这个步骤不单单对了解webpack在做什么有用，如果你在编写自己的plugin或者loader的话，你可以用这种方式去做debug。这就是传说中的”debug driven development”。</p>\n<h2 id=\"First-Module\"><a href=\"#First-Module\" class=\"headerlink\" title=\"First Module\"></a>First Module</h2><p>在<code>src</code>目录下加入一个新的文件<code>foo.js</code>，里面只写一个导出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">\"foo\"</span>;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>index.js</code>里面将其import进来console出来:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"./foo\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo);</span><br></pre></td></tr></table></figure>\n<p>然后直接运行<code>npm run dev</code>，这时你应该能看到webpack将两个文件打包成功，并且在项目目录下出现了一个新的<code>dist</code>文件夹，里面的<code>main.js</code>文件就是刚刚打包好的内容(这是webpack的默认配置)。在控制台运行<code>node ./dist/main.js</code>你就能看到foo被打印出来了。</p>\n<p>如果每次修改都run一次script未免太麻烦，所以webpack还提供了<strong>watching mode</strong>，只需要在<code>dev</code>命令后加上<code>--watch</code>的flag，在每次修改文件保存后webpack就会自动重新打包最新的代码。</p>\n<h2 id=\"ES-Module-Syntax\"><a href=\"#ES-Module-Syntax\" class=\"headerlink\" title=\"ES Module Syntax\"></a>ES Module Syntax</h2><p>在上面的例子中foo文件直接export default了，但是有一些情况我们的一个文件中可能包含多个部分:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bar.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> firstPart = <span class=\"string\">\"first\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> secondPart = <span class=\"string\">\"second\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"./foo.js\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; firstPart, secondPart &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./bar.js\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo, firstPart, secondPart);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>CommonJS也是几乎相同的用法，但是不推荐在0202年的这个时间点使用CommonJS，毕竟其不支持tree-shaking等等功能(老旧系统当我没说)</p>\n</blockquote>\n<h2 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h2><p>在默认情况下webpack会在打包production代码的时候启用这个功能，这个功能能够舍弃那些我们没有用到的死代码，一个通用的例子是，你引入了lodash，但是只用到了里面的一个函数，那么只要你正确引入并使用(比如使用ES Module Syntax等等)了lodash，在最后打包的时候webpack就只会打包你使用过的函数而不是一整个lodash库。</p>\n<h2 id=\"Bundle-Result\"><a href=\"#Bundle-Result\" class=\"headerlink\" title=\"Bundle Result\"></a>Bundle Result</h2><p>开始前请将代码切到<code>feature/031-all-module-types</code>分支并且在根目录下创建<code>webpack.config.js</code>文件，并在其中加上一下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">\"none\"</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>之后直接运行<code>npm run webpack</code>然后你就能在<code>dist</code>目录下看到打包好的，没有经过任何处理的<code>main.js</code>文件，我们来看看webpack打包后的代码到底是什么样子的。</p>\n<p>首先我们看到的是一个IFEE，这个IFEE就是webpack的运行时(runtime code)，它接受了一个参数modules，这个modules在下面可以看到是一个数组，其实就是我们打包的各个文件的真实代码，只不过webpack帮我们做了一些处理，打包的时候可以在控制台看到一些index:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/index-of-bundle-files.png\" alt=\"index-of-bundle-files\"></p>\n<p>它们就对应代码里面注释里的一个个文件:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/the-first-bundled-file.png\" alt=\"the-first-bundled-file\"></p>\n<p>那么这段runtime code里面做了什么呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/******/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123; <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// The module cache</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// The require function</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"comment\">// Check if module is in cache</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">if</span>(installedModules[moduleId]) &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t<span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\ti: moduleId,</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\tl: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\texports: &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t&#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"comment\">// Execute the module function</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\tmodules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t&#125;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// expose the modules object (__webpack_modules__)</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.m = modules;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// expose the module cache</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.c = installedModules;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// define getter function for harmony exports</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports, name, getter</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">if</span>(!__webpack_require__.o(exports, name)) &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t<span class=\"built_in\">Object</span>.defineProperty(exports, name, &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t\tconfigurable: <span class=\"literal\">false</span>,</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t\tenumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t\tget: getter</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t&#125;);</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t&#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// define __esModule on exports</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"string\">'__esModule'</span>, &#123; <span class=\"attr\">value</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t&#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">var</span> getter = <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule ?</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">'default'</span>]; &#125; :</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>; &#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t__webpack_require__.d(getter, <span class=\"string\">'a'</span>, getter);</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t\t<span class=\"keyword\">return</span> getter;</span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t&#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// Object.prototype.hasOwnProperty.call</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">object, property</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// __webpack_public_path__</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t__webpack_require__.p = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"comment\">// Load entry module and return exports</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> \t<span class=\"keyword\">return</span> __webpack_require__(__webpack_require__.s = <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">/******/</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">/************************************************************************/</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span> ([here, is, file, modules]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 篇幅所限，剩下的代码请到代码库中查看</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第3行设置了一个已经加载过的modules的cache变量</li>\n<li>第6行有一个require函数，它会检查传入的module是否存在于上面的cache中，如果存在的话就会直接return cache里面的exports字段，如果不存在就会创建一个module放入那个cache中(不过此时的exports字段是空的，并且没有被加载)，之后将这个module传入另一个require函数中(实际上是直接call了这个module)，执行完后将其标记为已加载，最后再把这个module的exports字段返回</li>\n<li>第37行与ESM的动态绑定有关，它是一个支持循环依赖的特性，本来应该在浏览器端实现的一个功能，之所以使用<code>defineProperty</code>是因为webpack将各个module的exports做了冻结处理，防止其被修改</li>\n<li>第48行的函数是为了与CommonJS交互，因为CommonJS没有default export，所以webpack使用了与TS相同的处理方式，在上面定义了一个常量标记这是一个CommonJS的module</li>\n<li>第53行的函数是为了与non-harmony的modules交互</li>\n<li>第69行就是webpack的执行入口，它将第一个module传入require方法执行了</li>\n<li>之后执行的就是真正的我们自己写的代码了，如果将打包后的代码和我们自己写的代码作对比，你能够很轻易的发现第78行到83行就是在做import，下面的函数就是在做console</li>\n</ul>\n<p>所以这些代码就是我们在使用webpack build的时候所发生的一切了(当然，这仅仅是最简单的那部分)</p>\n","categories":["技术"],"tags":["webpack"]},{"title":"用React hooks实现TDD","url":"https://teobler.com/20200211-tdd-with-react-hooks.html","content":"<blockquote>\n<p>本文首发于我的个人博客: <a href=\"https://teobler.com/\">https://teobler.com</a>, 转载请注明出处</p>\n</blockquote>\n<p>由于篇幅所限文章中并没有给出demo的所有代码，大家如果有兴趣可以将代码clone到本地从commit来看整个demo的TDD过程，配合文章来看会比较清晰。本文涉及的所有代码地址: <a href=\"https://github.com/teobler/TDD-with-React-hooks-demo\" target=\"_blank\" rel=\"noopener\">teobler/TDD-with-React-hooks-demo</a></p>\n<h2 id=\"前端TDD的痛\"><a href=\"#前端TDD的痛\" class=\"headerlink\" title=\"前端TDD的痛\"></a>前端TDD的痛</h2><p>从进公司前认识了TDD，到实践TDD，过程中自己遇到或者小伙伴们一起讨论的比较频繁的一个问题是 — 前端不太好TDD / 前端TDD的投入收益比不高。为啥会这样呢？</p>\n<p>我们假设你在写前端时全程TDD，那么你需要做的是 — 先assert页面上有一个button，然后去实现这个button，之后assert点击这个button之后会发生什么，最后再去实现相应的逻辑。</p>\n<p>这个过程中有一个问题，因为前端中UI和逻辑强耦合，所以在TDD的时候你需要先实现UI，然后选中这个UI上的组件，trigger相应的行为，这个过程给开发人员增加了不少负担。</p>\n<p>诚然，这样写出来的代码严格遵循了TDD的做法，也得到了TDD给我们带来的各种好处，但是据我观察下来，身边的小伙伴们没有一个人认同这样的做法。大家的痛点在于UI部分的TDD过于痛苦并且收益太低，而且由于UI和逻辑强耦合，后续的逻辑部分也需要先选取页面上的元素trigger出相应的执行逻辑。</p>\n<p>这些痛点在项目组引入了hooks之后有了显著的改善，从引入hooks到现在快一年的时间，组里的小伙伴们一起总结除了一套测试策略。在此我们将React的组件分为三类 — 纯逻辑组件(比如request的处理组件，utils函数等)，纯UI组件(比如展示用的Layout，Container组件等)和两者结合的混合组件(比如某个页面)。</p>\n<h2 id=\"纯逻辑组件\"><a href=\"#纯逻辑组件\" class=\"headerlink\" title=\"纯逻辑组件\"></a>纯逻辑组件</h2><p>这部分组件没啥好说的，全都是逻辑，tasking，测试，实现，重构一条龙，具体咋写我们这里不讨论。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// combineClass.test.ts</span></span><br><span class=\"line\">describe(<span class=\"string\">'combineClass'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    it(<span class=\"string\">'should return prefixed string given only one class name'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = combineClass(<span class=\"string\">'class-one'</span>);</span><br><span class=\"line\">        expect(result).toEqual(<span class=\"string\">'prefix-class-one'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    it(<span class=\"string\">'should trim space for class name'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = combineClass(<span class=\"string\">'class-one '</span>);</span><br><span class=\"line\">        expect(result).toEqual(<span class=\"string\">'prefix-class-one'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    it(<span class=\"string\">'should combine two class name and second class name should not add prefix'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = combineClass(<span class=\"string\">'class-one'</span>, <span class=\"string\">'class-two'</span>);</span><br><span class=\"line\">        expect(result).toEqual(<span class=\"string\">'prefix-class-one class-two'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    it(<span class=\"string\">'should combine three class name and tail class name should not add prefix'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = combineClass(<span class=\"string\">'class-one'</span>, <span class=\"string\">'class-two'</span>, <span class=\"string\">'class-three'</span>);</span><br><span class=\"line\">        expect(result).toEqual(<span class=\"string\">'prefix-class-one class-two class-three'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// combineClass.ts</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> CLASS_PREFIX = <span class=\"string\">\"prefix-\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> combineClass = <span class=\"function\">(<span class=\"params\">...className: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> resultName = className.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">    resultName[<span class=\"number\">0</span>] = CLASS_PREFIX + className[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultName</span><br><span class=\"line\">        .join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">        .trim();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"纯UI组件\"><a href=\"#纯UI组件\" class=\"headerlink\" title=\"纯UI组件\"></a>纯UI组件</h2><p>这类组件我们没有一个个去测试组件里面的元素，而是按照UX的要求build完组件以后加上一个jest的json snapshot测试。</p>\n<blockquote>\n<p>注意这里的snapshot并不是大家印象中的e2e测试中的截图，而是jest里将组件render出来之后使用json生成一份UI的dom结构，在下次测试时，生成一份新的快照与旧的快照进行比对，从而得出两个UI不一样的地方，实现对UI的保护。</p>\n</blockquote>\n<p>但是其实使用snapshot测试有两个问题：</p>\n<ol>\n<li>snapshot相比较于一般的单元测试来说运行速度较慢，如果项目中大量使用的snapshot测试的话，在运行所有单元测试的时候会比较明显的感受到单元测试的速度被拖慢了，一定程度上违背了单元测试快速反馈的初衷；</li>\n<li>维护snapshot的人工成本较大，snapshot测试最大的问题在于你只要改动了任何UI的部分，这个测试都会挂掉，这个时候就需要仔细对比不同的地方以决定是更新snapshot还是改错地方了，而如果此时团队里有“省心”的队友无脑更新snapshot的话，这个测试相当于浪费了资源。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Content.test.tsx</span></span><br><span class=\"line\">describe(<span class=\"string\">'Content'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    it(<span class=\"string\">'should render correctly'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;container&#125; = render(&lt;Content/&gt;);</span><br><span class=\"line\">        expect(container).toMatchSnapshot();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Content.test.tsx.snap</span></span><br><span class=\"line\"><span class=\"comment\">// Jest Snapshot v1, https://goo.gl/fbAQLP</span></span><br><span class=\"line\"></span><br><span class=\"line\">exports[<span class=\"string\">`Content should render correctly 1`</span>] = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;main</span></span><br><span class=\"line\"><span class=\"string\">    class=\"prefix-layout-content\"</span></span><br><span class=\"line\"><span class=\"string\">  /&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Content.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> Content: React.FC&lt;React.HTMLAttributes&lt;HTMLElement&gt;&gt; = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; className = <span class=\"string\">''</span>, children, ...restProps &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;main className=&#123;combineClass(<span class=\"string\">'layout-content'</span>, className)&#125; &#123;...restProps&#125;&gt;</span><br><span class=\"line\">            &#123;children&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/main&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"逻辑与UI混合组件\"><a href=\"#逻辑与UI混合组件\" class=\"headerlink\" title=\"逻辑与UI混合组件\"></a>逻辑与UI混合组件</h2><p>这个部分我们就需要hooks的帮忙了，这样的组件不是UI和逻辑强耦合嘛，那我们就可以将两者拆开。于是这样的组件我们会这样写：</p>\n<ol>\n<li><p>首先将UI页面build出来，但是需要的callback全部写成空函数</p>\n</li>\n<li><p>将所有callback或者是页面需要用到的逻辑抽到一个hook中</p>\n</li>\n<li><p>此时hook里的代码没有UI只有逻辑，故可以使用测试库对hook进行单独的逻辑测试，所以此时hook的开发可以按照逻辑组件的开发进行TDD</p>\n</li>\n<li><p>整个混合组件开发完成后，补上一个snapshot测试，需要注意的是可能该组件在渲染时需要一些数据，在写snapshot测试时应该确保准备的数据是完备的，否则快照会渲染出一份根本没有数据的错误组件</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usePageExample.test.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;act, renderHook&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"@testing-library/react-hooks\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'usePageExample'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mockGetUserId: jest.Mock;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mockValidate: jest.Mock;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">beforeAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    mockGetUserId = jest.fn();</span><br><span class=\"line\">    mockValidate = jest.fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    jest.mock(<span class=\"string\">'../../../../request/someRequest'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;</span><br><span class=\"line\">        getUserId: mockGetUserId,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">    jest.mock(<span class=\"string\">'../../../../validator/formValidator'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> (&#123;</span><br><span class=\"line\">        formValidate: mockValidate,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">afterAll(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    mockGetUserId.mockReset();</span><br><span class=\"line\">    mockValidate.mockReset();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should trigger request with test string when click button'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;usePageExample&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'../usePageExample'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;result&#125; = renderHook(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> usePageExample());</span><br><span class=\"line\"></span><br><span class=\"line\">    act(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result.current.onClick();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(mockGetUserId).toBeCalled();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">'should validate form values before submit'</span>, <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;usePageExample&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'../usePageExample'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;result&#125; = renderHook(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> usePageExample());</span><br><span class=\"line\">    <span class=\"keyword\">const</span> formValues = &#123;id: <span class=\"string\">'1'</span>, name: <span class=\"string\">'name'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    act(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result.current.onSubmit(formValues);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(mockValidate).toBeCalledWith(formValues);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// usePageExample.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;getUserId&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../../request/someRequest\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;formValidate&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"../../../validator/formValidator\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> IFormValues &#123;</span><br><span class=\"line\">    email: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> usePageExample = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onClick = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        getUserId();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> onSubmit = <span class=\"function\">(<span class=\"params\">formValues: IFormValues</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        formValidate(formValues);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;onClick, onSubmit&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PageExample.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> React <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;usePageExample&#125; <span class=\"keyword\">from</span> <span class=\"string\">\"./hooks/usePageExample\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> PageExample: React.FC&lt;IPageExampleProps&gt; = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;onClick, onSubmit&#125; = usePageExample();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;form onSubmit=&#123;<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> onSubmit&#125;&gt;</span><br><span class=\"line\">                &lt;input <span class=\"keyword\">type</span>=<span class=\"string\">\"text\"</span>/&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/form&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;button onClick=&#123;onClick&#125;&gt;test&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;;</span></span><br></pre></td></tr></table></figure>\n<p>这篇文章算是给大家提供了一个hooks的TDD思路，当然其中还有一些我们也觉得不是很完善的地方(比如UI的测试)，大家如果有更好的实践的话欢迎一起讨论。</p>\n","categories":["技术"],"tags":["React","TDD","单元测试","测试驱动开发"]},{"title":"如何减小前端代码打包体积","url":"https://teobler.com/20200107-reduce-bundle-size.html","content":"<p>对于减小打包体积这件事，大家主要会从两个方面着手 — </p>\n<p>第一是通过压缩、删除废代码、重复代码等手段实实在在地减少打包的大小；</p>\n<p>第二是通过将打包拆分成小包，进行懒加载，让用户下载的单个包变小，达到快速加载网页的目的；</p>\n<p>这篇文章主要也是中这两个方面入手，但是由于一些手段会将两者杂糅在一起，所以文章就不做细分了，将两种方式都放在一起。</p>\n<h2 id=\"1-Bundle分析\"><a href=\"#1-Bundle分析\" class=\"headerlink\" title=\"1. Bundle分析\"></a>1. Bundle分析</h2><p>在优化你的打包体积之前，你至少需要对你的包体积有一个大概的了解，否则直接就上手进行“优化”，说不定得到的是负优化，况且还有一种不知从哪里下手的感觉。</p>\n<h3 id=\"1-插件可视化分析\"><a href=\"#1-插件可视化分析\" class=\"headerlink\" title=\"1. 插件可视化分析\"></a>1. 插件可视化分析</h3><p><a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>是一个可以将你的包内容可视化的webpack插件，它运行后的结果大概长下面这个样子：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/webpack-bundle-analyzer.gif\" alt=\"webpack-bundle-analyzer\"></p>\n<p>它能够将每一个模块的大小信息，甚至是压缩后的信息占你总的打包体积按照树形结构可视化出来，可以让你直观的看出打包后的重复模块，过于大的模块等等，让你可以对症下药。</p>\n<h3 id=\"2-“预算”\"><a href=\"#2-“预算”\" class=\"headerlink\" title=\"2. “预算”\"></a>2. “预算”</h3><p>其实优化打包体积这件事并不是一蹴而就的，你的包体积一定会随着项目的不断进行越来越大，如果你仅仅是做一次就不管了的话，那么这一次优化在未来肯定会消失的无踪无际的。</p>\n<p>正确的做法应该是组内不同的role共同定下一个<strong>合理</strong>的指标，然后定期去检查线上的打包大小是否已经超过了预警值，如果超过了，那么就需要进行一次适当的优化。</p>\n<p>那么怎样的指标算是合理的呢？</p>\n<p>专业的做法当然是运营的同学拿出一个数据报表，多快的加载速度能够帮助转化多少的用户，为了多少用户我们必须达到多少的加载速率，反推出我们的打包体积应该在多大是合理的。</p>\n<p>简单粗暴的做法可以打开Chrome的Audits，跑一遍performance测试，然后Chrome会告诉你 — 你该想想办法治治你的JS了，比如这样:</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/perfoemance.png\" alt=\"perfoemance\"></p>\n<p><strong>但是需要注意的是，这里的加载速度并不代表这是因为你的打包体积过大导致的，所以具体的情况还需要结合第一部分的webpack插件进行分析。</strong></p>\n<h2 id=\"2-代码拆分\"><a href=\"#2-代码拆分\" class=\"headerlink\" title=\"2. 代码拆分\"></a>2. 代码拆分</h2><p>代码拆分是一个有效的减少打包文件中重复模块的方式。拆分后的代码可以在特定的时间进行加载，避免在刚进入网页时加载所有的资源造成block。而什么时候你应该进行代码拆分了呢？幸运的是Chrome依旧给我们提供了工具 — 在聚焦DevTools时使用esc键打开一个新的tab，在新的tab最左边有一个more tools的按钮，里面有一个<strong>coverage</strong>的工具，它可以识别出当前路由下所包含的未使用代码的脚本：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/coverage.png\" alt=\"coverage\"></p>\n<p>如图展示了一个网页JS包的使用情况，可以看到在当前路由下绝大多数JS代码都是无用的，这个时候我们就可以考虑是不是可以通过代码拆分将这部分无用的代码拆出当前路由\\入口。</p>\n<h3 id=\"1-入口打包\"><a href=\"#1-入口打包\" class=\"headerlink\" title=\"1. 入口打包\"></a>1. 入口打包</h3><p>如果你正在开发的不是单页面应用程序(SPA)，或者是一个混合应用程序，其中某些页面不使用客户端路由，但其他页面有可能使用。在这样的情况下，跨多个入口拆分代码是有意义的。此时我们根据各个入口进行代码拆分，当用户访问入口1时不会去下载入口2的包，以拆分的方式减小了用户下载的包大小。</p>\n<p>在webpack中，我们可以通过在entry配置中指定它们来按入口拆分代码，如下所示：</p>\n<pre><code>module.exports = {\n  // ...\n  entry: {\n    main: path.join(__dirname, &quot;src&quot;, &quot;index.js&quot;),\n    detail: path.join(__dirname, &quot;src&quot;, &quot;detail.js&quot;),\n    favorites: path.join(__dirname, &quot;src&quot;, &quot;favorites.js&quot;)\n  },\n  // ...\n};\n</code></pre><p>当有多个入口点时，webpack将它们全部视为单独的依赖树，这意味着代码会自动以命名进行拆分，如下所示：</p>\n<pre><code>                   Asset       Size  Chunks             Chunk Names\njs/favorites.15793084.js   37.1 KiB       0  [emitted]  favorites\n   js/detail.47980e29.js   44.8 KiB       1  [emitted]  detail\n     js/main.7ce05625.js   49.4 KiB       2  [emitted]  main\n              index.html  955 bytes          [emitted]\n             detail.html  957 bytes          [emitted]\n          favorites.html  960 bytes          [emitted]\n</code></pre><h3 id=\"2-公共库的打包\"><a href=\"#2-公共库的打包\" class=\"headerlink\" title=\"2. 公共库的打包\"></a>2. 公共库的打包</h3><p>如果单纯的按照入口来进行打包的话，可能出现的问题就是各个入口重复依赖了一些公共的包。这是因为webpack将每个入口视为自己单独的依赖关系树，而不评估它们之间共享的代码。如果<a href=\"https://webpack.js.org/configuration/devtool/\" target=\"_blank\" rel=\"noopener\">我们启用webpack中的source maps</a>并使用<a href=\"https://github.com/samccone/bundle-buddy\" target=\"_blank\" rel=\"noopener\">Bundle Buddy</a>或<a href=\"https://github.com/webpack-contrib/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>等工具分析我们的代码，我们可以看到每个块中有多少重复代码：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/bundle-buddy.png\" alt=\"bundle-buddy\"></p>\n<p>这里的重复代码来自公共依赖包脚本。为了解决这个问题，我们将告诉webpack为这些脚本创建一个单独的代码块。为此，我们将使用<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/#optimization-splitchunks\" target=\"_blank\" rel=\"noopener\">optimization.splitChunks配置对象</a> ：</p>\n<pre><code>module.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        // Split vendor code to its own chunk(s)\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/i,\n          chunks: &quot;all&quot;\n        }\n      }\n    },\n    // The runtime should be in its own chunk\n    runtimeChunk: {\n        name: &quot;runtime&quot;\n    }\n   },\n  // ...\n};\n</code></pre><p>此配置表示“我想为公共依赖包脚本输出单独的块”（从node_modules文件夹加载的那些）。这很有效，因为所有公共依赖脚本都是由npm安装到node_modules ，我们使用<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/#splitchunks-cachegroups-test\" target=\"_blank\" rel=\"noopener\">test选项</a>来检查此路径。<a href=\"https://webpack.js.org/configuration/optimization/#optimization-runtimechunk\" target=\"_blank\" rel=\"noopener\">runtimeChunk选项</a>还制定以将<a href=\"https://webpack.js.org/concepts/manifest/#runtime\" target=\"_blank\" rel=\"noopener\">webpack的运行时</a>分离到自己的代码块中，以避免在我们的应用代码中重复使用它。当我们将这些选项添加到配置并重建应用程序时，输出显示我们的应用程序的公共依赖包脚本已移至单独的文件：</p>\n<pre><code>                                       Asset      Size  Chunks             Chunk Names\njs/vendors~detail~favorites~main.29eb30bb.js  30.1 KiB       0  [emitted]  vendors~detail~favorites~main\n                         js/main.06d0afde.js  16.5 KiB       2  [emitted]  main\n                       js/detail.1acdbb27.js  13.4 KiB       3  [emitted]  detail\n                    js/favorites.230214a7.js  5.52 KiB       4  [emitted]  favorites vendors~detail~favorites~main\n                      js/runtime.2642dc2d.js  1.46 KiB       1  [emitted]  runtime\n                                  index.html   1.1 KiB          [emitted]\n                                 detail.html   1.1 KiB          [emitted]\n                              favorites.html   1.1 KiB          [emitted]\n</code></pre><p>由于公共依赖包脚本，运行时和共享代码现在已拆分为专有代码块，因此我们也减小了入口脚本的大小。感谢我们的努力，Bundle Buddy为我们带来了更好的结果：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/bundle-buddy2.png\" alt=\"bundle-buddy2\"></p>\n<p>但是其实到了这一步我们还可以做得更好，可以想象一下，你在项目中依赖了很多NPM modules，这些modules其实还是有别的依赖，那么我们其实可以将这些真正的”公共“部分再进行拆分，拆分出一个common包，进一步减小各个包之间的重复代码：</p>\n<pre><code>module.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        // Split vendor code to its own chunk(s)\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/i,\n          chunks: &quot;all&quot;\n        },\n        // Split code common to all chunks to its own chunk\n        commons: {\n          name: &quot;commons&quot;,    // The name of the chunk containing all common code\n          chunks: &quot;initial&quot;,  // TODO: Document\n          minChunks: 2        // This is the number of modules\n        }\n      }\n    },\n    // The runtime should be in its own chunk\n    runtimeChunk: {\n      name: &quot;runtime&quot;\n    }\n  },\n  // ...\n};\n</code></pre><p>当我们使用公共代码拆分时，块之间共同的代码将被拆分为一个名为commons的新代码块，如下输出所示：</p>\n<pre><code>                   Asset      Size  Chunks             Chunk Names\n  js/commons.e039cc73.js    40 KiB       0  [emitted]  commons\n     js/main.5b71b65c.js  7.82 KiB       2  [emitted]  main\n   js/detail.b3ac6f73.js  5.17 KiB       3  [emitted]  detail\njs/favorites.8da9eb04.js  2.18 KiB       4  [emitted]  favorites\n  js/runtime.2642dc2d.js  1.46 KiB       1  [emitted]  runtime\n              index.html  1.08 KiB          [emitted]\n             detail.html  1.08 KiB          [emitted]\n          favorites.html  1.08 KiB          [emitted]\n</code></pre><p>当我们重新运行Bundle Buddy时，我们应该会被告知我们的bundle不再有重复代码块。</p>\n<p>以上按照入口打包和公共组件库的打包的具体项目实例可以参考：</p>\n<p><a href=\"https://github.com/malchata/code-splitting-example/tree/webpack-entry-point-splitting\" target=\"_blank\" rel=\"noopener\">malchata/code-splitting-example</a></p>\n<h3 id=\"3-动态拆分打包\"><a href=\"#3-动态拆分打包\" class=\"headerlink\" title=\"3. 动态拆分打包\"></a>3. 动态拆分打包</h3><p>但是当你的应用是一个单页应用时，虽然我们依旧可以使用公共库打包的方式减少代码重复，但是由于是单入口的，就没有办法按照入口来进行代码拆分了，这时我们可以进行动态拆分，按照feature\\route进行代码拆分，只有当用户使用到某个feature或者是访问了某一个路由时才会加载那个部分的JS脚本，减少用户一次性下载的脚本大小。</p>\n<p>通常我们会使用<a href=\"https://developers.google.com/web/updates/2017/11/dynamic-import?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">动态import()语句</a>来进行脚本的延迟加载，照旧，我们可以先看一个例子：</p>\n<pre><code>import { Router, Switch } from &quot;react-router&quot;;\nimport * as React from &quot;react&quot;;\nimport * as ReactDOM from &quot;react-dom&quot;;\nimport Search from &quot;./components/Search/Search&quot;;\nimport PedalDetail from &quot;./components/PedalDetail/PedalDetail&quot;;\nimport Favorites from &quot;./components/Favorites/Favorites&quot;;\n\nReactDOM.render(&lt;Router&gt;\n    &lt;Switch&gt;\n      &lt;Search path=&quot;/&quot; default/&gt;\n      &lt;PedalDetail path=&quot;/pedal/:id&quot;/&gt;\n      &lt;Favorites path=&quot;/favorites&quot;/&gt;\n    &lt;/Switch&gt;\n&lt;/Router&gt;, document.getElementById(&quot;app&quot;));\n</code></pre><p>如上所示，我们为每个路由加载了所有的组件，无论用户是否访问过它们。当以这种方式构建应用程序时，我们错过了通过延迟加载JavaScript来提高加载性能的潜在机会。在这个示例应用的情况下，我们可以通过使用动态import()来延迟加载/pedal/:id和/favorites路由所需的组件，如下所示：</p>\n<pre><code>import * as React from &quot;react&quot;;\nimport * as ReactDOM from &quot;react-dom&quot;;\nimport { Route, Router, Switch } from &quot;react-router&quot;;\nimport { AsyncComponent } from &quot;./components/AsyncComponent&quot;;\nimport Search from &quot;./components/Search/Search&quot;;\n\nReactDOM.render(\n  &lt;Router&gt;\n    &lt;Switch&gt;\n      &lt;Search path=&quot;/&quot; default /&gt;\n      &lt;Route\n        render={props =&gt; (\n          &lt;AsyncComponent\n            importModule={() =&gt;\n              import(\n                /* webpackChunkName: &quot;Favorites.js&quot; */ &quot;./components/Favorites/Favorites&quot;\n                )\n            }\n          /&gt;\n        )}\n      /&gt;\n      &lt;Route\n        render={props =&gt; (\n          &lt;AsyncComponent\n            importModule={() =&gt;\n              import(\n                /* webpackChunkName: &quot;PedalDetail.js&quot; */ &quot;./components/PedalDetail/PedalDetail&quot;\n              )\n            }\n          /&gt;\n        )}\n      /&gt;\n    &lt;/Switch&gt;\n  &lt;/Router&gt;,\n  document.getElementById(&quot;app&quot;)\n);\n</code></pre><p>在上面的代码片段中，一个名为<strong>webpackChunkName</strong>的内联指令告诉webpack该代码块的名称应该是什么。在import()调用时，webpack为代码块提供了正确的名称，如下所示：</p>\n<pre><code>                        Asset       Size  Chunks             Chunk Names\n          js/main.b72863fc.js   10.2 KiB       0  [emitted]  main\n     js/Favorites.0ce4835e.js   3.33 KiB       2  [emitted]  Favorites\n    js/simpleSort.ef5256f9.js  358 bytes       3  [emitted]  simpleSort\njs/toggleFavorite.fc4ea97d.js  534 bytes       4  [emitted]  toggleFavorite\n  js/vendors~main.526c9b0c.js   42.9 KiB       5  [emitted]  vendors~main\n       js/runtime.a735e0fe.js   2.32 KiB       6  [emitted]  runtime\n   js/PedalDetail.ba7a0692.js   6.12 KiB       1  [emitted]  PedalDetail\n                   index.html   1.08 KiB          [emitted]\n</code></pre><p>以上按照入口打包和公共组件库的打包的具体项目实例可以参考：</p>\n<p><a href=\"https://github.com/malchata/code-splitting-example/tree/webpack-dynamic-splitting\" target=\"_blank\" rel=\"noopener\">malchata/code-splitting-example</a></p>\n<p><strong>需要注意的是代码拆分虽然减少了用户下载的包大小，但是相应的用户需要下载多个包，也就是说它增加了请求数量，可能也会带来一些问题，所以请合理配合缓存和预加载，具体的方法会在别的文章中提到。</strong></p>\n<h2 id=\"3-UI库的打包\"><a href=\"#3-UI库的打包\" class=\"headerlink\" title=\"3. UI库的打包\"></a>3. UI库的打包</h2><p>为了简化项目的开发，往往不同的项目会选用不同的UI库，但是开源的UI库通常会提供一些大而全的组件，如果我们将所有组件都打包进我们的项目，显然是不行的，毕竟里面其实有很多组件我们并没有用到，而且全部打包的组件库很大，会对我们的性能产生很大的影响。</p>\n<p>良心的组件库会直接在官网中告诉你应该怎样打包可以得到一个理想体积的UI包(比如<a href=\"https://material-ui.com/zh/guides/minimizing-bundle-size/\" target=\"_blank\" rel=\"noopener\">Material UI</a>，<a href=\"https://ant.design/docs/react/introduce-cn#%E7%A4%BA%E4%BE%8B\" target=\"_blank\" rel=\"noopener\">ant design</a>)，只需要严格按照其教程进行打包往往体积都不会过大。</p>\n<h2 id=\"4-Tree-Shaking\"><a href=\"#4-Tree-Shaking\" class=\"headerlink\" title=\"4. Tree Shaking\"></a>4. Tree Shaking</h2><p>使用Tree Shaking可以帮助我们删除项目中的废代码，从而减少打包的体积大小，对于Tree Shaking具体的原理和实践，可以移步。</p>\n<h2 id=\"5-Icon的打包\"><a href=\"#5-Icon的打包\" class=\"headerlink\" title=\"5. Icon的打包\"></a>5. Icon的打包</h2><p>如果你想使用上面提到的技术来优化你的Icon体积的话，你的Icon就不应该是一个CSS文件或是字体文件(比如Font Awesome)，否则在打包的时候webpack没有办法Shaking你的CSS文件和字体文件的，这个时候我们可以寻找一些替代品 — 如果你的组里有专业的UX的话，请UX将SVG图标给你，然后使用类似<a href=\"https://github.com/gregberge/svgr/tree/master/packages/cli\" target=\"_blank\" rel=\"noopener\">svgr</a>的工具将Icon转换成组件的形式，之后就是用到哪个就引入哪个了。当然了，既然组里已经有UX，其实这一步转换也不是很必要，毕竟UX设计的Icon理论上我们都会用到，不存在无用的打包。</p>\n<p>如果组里没有UX，需要我们自己去找Icon的话，<a href=\"https://github.com/react-icons/react-icons\" target=\"_blank\" rel=\"noopener\">response-icons</a>这样的工具会是一个好的选择，其包含了SVG格式的Font Awsome和其他的一些图标包，并且可以生成一个ES Module格式的React组件，我们就不需要用户去下载一个巨大的font文件了。</p>\n<h2 id=\"6-NPM包的体积问题\"><a href=\"#6-NPM包的体积问题\" class=\"headerlink\" title=\"6. NPM包的体积问题\"></a>6. NPM包的体积问题</h2><blockquote>\n<p>“NPM 就像一个乐高商店，里面装满了积木，你可以随意挑选你喜欢的。你不需要为安装 Package 付费。但是这些 Package 会占用应用程序的字节大小，你的用户会为此买单。所以请做出明智的选择。”</p>\n</blockquote>\n<p>如果在项目的初期能够确定性能要求十分严格的话，那么在选择开源NPM包的时候，就需要考虑NPM包的大小了，假如两个包的作用类似的话，我们是不是可以考虑使用相对较小的包引用到我们的项目中呢。</p>\n<p>但是需要注意的是，不要一味的追求包的体积，作者对包的维护或者是团队对包的掌控力也是一个重要的指标，如果作者修复的速度过慢，你们是否可以自己去修改这个“小包”来解决这个问题呢？或者换句话说，团队里是不是有别的实现可以不去用这些大体积的包呢？</p>\n<h2 id=\"7-TSlib\"><a href=\"#7-TSlib\" class=\"headerlink\" title=\"7. TSlib\"></a>7. TSlib</h2><p>现在TypeScript可以说已经是前端必备的语言了，但是浏览器运行的还是JavaScript，所以我们的代码最终都会被编译成ES5的JavaScript文件，同时TypeScript的编译器会为其添加一些辅助函数，为了确保你的代码中使用的一些旧浏览器不支持的ES6+的特性。</p>\n<p>那么也就是说，大多数情况下你的TypeScript文件都会有一些辅助函数，从单个文件来看这些辅助函数的确不大，但是问题在于随着项目的增大，这些函数在每一个文件中都存在，而且由于其特殊性，webpack的tree shaking没有办法删除重复的函数，这就导致我们编译后的包含有很多重复的辅助函数代码。</p>\n<p>一个叫做<a href=\"https://github.com/Microsoft/tslib\" target=\"_blank\" rel=\"noopener\">tslib</a>的包解决了这个问题，这个包里包含了TypeScript在编译时所需要的所有辅助函数，安装之后我们只需要按照教程在tsconfig中进行配置，就可以让编译器从这个包里去引入辅助函数，从而达到去重复的目的(是不是有点像code split的单独打包，没错，原理就是这样的)。</p>\n","categories":["技术细节"],"tags":["bundle","打包"]},{"title":"React中的错误处理","url":"https://teobler.com/20190906-error-handler.html","content":"<blockquote>\n<p>由于本文使用了比较通用的redux技术栈，所以本文默认读者对redux和redux的middleware相关的知识已经有足够的了解，所以本文不会就相关领域做展开讨论。</p>\n</blockquote>\n<p>Error handler是一个项目中不得不做的一件事，不论是用户的错误操作还是网络请求发生异常，都需要一个机制来告诉用户 — 这里挂了，你待会再来。</p>\n<p>而如果这个东西做的不好的话，就会散落在项目的各个地方，在任何你觉得会发生错误的地方，你都需要提前做好预防，防止未来系统在这里挂掉。如果这样的话，那么你的handler就会极难维护，错误处理的需求一变，你需要翻遍整个项目，去寻找那些散落在各处的“星星”。</p>\n<h2 id=\"Error-Middleware-With-Redux\"><a href=\"#Error-Middleware-With-Redux\" class=\"headerlink\" title=\"Error Middleware With Redux\"></a>Error Middleware With Redux</h2><p>在项目中我们使用redux的中间件来管理error handling这件事。在redux的store中，我们使用redux提供的<code>applyMiddleware</code>接口将<code>errorMiddleware</code>与其他的middleware组合起来形成一个<code>enhancer</code>，然后在<code>createStore</code>的时候传进去。</p>\n<h2 id=\"错误处理流程\"><a href=\"#错误处理流程\" class=\"headerlink\" title=\"错误处理流程\"></a>错误处理流程</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> createErrorMiddleware = <span class=\"function\">(<span class=\"params\">shouldHandleError: (<span class=\"params\">action: AnyAction</span>) =&gt; <span class=\"built_in\">boolean</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch &#125;: MiddlewareAPI</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">next: Dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action: AnyAction</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shouldHandleError(action)) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// do what you want</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先由于是middleware，所以会拦截到所有的action，通常并不是所有的action都需要错误处理，所以我们会在一开始时通过<code>shouldHandleError</code>函数来判断这个action是否需要错误处理，不需要的话直接dispatch一个新的action给下游。</p>\n<p>如果需要处理的话可以进一步判断这个action是哪一类错误，需要对其做什么处理等等，这一步往往跟业务强相关，不同的项目组会有不同的需求，需要“对症下药”。比较通用的做法是在拿到<code>error message</code>后在页面中将其显示出来，及时给用户一个反馈，告诉用户这时应该怎么做。</p>\n<h2 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h2><p>在有一些比较特殊的情况下我们并不想处理某个类型的错误，这时我们也会在<code>shouldHandleError</code>中进行错误action的过滤。通常可以设置一个标志位，当检测到这个标志位的时候就过滤掉这个action，不进行处理。</p>\n<h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><p>错误发生之后，我们通常需要告诉用户我们的App发生了什么错误，或者告诉用户下次应该如何避免这样的错误。这时候就需要一个全局范围的通知信息，将错误信息显示出来，我们一般会选择Toast/Snack Bar作为错误信息的容器。</p>\n<h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><p>比较常见的错误之一就是业务上的错误请求，比如参数错误，用户误操作发送请求等。这时通常后端会在response中塞入一个error message，我们就可以将error message或者设置在前端的一个默认错误信息放入一个错误的action中。当这个action被error middleware捕获到后就可以dispatch一个新的action通知用户发生了什么错误。</p>\n<p>而其它的常见错误比如后端返回的各种状态码4XX/5XX等也会用相同的处理方式进行处理。</p>\n<h2 id=\"主动抛错\"><a href=\"#主动抛错\" class=\"headerlink\" title=\"主动抛错\"></a>主动抛错</h2><p>在一些情况下前端也需要主动抛出错误，告诉用户当前操作是违规操作，在不发请求的情况下主动抛出错误，提升用户体验。举个例子，比如在文件上传的时候，为了保护磁盘空间，往往会限制用户上传文件的大小。如果此时让后端来返回错误的话，其实文件已经上传了，实属没有必要，所以往往我们会在上传前检查文件大小，如果文件过大，我们便可以主动抛错，告诉用户从新上传一个小一些的文件。</p>\n","categories":["技术细节"],"tags":["errorHandler","错误处理"]},{"title":"函数式初识(6) - 组合","url":"https://teobler.com/20190903-compose.html","content":"<p>在<a href=\"https://teobler.com/20190822-point-free.html\">Point-free</a>的文章中我们简单的提到过组合(compose)技术，现在我们来做一些比较沉入的了解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus2</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x - <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">triple</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * <span class=\"number\">3</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 算总价</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> temp = increment(<span class=\"number\">4</span>);</span><br><span class=\"line\">temp = triple(temp);</span><br><span class=\"line\">totalCost = basePrice + minus2(temp);</span><br></pre></td></tr></table></figure>\n<p>可以看到这段代码其实就是在利用一个中间变量去计算最终的购物总价，为了理解这段代码，你需要将所有东西串联起来，理解了第一个去理解第二个，然后将第一个和第二个联合起来，就得到了中间那个变量是个啥，然后要将之前的基础价格加起来也就是说你需要将所有东西放到一起来理解 — 中间变量，基础价格，所有的函数。</p>\n<p>这个时候我想跟大家介绍一种思想 — 抽象(abstraction)。抽象指的是在两个原本“耦合”在一起的事物中加入一个语义边界使其分离。那么语义边界是啥？在下面的例子里我们来慢慢揭晓。其实抽象并不是要将与主体不相关的东西隐藏起来，它更希望是将它们独立分离开。使我们能够对两个或多个事物进行独立思考并且不用考虑另外的事物对它的影响，更容易去分析和理解。所以对于第6行到第8行代码，我们要想办法分离他们，并不是说我们要隐藏。</p>\n<p>接下来我需要你在代码和虚拟故事中不断切换自己的身份：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/right-to-left.png\" alt=\"right-to-left\"></p>\n<p>我们假设你是流水线上的一个工人，你的任务是维护和改造这条流水线。第一步我们将融化的巧克力倒进漏斗，然后千克力就被变成一个个大的巧克力方糖；然后进入下一个机器，这个机器将大的方糖切成小方糖；再然后小方糖进入最后一个机器，被做成糖果。</p>\n<p>有一天，老板老找你说：小伙，我们这个机器供应不足啊，这不行啊，你想想办法，加加速，多做点，但是我没多余的厂房了，你自己想想办法哈。</p>\n<p>我们回到代码里，想想那些中间变量。那些中间变量其实除了给我们增加理解负担以外并没有什么用了。所以，我们来看看能不能用一种大家常用的方式干掉它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">totalCost = basePrice + minus2(triple(increment(<span class=\"number\">4</span>)));</span><br></pre></td></tr></table></figure>\n<p>其实，这就是函数的组合 — 一个函数接收一个参数，然后将其唯一的返回值作为下一个函数的参数。那么这么来看，我们用这种方式干掉了中间变量，是不是就节省了很多空间呢？</p>\n<p>然后我们回到工厂里，我们是不是就可以想象，如果我们能把工厂里的中间变量干掉，那是不是在节省了空间的同时我们还可以加快加工的速度呢？比如这样：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/candy-factory.png\" alt=\"candy-factory\"></p>\n<p>然后你的老板很开心，心里想996果然是有效果的。不过资本家嘛，肯定还有别的想法的，过了一段时间，老板又来找你了。老板说厂里的机器太多了，你是工头，你能清楚的记得啥时候按启动键，啥时候应该把料放到下一个机器里，但是流水线上的工人不知道哇，你能不能把流水线搞简单点，就一台机器，巧克力放进去，糖就出来了，这样可以减(ci)轻(tui)点工人的负担。这个时候该你犯嘀咕了，先不说能不能做到，就算能做到，中间某一步出问题了咋办？我把机器拆了去看哪出问题了？那我不得好好研究研究，不给自己挖坑，以后修机器咋整呢。</p>\n<p>回到代码里，我们的代码也有相同的问题，这个时候我们的解决办法也很简单 — 函数提取：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shippingRate</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minus2(triple(increment(x)));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">totalCost = basePrice + shippingRate(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>所以在最后一行我们的代码就被拆分成两个部分了，比之前简洁了很多，这个时候其实我们已经做了一个完整的抽象。还记得上面说的语义边界吗？这里的语义边界就是函数名，语义边界将如何去做(函数定义)和做了什么(函数调用)做了分离。</p>\n<p>回到工厂里来，是的没错，为了完成老板的任务，其实我们只需要在整个机器外边套一个大箱子就可以了，箱子上我们搞一个控制面板，方便我们修机器，对于工人来说，他们只需要打开开关，放入材料，所有的一切就可以自动运转了。就像这样：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/candy-factory-box.png\" alt=\"candy-factory-box\"></p>\n<p>然后过了几天，老板想扩充市场了，他不但想做巧克力，还想做小黑兔奶糖，可能还要做别的玩意，可是他又不想买一堆新机器，成本太高了，他想让你改造发明下，能不能用机器去生产机器，我想做奶糖，就用大机器去生产一个奶糖机器，然后奶糖机器就可以用来做奶糖，想做巧克力就生产一个巧克力机器，然后就可以用它生产巧克力。</p>\n<p>回到代码里来，在真实的代码环境中，如果真的需要我们计算消费价格，我们可能有许许多多的价格需要计算，那么为了计算这些价格，我们就需要定义许许多多的价格计算函数，那我们能不能定义一个“组合”函数去生成这一堆的函数呢？比如这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">composeThree</span>(<span class=\"params\">fn2, fn1, fn0</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">composed</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn2(fn1(fn0(v)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们的计算函数就可以这样定义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shippingRate = composeThree(minus2, triple, increment);</span><br><span class=\"line\"></span><br><span class=\"line\">totalCost = basePrice + shippingRate(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>于是利用我们已经定义好的“函数组件”，我们可以定义出各种各样的计算函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> internetShippingRate = composeThree(double, increment, minus1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> xxxShippingRate = composeThree(increment, triple, minus4);</span><br></pre></td></tr></table></figure>\n<p>这样的定义不仅仅是<a href=\"https://teobler.com/20190822-point-free.html\">Point-free风格</a>的，而且要更加偏向于声明式，更易于理解。可以看出<code>compose</code>函数实际上是一个“从右到左”的执行过程，我们将最初的参数传给最右边的函数，计算后的返回值传入左边的函数，直到计算出最终结果。</p>\n<p>其实<strong>组合就是一条声明式的数据流</strong>。数据经过了一系列的函数运算之后得到最终的返回值。所以其实组合的思想在于，你的所有程序都是一系列的数据流，你的任何程序都是拿到一个输入值，做一些事情，然后返回一个值，下一个部分再拿到这个值，以此反复。所以组合技术对于函数式编程是至关重要的。</p>\n<p>最后一次，我们回到工厂里，按照代码里面的解决办法，其实我们的工厂就有了这么一个解决方案：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/factory-factory.png\" alt=\"factory-factory\"></p>\n<h3 id=\"Pipe-VS-Compose\"><a href=\"#Pipe-VS-Compose\" class=\"headerlink\" title=\"Pipe VS Compose\"></a>Pipe VS Compose</h3><p>Compose是一种从右到左的定义方式，相对应的，Pipe是一种从左到右的定义方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minus2</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x - <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">triple</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * <span class=\"number\">3</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = composeThree(minus2, triple, increment);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p = pipeThree(increment, triple, minus2);</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">4</span>); <span class=\"comment\">// 7</span></span><br><span class=\"line\">g(<span class=\"number\">4</span>); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n<p>为什么有两个方向呢？我也不知道，只能说一个大概的理解。当我们有一组函数是这样调用的<code>A(B(C()))</code>，那么他们的执行顺序是 — C =&gt; B =&gt; A。表面上来看他们的执行顺序是从右到左的，但是其实是从内到外的。所以其实compose的参数顺序是符合真正的函数复合调用的书写顺序的。但是为了更加迎合我们的人脑思考，就有了Pipe，因为大脑一般会思考一个从左到右的执行顺序。</p>\n<h3 id=\"结合律与柯里化\"><a href=\"#结合律与柯里化\" class=\"headerlink\" title=\"结合律与柯里化\"></a>结合律与柯里化</h3><p>众所周知，结合律也是数学中的一个定律。compose是严格遵守结合律的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose(fn1, compose(fn2, fn3)) === compose(compose(fn1, fn2), fn3);</span><br></pre></td></tr></table></figure>\n<p>所以组合就可以与柯里化完美运用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x, y</span>) </span>&#123; <span class=\"keyword\">return</span> x + y; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">triple</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * <span class=\"number\">3</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divBy</span>(<span class=\"params\">y, x</span>) </span>&#123; <span class=\"keyword\">return</span> x / y; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">divBy(<span class=\"number\">2</span>, triple(sum(<span class=\"number\">3</span>, <span class=\"number\">5</span>))); <span class=\"comment\">// 12</span></span><br><span class=\"line\"></span><br><span class=\"line\">sum = curry(<span class=\"number\">2</span>, sum);</span><br><span class=\"line\">divBy = curry(<span class=\"number\">2</span>, divBy);</span><br><span class=\"line\"></span><br><span class=\"line\">compose(</span><br><span class=\"line\">    divBy(<span class=\"number\">2</span>),</span><br><span class=\"line\">    triple,</span><br><span class=\"line\">    sum(<span class=\"number\">3</span>)</span><br><span class=\"line\">)(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Point-free-with-composition\"><a href=\"#Point-free-with-composition\" class=\"headerlink\" title=\"Point-free with composition\"></a>Point-free with composition</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mod2 = mod(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> eq1 = eq(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isOdd</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> eq1(mod(x));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = compose(eq1, mod2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = compose(eq(<span class=\"number\">1</span>), mod(<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"函数式初识(5) - 偏函数和柯里化","url":"https://teobler.com/20190831-partial-and-currying.html","content":"<h2 id=\"从通用到特殊\"><a href=\"#从通用到特殊\" class=\"headerlink\" title=\"从通用到特殊\"></a>从通用到特殊</h2><p>在前面的文章中我们已经提到过在函数式编程中，一个函数“形状”的重要性，我们力求每一个函数都是一元函数，以便我们将各个函数组合在一起，但是我们总会遇到各种各样的情况迫使我们的函数是一元二元甚至是多元的，这时我们就需要借助柯里化来“改变函数的形状”，使其能够适应别的函数。同时这也是将一个函数从“一般化”引向“特殊化”的过程，这在函数式编程中极其重要。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = (url, data, cb) &#123;<span class=\"comment\">/*..*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(CUSTOMER_API, &#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span> &#125;, renderCustomer);</span><br></pre></td></tr></table></figure>\n<p>假如我们有一个函数<code>ajax</code>，然后我们通过传入一些参数调用它，它的作用是通过请求某个API拿到数据后在页面中渲染UI。一个很常见的函数，但是或许我们在调用的时候给了太多的信息量，这需要代码的阅读者思考这里发生了什么，我们其实可以让它传达的信息更简单些，能让读者一瞬间清晰的理解代码想要表达的内容，当然不是为了让代码单纯的更短，实际上可能会更长。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCustomer (data, cb) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(CUSTOMER_API, data, cb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getCustomer(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span> &#125;, renderCustomer);</span><br></pre></td></tr></table></figure>\n<p>因为<code>url</code>其实是一个hard code，我们实际上只需要request data和callback就可以调用这个函数，那么我们将<code>ajax</code>封装用<code>getCustomer</code>起来，这个时候再去调用，就会少了一个变量，同时也少了一些信息量，能让读者一眼看出这个函数想干嘛。但是其实这个功劳是函数名带来的，这个名字要比<code>ajax</code>更加语义化，更能让人明白目的。</p>\n<p>这样的变化其实并没有让代码变简单，但是因为多封装了一层函数，表面上看起来代码变复杂了，但是你可以将一个“一般化”的函数变成一个“特殊化”函数，并给它取了一个语义化的函数名，能让人一眼看出这个特殊的函数目的是什么，更容易理解。</p>\n<p>按照这个思路，其实我们可以进一步将这个更加“特殊化”，向读者传递更加深层的信息。比如我们需要拿到当前特定登录用户的信息，那么我们可以有下面这样一个函数，可以更加详细的表达这些信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getCurrentUser (cb) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// return ajax(CUSTOMER_API, &#123; id: 33&#125;, cb);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getCustomer(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span>&#125;, cb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getCurrentUser(renderCustomer);</span><br></pre></td></tr></table></figure>\n<p>值得注意的是我们在定义<code>getCurrentUser</code>这个函数的时候，我们其实可以用<code>ajax</code>这个函数去定义，不用是因为<code>getCustomer</code>能让我们更加清晰的去表达各个函数之间层层递进的关系。</p>\n<h2 id=\"参数顺序\"><a href=\"#参数顺序\" class=\"headerlink\" title=\"参数顺序\"></a>参数顺序</h2><p>当你想要让一个函数从“一般化”到“特殊化” — 也就是让一个多元函数逐渐变成一个一元、二元函数 — 的时候，我们需要重点考虑传入参数的顺序。参数的优先级应该也是从一般化到特殊化的，也就是说最闲传入的参数应该是一个一般化的参数，后面的参数越来越多具体。假如你一开始传入的就是一个很具体的参数，那么后面的参数将难以与其匹配，这个函数将直接成为一个单一作用的函数。</p>\n<p>例如上面的<code>ajax</code>函数，如果我一开始传入的参数就是一个callback，那么我得到的新的柯里化函数只能用作render，别无它用，这也违背了函数式中函数组件复用的原则。所以在设计函数的时候，参数的顺序是一个很重要的点，这一点可以从各个函数式的三方库中(ramda.js, lodash/fp等)去吸取经验。</p>\n<p>比如<code>ramda</code>库中的<code>map</code>函数，其所接受的第一个参数是callback回调函数，第二个参数时传入这个callbak的数组，第一个参数使这个map函数成为了一个特殊化的<strong>mapper</strong>，之后可以很轻易的复用它，它可以接受各种输入返回需要的值。假如第一个参数使数组，那么返回的新函数将是一个只用于该数组的map函数。</p>\n<h2 id=\"偏函数-partial-和柯里化-currying\"><a href=\"#偏函数-partial-和柯里化-currying\" class=\"headerlink\" title=\"偏函数(partial)和柯里化(currying)\"></a>偏函数(partial)和柯里化(currying)</h2><p>偏函数和柯里化是每一个函数式编程的库都会为你提供的两个工具函数，有了这两个函数，我们就可以不必手动去写如同上面例子的”函数特殊化”，这一切可以交给工具函数帮我们实现。我们不关心其内部怎么实现的，我们在此只说怎么使用它们。</p>\n<p>看到偏函数这个名字是不是有点熟悉，不错，它来源于数学中的偏导：</p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6\" target=\"_blank\" rel=\"noopener\">数学</a>中，一个多变量的函数的<strong>偏导数</strong>（英语：partial derivative）是它关于其中一个变量的<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%BC%E6%95%B0\" target=\"_blank\" rel=\"noopener\">导数</a>，而保持其他变量恒定（相对于<a href=\"https://zh.wikipedia.org/wiki/%E5%85%A8%E5%AF%BC%E6%95%B0\" target=\"_blank\" rel=\"noopener\">全导数</a>，在其中所有变量都允许变化）</p>\n</blockquote>\n<p>那么这样就很好理解了，其实偏函数相当于提前设定好了某个函数需要的部分参数，并返回一个新的函数来等待接下来的参数传入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax(url, data, cb) &#123; <span class=\"comment\">/*...*/</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getCustomer = partial(ajax, CUSTOMER_API);</span><br><span class=\"line\"><span class=\"comment\">// const getCurrentUser = partial(ajax, CUSTOMER_API, &#123; id:33 &#125;);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getCurrentUser = partial(getCustomer, &#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">getCustomer(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span>&#125;, renderCustomer);</span><br><span class=\"line\">getCurrentUser(renderCustomer);</span><br></pre></td></tr></table></figure>\n<p>熟悉函数式的同学可能会更加喜欢柯里化，柯里化能将一个接受多个参数的函数转换成一次只接受一个参数的函数，没接收一个新的参数，将会返回一个新的函数等待接下来的一个参数，一直到所有参数接受完成后返回运算的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const ajax =&gt; url =&gt; data =&gt; cb =&gt; ajax(url, data, cb);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCB</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ajax(url, data, cb);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(CUSTOMER_API)(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span>&#125;)(renderCustomer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getCustomer = ajax(CUSTOMER_API);</span><br><span class=\"line\"><span class=\"keyword\">const</span> getCurrentUser = getCustomer(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>当然这里我们是手动定义了一个天然柯里化的函数，但是如果每个函数都这样写那就太累了，所以我们用库来帮我们完成这件事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = curry(<span class=\"number\">3</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">url, data, cb</span>) </span>&#123;<span class=\"comment\">/*...*/</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getCustomer = ajax(CUSTOMER_API);</span><br><span class=\"line\"><span class=\"keyword\">const</span> getCurrentUser = getCustomer(&#123; <span class=\"attr\">id</span>: <span class=\"number\">33</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>curry函数要你告诉它你想要柯里化的函数有几个参数，然后再传入那个函数就ok了。</p>\n<h2 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h2><ul>\n<li>两者都为了达成一个目的 — 将一个一般化的通用函数变成一个特殊化的函数。</li>\n<li>柯里化能做到”一次付费终生使用“，你只需要柯里化一次你的函数，那么这个函数就能被任意级别的特殊化，并且柯里化没有预先传入参数，所有参数需要你在接下来的使用中逐个传入。</li>\n<li>偏函数是”一次定型”的，每一次如果你想要继续改变函数的形状，你都需要再次调用工具函数，并且在最开始就传入了一部分初始参数，剩下的参数在调用时一次传入。</li>\n</ul>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"函数式初识(4) - 闭包","url":"https://teobler.com/20190829-closure.html","content":"<p>闭包是一个在JS中怎么都绕不过的问题，不论是新手入门还是面试，你总会在各种地方看到它。而闭包在函数式编程中也是极其重要的，在前面的几篇文章中，几乎每个例子我们都用到了闭包，所以如果你对闭包的理解不到位的话，可以说你用不好函数式编程。可是一部分同学依然对闭包有一定的误解，这篇文章就是想要清除这些误解。</p>\n<h2 id=\"闭包与函数式\"><a href=\"#闭包与函数式\" class=\"headerlink\" title=\"闭包与函数式\"></a>闭包与函数式</h2><p>那么什么是闭包呢？这里有一个通俗的解释：</p>\n<blockquote>\n<p>Closure is when a function remembers and accesses variables from outside of its own scope, even when that function is executed in a different scope.</p>\n</blockquote>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> makeCounter = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">increment</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ++counter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = makeCounter();</span><br><span class=\"line\"></span><br><span class=\"line\">c(); <span class=\"comment\">// 1</span></span><br><span class=\"line\">c(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">c(); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>这里的<code>makeCounter</code>函数并没有任何输入值，然后它定义了一个变量<code>counter</code>然后返回了一个函数，每次我们调用这个函数，这个函数将<code>counter</code>加一后返回。可以看到其实在调用函数<code>c</code>的时候，我们并没有传入任何参数，但是它依旧可以返回一个累加过后的根本不存在于自己作用域内的<code>counter</code>。</p>\n<p>可以看出，这里的<code>c()</code>并不是一个纯的函数调用，我们每一次传入相同的参数(undefined)，都会得到一个不同的返回值。由此可见：</p>\n<blockquote>\n<p>闭包不一定是一个纯函数，但是闭包可以用在函数式理论中</p>\n</blockquote>\n<p>所以关键点其实在于：我可以在闭包中封装一个变量，但是我需要保证这个变量是一个常量，它不能被重新赋值，如果它被重新赋值了，那么这个函数就不再是一个纯函数，下面就是两个封装了一个常量的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unary = <span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">one</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addAnother = <span class=\"function\">(<span class=\"params\">z</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwo</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y + z;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个<code>unary</code>方法先接受了一个函数<code>fn</code>并”记住”了它，在传入一个参数的时候进行调用，所以在这个例子中，这个参数变量是一定不会被改变的。第二个例子同理。</p>\n<h2 id=\"lazy-VS-eager\"><a href=\"#lazy-VS-eager\" class=\"headerlink\" title=\"lazy VS eager\"></a>lazy VS eager</h2><p>这两是啥意思呢？别着急，我们先来看几个例子，你马上就懂了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeater = <span class=\"function\">(<span class=\"params\">count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allTheAs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.padStart(count, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = repeater(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br></pre></td></tr></table></figure>\n<p>可以看到这个函数的最终目的是返回N个相同的”A”，但是真正做“返回”这件事的地方是在第10行开始，或者说是闭包里面的函数真正被调用的时候，在生成<code>A</code>这个函数的时候，我们什么都没做，仅仅是记住了<code>count</code>这个入参，在之后进行了真正的计算。但是这也就意味着，你调用了几次<code>A</code>函数，你就需要做几次相同的生成”A”的工作。</p>\n<p>那么我们就说这个闭包就是<strong>Lazy</strong>的。那么问题来了，为什么我们要把一些工作推迟到里面的闭包真正执行的时候才执行呢？其中的一个原因是，我们可能并不确定闭包里面的函数什么时候会被调用。我们假设这样一个情景 — 闭包里是一个比较复杂的函数，而不是像例子中一样仅仅返回N个重复的字符，而且我们可能只有10%的可能性执行这个函数，那么是不是这种推迟执行的方式就能节省许多不必要的计算呢？</p>\n<p>接下来我们来聊聊<strong>eager</strong>，假如上面的例子是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeater = <span class=\"function\">(<span class=\"params\">count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> str = <span class=\"string\">\"\"</span>.padStart(count, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allTheAs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = repeater(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br></pre></td></tr></table></figure>\n<p>可以看到虽然它们的最终输出结果是一致的，但是其实计算在第8行调用<code>repeater</code>这个函数的时候就已经计算好了，在后续调用函数<code>A</code>的时候仅仅只是返回了一个已经计算好的结果。如果我们可以确定这个闭包一定会被调用多次，那么这样的定义方式可以节省很大的开销。</p>\n<p>说到底其实可以说，<strong>在闭包中，你封装常量的位置决定了这个闭包是lazy的还是eager的。</strong></p>\n<h2 id=\"小孩子才做选择，我全都要\"><a href=\"#小孩子才做选择，我全都要\" class=\"headerlink\" title=\"小孩子才做选择，我全都要\"></a>小孩子才做选择，我全都要</h2><p>这个时候可能有人会问，有没有一种中庸的解决办法呢？当然：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeater = <span class=\"function\">(<span class=\"params\">count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allTheAs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">            str = <span class=\"string\">\"\"</span>.padStart(count, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = repeater(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br></pre></td></tr></table></figure>\n<p>可以看到这种方法也是delay的，计算真正生效在第10行<code>A</code>函数调用的时候，然后我们将结果”cache”起来了。可是熟悉函数式的小伙伴可能会立马拉起警报，这样的函数调用还是纯的吗？</p>\n<p>在函数定义的时候很显然我们将<code>str</code>的值从<code>undefined</code>重新赋值成了<code>AAAAAAAAAA</code>，而且这还是一个外部变量，其实这是打破了纯函数的原则的。虽然在函数定义的时候破坏了纯函数原则，但是在真正调用<code>A</code>函数的时候，其实<code>A</code>函数的调用是一个纯的函数调用，它完美符合纯函数调用的所有特点。</p>\n<p>不过在”函数式洁癖”们看来，这样的做法依旧是不可接受的，毕竟已经产生了副作用，不能算作是纯函数了，也违背了函数式的原则，所以能不能解决呢？我们需要借助一个工具函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> repeater(count) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memoize(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">allTheAs</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>.padStart(count, <span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = repeater(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br><span class=\"line\">A(); <span class=\"comment\">// AAAAAAAAAA</span></span><br></pre></td></tr></table></figure>\n<p><code>memoize</code>函数会对传入的参数做一个cache，如果传入的是一个函数，那么在调用这个函数时会将返回值cache起来，下次调用时直接返回结果。</p>\n<p>所以这段代码不论是从定义还是从调用来看都是纯的，并且要更偏向于声明式的。这里有另外一个重点是，不要cache你的每一个函数，可以想象，这样的方式的确能够降低很多计算，但是有一个前提是，你的这个函数会被<strong>用相同的入参调用很多次</strong>，假如你的方法只会被调用一两次或者是用不同的入参调用多次，那么你在cache的时候实际上是浪费了更多的资源的，毕竟这不仅仅是在你的函数外面再包一层函数那么简单，memoize底层用内存帮你存储了结果。这时你实际需要的可能是lazy的闭包。</p>\n<p>这种代码风格被称作<strong>Memoization</strong>。</p>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"HTML换行","url":"https://teobler.com/20190827-newline-in-html.html","content":"<p>在html中，如果你的字符串是写在某个标签里面的，那么不管是真正的回车换行还是你用转义 <code>\\n</code>换行，你都得不到你想要的结果：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  abc\\n</span><br><span class=\"line\">  `def\\n`</span><br><span class=\"line\">  \"ghi\\n\"</span><br><span class=\"line\">  fd</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段标签最后会显示成这样：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/without-newline.png\" alt=\"without-newline\"></p>\n<p>也就是说，真正的回车换行会变成空格，你想象中的转义会被原封不动的显示出来。为了解决这个问题，你需要CSS中的一个属性 — <code>white-space</code>。</p>\n<p>这个属性被用来”告诉“html如何处理”空白“元素，但是这里的空白并不是你想象中的空格。这里的”空白“指的是用于显示正常字符之间的水平或者垂直的空格。所以你会发现在html中多个空格最后会被显示成一个空白，回车也会被显示成一个空白。</p>\n<p>这个时候可以将<code>white-space</code>设置成：</p>\n<ul>\n<li><strong>pre-wrap</strong> — 连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</li>\n<li><strong>pre-line</strong> — 连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre-wrap;\"</span>&gt;</span></span><br><span class=\"line\">  ab    c\\n</span><br><span class=\"line\">  `def\\n`</span><br><span class=\"line\">  \"ghi\\n\"</span><br><span class=\"line\">  </span><br><span class=\"line\">  fddf</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"white-space: pre-line;\"</span>&gt;</span></span><br><span class=\"line\">  ab    c\\n</span><br><span class=\"line\">  `def\\n`</span><br><span class=\"line\">  \"ghi\\n\"</span><br><span class=\"line\">  </span><br><span class=\"line\">  fddf</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的两段代码会被分别渲染成：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/newline-with-space.png\" alt=\"newline-with-space\"></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/newline-without-space.png\" alt=\"newline-without-space\"></p>\n","categories":["技术细节"],"tags":["HTML"]},{"title":"函数式初识(3) - Point-Free","url":"https://teobler.com/20190822-point-free.html","content":"<p>Point-free是什么？Point实际上指的是函数的参数，Point-free是一种编程风格，这是一种在函数里面实际上没有写任何东西的函数编写方式，这种方式可以将一个函数与其他函数一起生成一个新的函数，而实际上并没有定义这个新的函数的参数是什么。比如下面这个函数就是一个简单的Point-free风格的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> R <span class=\"keyword\">from</span> <span class=\"string\">\"ramda\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addOne = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addOneThenSquare = R.compose(square, addOne);</span><br><span class=\"line\"></span><br><span class=\"line\">addOneThenSquare(<span class=\"number\">1</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>由于JS不是一门严格的函数式编程语言，所以在这里我们引入了一个叫做“ramda”的第三方库来帮我们完成一些函数式编程的事情。首先我们有两个简单的函数，这两个函数的作用分别是对传入的数进行加一和平方的操作，然后我将两个函数compose(compose是函数式编程里面的一种方法，该函数会将接收到的方法“从右到左”串联起来依次执行，将上一个函数的返回值作为下一个函数的入参)起来得到一个新的函数，这个新函数的作用是讲传入的数先加一再平方。定义这个新函数的方法就是Point-free风格。</p>\n<p>当我们的函数中有参数时，我们的编程风格更像是命令式的，其实我们是在引导一个变量从输入值转换成输出值。但是当我们使用Point-free风格编程时，我们的编程就更偏向声明式。实际上我们是将参数的转换过程隐藏了，其实当你去问别的程序员代码是显式的好还是隐式的好，可能大多数程序员都会告诉你显式的好，因为那可以让你看到代码里发生了什么。但是在有的情况下代码可以是隐式的，比如在函数式编程中，那些一个个的“函数组件”能够给我们足够的信心处理好我们的输入输出，我们只需要关注在最后的输出是不是我们想要的，不用去关注它是怎么去做转换的，因为这对于读你代码的人来说是一些不必要立马去了解的细节。</p>\n<h2 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h2><p>Point-free的定义很简单，看到这里说不定一些读者就会说到，我以前也这么玩过，只不过我不知道这个就叫做Point-free。是的Point-free的定义很简单，但是要用好它就没那么简单了。设想一下，上面那个简单的例子，如果把他们的函数名改成xyz，你还能知道最后一个函数是在干嘛吗，当然这个例子比较极端，但是不妨试想下你在项目上看到过的同事起的各种奇葩的命名，然后将这一堆看起来就不知道干嘛的函数全部compose在一起，那这对于维护代码的人来说将是灾难性的。这就与函数式编程能够提高代码可读性的结论背道而驰了。所以要用好Point-free的第一件事情就是为你的函数“组件”起一个通俗易懂的好名字，让阅读者能够看着名字就知道函数在干嘛而不用去深入函数细节，还原函数式编程的初衷。</p>\n<p>所以不要滥用Ponit-free，当项目中出现了过多的Point-free风格但又没有严格符合编程规范的话，很可能会让你的项目难以维护。</p>\n<p>但是其实compose只是Point-free中的一种应用，还有许许多多别的应用，只要你使用得当，你的代码依旧可以清晰可读，比如下面的这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> not = <span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">negated</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !fn(...args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd(v) = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v % <span class=\"number\">2</span> === <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isEven = not(isOdd);</span><br><span class=\"line\"></span><br><span class=\"line\">isEven(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，我们当然可以将<code>isEven</code>的定义写成<code>return v % 2 === 0</code>，但是其实这样的定义是给代码的阅读者增加了额外的理解负担的，你当然可以说例子里面的代码很简单，你可以一眼就看出来这个函数要做的事情，但是如果这是你公司项目中的一个复杂的判断函数呢，那是不是你就需要读两次几乎一样的代码来判断，最后发现这两个函数其实只是在做相反的事情。</p>\n<p>这样的定义方式并不是为了我们在写代码的时候可以少写几个字母，更重要的是让我们项目里面的各个”函数组件“之间有了联系，让读代码的人一眼就能看出来，这两个函数是相反的关系，让他能够更容易的理解代码，说到底是为了提升代码的可读性。</p>\n<h2 id=\"函数的“形状”\"><a href=\"#函数的“形状”\" class=\"headerlink\" title=\"函数的“形状”\"></a>函数的“形状”</h2><p>可以注意到在使用Point-free这种编程风格时，组成最新那个函数的各个函数“组件”都是只接受一个参数并且只返回一个返回值，也就是说这里的函数都需要是数学中的一元函数。所以在函数式编程中，保持你的所有函数是一元函数是及其重要的，这可以保证它们如同乐高玩具一样拥有相同的接口，可以相互连接在一起。</p>\n<p>当然并不是所有的函数都可以是一元函数，所以在函数式编程中有一个极其重要的东西是柯里化，当你的函数不是一元函数但是你却又想将其作为组件组合在一起时就需要通过柯里化的形式讲一个二元甚至是多元的函数转换成一个一元函数，然后再同其他函数组合在一起。也就是说在函数式编程中所有的函数都需要支持柯里化，这样才能保证各个函数之间能够正常工作。</p>\n<h2 id=\"Point-free的”高级“应用\"><a href=\"#Point-free的”高级“应用\" class=\"headerlink\" title=\"Point-free的”高级“应用\"></a>Point-free的”高级“应用</h2><p>其实Point-free的应用不仅仅是利用原本的函数来组合新的函数，更进一步的话，Point-free应该是使用一些函数的”通用组件“去组成你需要的”特殊组件“。我们还是以上面的两个函数为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mod = <span class=\"function\">(<span class=\"params\">y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forX</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x % y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eq = <span class=\"function\">(<span class=\"params\">y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forX</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x === y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>加入我们有两个函数，其中一个函数先接受一个变量y，然后返回一个函数，这个新返回的函数接收另一个参数x，然后返回x对y取余的结果；第二个函数先接受一个变量y，然后返回一个函数，这个新返回的函数接收另一个参数x，然后返回x是否等于y的结果。请注意，这两个函数有两个很重要的特点：</p>\n<ol>\n<li>它们接收的参数顺序是反直觉的，但是在函数式编程中却是必须应该这样的，原因我们可以继续往下看；</li>\n<li>它们虽然都不是一元函数，但是都经过了柯里化处理，是由两个一元函数”嵌套“而成的，这一点在函数式编程中也极为重要，这决定了这些函数是否有相同的接口，是否能够组合在一起；</li>\n</ol>\n<p>然后我们用这两个函数去定义我们之前例子中的两个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mod2 = mod(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> eq1 = eq(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> eq1(mod2(x));</span><br></pre></td></tr></table></figure>\n<p>我们先给mod和eq两个函数传了一个参数，让它们从一个一般化的函数成为一个特殊化的函数，之后<code>isOdd</code>函数只接受一个参数，这个参数直接传给<code>mod2</code>，然后它的返回值再直接传给<code>eq1</code>。这样的定义其实已经从命令式慢慢过渡到声明式了，只不过还不能算是函数式的Point-free。不过这样直接传一个参数，计算后直接将返回值传给下一个函数作为入参，这在数学中有一个名字叫做<strong>Composition</strong>。是的没错，就是文章开头的那个composition，其实compose函数也很简单，他只做了一件事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">fn2, fn1</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">composed</span>(<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn2(fn1(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以我们的定义又会变成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isOdd = compose(eq1, mod2);</span><br></pre></td></tr></table></figure>\n<p>但是其实在函数式编程中一般情况下大家都不会去特意构造一个特殊的函数(mod2, eq1)，所以其实最后的Point-free定义就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isOdd = compose(eq(<span class=\"number\">1</span>), mod(<span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n<p>其实乍一看上去，compose的参数也是反直觉的，人们通常习惯从左到右进行阅读，但其实这里的运行顺序是从右到左的。这当然是有原因的：</p>\n<ol>\n<li>我们回到之前提到的<code>eq</code>和<code>mod</code>函数中的第一个重要特点 — 参数顺序，我们假如他们的参数顺序是符合人类直觉的，那么他们就不可能像我们最终定义哪样进行定义；</li>\n<li>当然你也可以说，我可以改变compose函数的定义来让他们可以组合在一起呀。这就是我第二个原因，在数学中函数复合写作<code>f o g</code>（相当于compose(f, g))，意思是一个函数接收一个参数x，并返回一个f(g(x))。</li>\n</ol>\n<p>所以其实compose的定义是严格遵循数学中的composition的，当然如果你是在觉得这有点反直觉，其实也有一个叫做pipe的函数，作用跟compose完全一样，只是参数的顺序完全相反。</p>\n<p>而且compose也是完全符合数学中的结合律的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> associative = compose(f, compose(g, h)) === compose(compose(f , g), h); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>这也就意味着我们可以有更高的灵活性去组合我们的函数。</p>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"函数式初识(2) - 纯函数","url":"https://teobler.com/20190821-pure-function.html","content":"<h2 id=\"Function-VS-Procedures\"><a href=\"#Function-VS-Procedures\" class=\"headerlink\" title=\"Function VS Procedures\"></a>Function VS Procedures</h2><p>这里的纯函数指的是在函数式编程里面的纯函数。要理解好纯函数这个概念，就需要理解好程序和函数的区别。</p>\n<p>程序(Procedure)指的是一系列的逻辑运算，也就是大家所熟知的循环，分支，跳转等，然后利用这些运算在你的大程序(program)中做一些事情。看起来是不是很像函数？那么什么才是函数？</p>\n<h2 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h2><ol>\n<li>一个函数不但应该有输入(just one is the best)，还应该有输出(just one is the best)，也就是说函数应该有<strong>return</strong></li>\n<li>函数只能去调用函数，如果一个函数调用了程序，那么这个函数也会变成程序</li>\n<li>函数应该是一种输入输出之间的一种语义化的“关系”<ul>\n<li>就像是数学中的函数一样，这也就意味着你不能不管输入是啥，单纯的返回一个随意的返回值</li>\n<li>所以在函数式编程中，函数的名字应该能够清晰的描述这个函数是一种怎样的关系，所以你就能够轻易的在你的程序中通过组合各个函数来得到一个新的函数</li>\n<li>需要明确的是，没有输入也是一种有效的输入；undefined也是一种有效的输出</li>\n</ul>\n</li>\n<li>在多次调用同一个函数时，相同的输入应该有相同的输出</li>\n<li>最重要的一点，函数不应该有副作用，但是编程毕竟不是数学，这个要求在很多时候是很难达到的，所以退一步来说，我们应该尽最大可能降低函数的副作用。即使不能降低，那么我们有两个选择 — 首选我们当然是把副作用抽离函数，不行的话应该使副作用尽量明显，让读你代码的人能够一眼看出，这是这个函数的副作用。</li>\n</ol>\n<h2 id=\"Side-Effects\"><a href=\"#Side-Effects\" class=\"headerlink\" title=\"Side Effects\"></a>Side Effects</h2><p>广义上来说非直接的输入或输出都算是副作用，常见的副作用主要有：</p>\n<ul>\n<li>使用了外部变量做输入，或者是在计算后对位外部变量做了修改</li>\n<li>I/O — console, 读/写文件</li>\n<li>数据库操作</li>\n<li>网络数据请求</li>\n<li>DOM操作</li>\n<li>随机数</li>\n<li>CPU请求</li>\n</ul>\n<p>这也就说明了为什么副作用是不可避免的，只可能尽量降低。</p>\n<p>那么为什么在函数中避免副作用是很重要的呢？首先<strong>函数式编程是基于数学理论</strong>的，如果你在写代码的时候能够严格遵循函数式编程的规范，将函数和副作用分开，那么如果你的程序出现了bug，你将能够比较容易的发现问题出在了哪里 — <strong>如果是函数出了问题</strong>，那么一般情况下几乎可以断定是你用错了算法或逻辑(这里的“<strong>用错</strong>”指的是如同你在做数学题时用四则运算法则去做几何证明的问题)，因为你根本不用去考虑是不是算法内部的问题，就<strong>如同你不用去证明1+1=2一样</strong>。但是<strong>更多的情况</strong>是你的副作用部分出了问题，因为你的副作用真的产生了你没有预知到的副作用。</p>\n<p>而又说回JS，因为其实<strong>JS并不是一门严格意义上的函数式语言</strong>，所以对于JS来说其实最重要的部分是<strong>函数的调用</strong>，在JS中，当我们说纯函数时，其实更应该说的是纯的函数调用，因为就算你定义函数的时候“觉得”那已经是一个纯函数了，但是在真正调用的时候，依旧可能会产生一些你没有想到的副作用，比如下面的这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getId = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj.id;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一眼看到这个函数，我问你，这是不是一个纯函数 — 是呀，当然是，完美的符合上面的所有条件。是的，从定义上来看的确是一个纯函数，那么如果我这样调用呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getId(&#123;</span><br><span class=\"line\">    get id() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>很显然，这已经明显的破坏了上面所说到的纯函数的规则。所以在一个不是函数式的语言中，或者说是具体到JS来说，当你要去判断这是不是一个纯函数时，不但需要判断这个函数的定义，还需要去判断函数的调用。</p>\n<p>所以什么算是一个纯的函数调用呢：<strong>可以用这个函数的返回值去替换这个函数的调用，即引用透明。</strong></p>\n<p>所以这到底有什么好处呢？其实最大的好处就是 — 对于代码阅读者来说，当他第一次看到某个函数时，他只需要记住那个结果，那么在整个项目中，只要看到这个函数被用相同的参数调用，就可以直接把他换成结果，无需再思考函数返回了什么。也就是说，他不用再浪费时间来思考函数里面发生了什么，可以将这部分精力用在更重要的地方。</p>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"函数式初识(1) - 为什么要用函数式编程(以JS为例)","url":"https://teobler.com/20190818-why-fp.html","content":"<p><em>首先需要说明的是，这篇文章是以JS为例的，而JS并不是一个以函数式设计的语言，它仅仅是可以做到函数式，那么既然如此我为何还要以JS为例呢？很简单，因为我是一名前端，目前我只会JS。第二个前提条件是，我们假设所有你参与的项目不可能是你一个人完成的。</em></p>\n<p>函数式编程在React团队推出Hooks方案之后在前端领域算是掀起了一股小热潮，于是在各大网站上一些问题的热度突然就起来了，比如为啥要用函数式编程？而为了解释这个问题，就不得不提到两个编程思想。</p>\n<h2 id=\"命令式编程-Imperative-Programming-vs-声明式编程-Declarative-Programming\"><a href=\"#命令式编程-Imperative-Programming-vs-声明式编程-Declarative-Programming\" class=\"headerlink\" title=\"命令式编程(Imperative Programming) vs 声明式编程(Declarative Programming)\"></a>命令式编程(Imperative Programming) vs 声明式编程(Declarative Programming)</h2><p>命令式编程更加注重于<strong>如何(how)</strong>去实现某件事。</p>\n<p>例如给你一个数组求和，命令式的方法基本就是，声明一个变量total，然后来一个for循环，把每一个元素加到之前的total变量中，然后return。这种风格一步一步告诉计算机该怎么做，性能表现也相对优异。但是当过几天另外一个人来读这些代码的时候，他需要一行一行把代码加载到大脑里，然后人脑运算，得出结论，哦，这个for循环是求和。声明式的代码往往要强制让人们在自己的大脑中运行代码然后理解代码中的每一行做了什么事情，而运行代码显然不是我们人脑在行的，而这个运行代码的过程往往只是为了理解这些代码在干嘛。</p>\n<p>而声明式的代码风格就不那么注重于如何去做，声明式的代码更注重于代码的<strong>产出(what)</strong>。还是以数组求和为例，声明式的代码基本就只有一句sum函数，传参，拿到结果。这个时候可能熟悉JS的同学会说，可是sum函数还是要你去实现啊。这就是为什么JS是支持声明式的而不是完全声明式的。一些纯函数式的语言比如Haskell会提供许多已经实现的功能，你需要做的就是讲这些功能组合起来，去得到你想要的结果，至于里面是怎么实现的，你可以不用关心，就如同你将渲染逻辑交给了React而不用关心他的实现是不是有什么问题。</p>\n<p>可以看出声明式的代码可读性要强于命令式编程，原因是我们把运行代码这部分内容让更擅长的计算机来做了，我们需要做的仅仅是维护语义化很强的代码，我们不用在头脑里再运行一次代码，看这段代码究竟在干嘛。而说到代码维护，就又不得不提到<strong>注释</strong>。</p>\n<blockquote>\n<p>people always says, comments is a eval, if code has comments, that’s means the code is terrible. Code need to self document itself. I would say no, Code doesn’t need to self document itself. Code needs to tell a story, it needs to communicate, that’s for true. </p>\n<p>There is a purpose for code comments. They’re not an excuse for not caring about your code. A lot of people will go to the other extreme and say, what does it matter how bad the code as long as there’s a code comment, and I explanined what I was doing. </p>\n<p>A bad code comment is worse than no comment at all. You don’t have to remove all comments, but your comment should not duplicate the narrative of what the code is doing. comments should explan why, not how, sometimes maybe it needs to focus on the how if it’s particularly confusing, if theres’s something particularly hard to understand. what if your code made it obvious why it was doing something.</p>\n</blockquote>\n<p>所以<strong>好的</strong>声明式的代码读起来更像是一份文档，甚至是一篇故事，你只有在发现故事无法进行下去的时候才需要去加一些注释。</p>\n<p>所以说了这么多，我们<strong>为什么用函数式编程</strong>呢？一个比较大的原因是因为函数式编程<strong>相对</strong>于其他的编程范式来说要“更加声明式”，读起来更加“自然”。它把代码运行层面的东西都交给了计算机(所以函数式也经常被人吐槽性能问题，比如immutable)，人们可以把自己的精力放在代码的逻辑和维护上面来，用人话说就是，可读性相对更强。</p>\n<h2 id=\"可读性\"><a href=\"#可读性\" class=\"headerlink\" title=\"可读性\"></a>可读性</h2><p>这个时候一定会有人吐槽：兄嘚，别忽悠了，我们组张三在组里推函数式，他那代码，我打包票，三天后他自己都看不懂。</p>\n<p>兄弟，别急，坐下来喝口水，我们继续来看看这张图：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/readability-for-FP.png\" alt=\"readability-for-FP\"></p>\n<p>这张图我们假设一个人是从命令式转到声明式来的，横轴是转换过程中所处的阶段，纵轴是这个人所写代码的可读性。然后我们来解读一下这张图：</p>\n<p>首先在0点位置，作为程序员我们假设大家写的代码都是有一定的可读性的，这个时候他想把自己的代码风格转换成声明式的，于是他的代码会有一段时间的可读性增长。就像是你在JS里第一次接触了foreach、map、reduce一样，你会开始逐渐抛弃for循环。记得刚进公司的时候我跟同事探讨过这个问题，为什么你不喜欢for循环了？得到的答复基本上是一致的，这些原生提供的方法写起来“更舒服”，读起来也更容易理解代码在做什么。虽然这些方法不算是函数式，但是也已经向声明式进了一步了。</p>\n<p>这个时候你一般会觉得很酷，想把更多的东西写成声明式的，然后噩梦就开始了，你的代码开始不可控。为啥呢？因为你想要吧自己的代码“变成”函数式的，但是函数式对你来说算是一种没有接触过的编程范式，你为了能够把自己的代码“套进”函数式的原则里，开始大量牺牲可读性，并且沾沾自喜，我会写函数式的代码了~然后同事开始质疑你写的这是啥，自己也发现渐渐看不懂自己的代码了，说好的可读性更强呢？明明是更烂了。</p>\n<p>于是有一大批人在这个节点放弃了，并且加入了吐槽的大军中去，函数式可读性高？高个P，写出来的全是意大利<del>炮</del>面条。另外一部分人坚持下去了，并且开始逐渐理解函数式，在加强的函数式的各种理解后，代码的可读性终于在谷底反弹，并渐渐超越了过去的自己。</p>\n<p>小黄书的作者Kyle用了3年让自己成为了一个函数式的工程师，他说自己在这中间也想过要放弃，在中间位置的部分比你想象的还要糟糕，所以如果你也想要尝试，那么请不要放弃，这不是一朝一夕能够改变的。</p>\n","categories":["技术细节"],"tags":["FP","函数式编程"]},{"title":"Webpack原理(1) — Why Webpack","url":"https://teobler.com/20190308-why-webpack.html","content":"<p>最近稍微打败了一点自己的懒癌，刚好工作上的压力没有那么大了，有时间能够看看前端的东西了。看了一部分webpack相关的东西，自己记录一下。这一篇主要介绍下webpack的历史以及我们为什么要使用webpack，当然，只能从我的角度力争保持不“篡改”历史，要是有不对的地方希望的指出。</p>\n<h2 id=\"我们怎么使用JS\"><a href=\"#我们怎么使用JS\" class=\"headerlink\" title=\"我们怎么使用JS\"></a>我们怎么使用JS</h2><p>众所周知，我们在HTML文件中使用JavaScript只能通过<code>script</code>标签来引入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果只是这样用，<strong>有什么问题呢</strong>？这样引入JavaScript是没办法大量引入的，什么算大量呢？也不用多，加入某个页面我需要20个JavaScript文件，怎么办？好像我只能加20个<code>script</code>标签，然后一个一个去请求。但是这样的话首先会使页面加载变慢，你需要在加载页面后去请求大量的script，更为重要的是，浏览器是有请求限制的：</p>\n<p>浏览器只允许一定数量的请求能够 ‘fetch data’，所以如果在同一时刻发起大量的请求的话，对于浏览器来说会有相当严重的性能问题。可能有人会说，9102年了，我用HTTP/2啊，没问题。是，对于大部分情况来说的确没有问题了，name对于特殊情况呢？比如Airbnb和MS的outlook，他们用超过3000个modules去进行构建。</p>\n<p>咋办呢？那我<strong>把所有需要的JavaScript代码写到同一个文件里</strong>就好了嘛，是的，历史就是这么发展的，所以老程序员们可能都见到过那种一万十万行的巨大的JavaScript文件。这种办法的确缓解了上述问题，可是，这样的文件，我还需要讲缺点嘛？不说别的，假如我用到的某个function有问题，我想debug一下，咋整呢？闹呢？<strong>我在第一行定义了一个变量，我要去第一万行找它，然后这他么还是一个全局变量，咋玩呢？</strong></p>\n<p>然后呢，万能的前端同学们想到了一个办法 — IIFE 啥是IIFE呢 — immediately invoked function expression，中文是立即执行函数，它可以干啥用呢：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outerScope = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> whatever = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dataWillUsedInside</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> outerScope = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        someAttribute: <span class=\"string\">'youWantThis'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outerScope);</span><br></pre></td></tr></table></figure>\n<p>这下游戏规则好像变简单了一点了，我们可以自己写很多JS文件，然后把它们封装成一个个的IIFE，然后封装到一个文件里面，好了，解决了一个问题，至少变量污染的问题解决了嘛。然后呢，开始进入工具时代了，这个时候大家开始寻找各种各样的工具 — make, grunt, gulp, broccoli…</p>\n<p><strong>那么新的问题又来了</strong> — 如果我想修改下某个文件，然后呢，我需要编译所有的文件，包括那些我都没有动过的。第二个问题是，比如我想引某个库，按需引用？不存在的，我只能一坨的引进来，这就有点可怕了，尤其还是以当时的网络状况来看。而且说不定你还需要引好多个库呢，那也只能全部放进来。而且这样编写成IIFE的“文件”由于各种原因会导致你的网页加载很慢。</p>\n<h2 id=\"JS的模块化\"><a href=\"#JS的模块化\" class=\"headerlink\" title=\"JS的模块化\"></a>JS的模块化</h2><p>所以这个时候前端的同学们又开始想办法了，我们得有<strong>模块化</strong>这个东西呀。Node其实就是把V8“拿”到了server端，那么问题来了，没有了browser，没有了DOM，我们还怎么使用JS？所以Node.JS的出现带来了模块化，带来了CommonJS。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [add, subtract] = <span class=\"built_in\">require</span>(<span class=\"string\">''</span>./math<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/*</span></span><br><span class=\"line\"><span class=\"string\"> * math.js (has two named exports [add, subtract])</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\">const divideFn = require('</span>./division<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">exports.add = (first, second) =&gt; first + second;</span></span><br><span class=\"line\"><span class=\"string\">exports.subtract = (first, second) =&gt; first - second;</span></span><br><span class=\"line\"><span class=\"string\">exports.divide = divideFn;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">/*</span></span><br><span class=\"line\"><span class=\"string\"> * dibision.js (has a exports '</span>divide<span class=\"string\">')</span></span><br><span class=\"line\"><span class=\"string\"> */</span></span><br><span class=\"line\"><span class=\"string\">module.exports = (first, second) =&gt; first / second;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码是一个简单的CommonJS的例子，有三个文件，他们可以通过使用<code>require</code>相互引用。你可以使用匿名的默认exports，也可以使用具名的导出。之后再在别的文件内以特定的语法导入。所以到现在我们就解决了作用域的问题，我们不再需要IFFE了，这个时候我们不用再担心变量污染的问题了，同时也解决了IFFE的缺点。而同时出现的NPM更是让各个开发者自己写的各种包能够让每一个人使用。</p>\n<p>可是还有问题，这玩意儿是Node的，<strong>不支持浏览器</strong>。而且如果你是一个写过别的语言的程序员的话你也应该知道动态绑定，但是CommonJS并<strong>不支持动态绑定</strong>。于是自我引用和循环引用层出不穷。而且他的<strong>同步算法贼慢</strong>。又为了解决这些问题，出现了一些有意思的东西：browserify, requireJS, systemJS…这些工具的目的很简单，就是让你能够在浏览器里面使用CommonJS。但是它们并<strong>不支持静态引入</strong>，也就是说你要用某个库你还是只能全部引进来。而且也并不是所有人在写库的时候都会使用CommonJS，毕竟还有个AMD不是吗。所以可以说这套玩意儿不能算是’module system’。</p>\n<p>于是<strong>ES Module</strong>出现了。据说与之相关的文档，在1998年就能看到，所以这是一个断断续续设计并开发了大概10多20年的玩意儿，不过他的语法更友好了些，至少不是一些<code>require</code>之类的让人看到一头雾水的词语了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;uniq, forOf, bar&#125; <span class=\"keyword\">from</span> <span class=\"string\">'lodash-es'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> utils <span class=\"keyword\">from</span> <span class=\"string\">'utils'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> uniqConst = uniq([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br></pre></td></tr></table></figure>\n<p>现在看起来我们好像有了一个完整的module system了，重用，封装这些基本特性看起来都还不错。但是呢？<strong>几个问题又来了</strong>：这玩意儿好像挺难使用在Node里面的 — 这也是现在好多团队正在努力的方向；而且它直接在浏览器里面使用的话 — 非常非常慢，慢到你以为网站挂了，而且不用多，10个modules就能达到这个效果。因为在浏览器从上到下读取这个JS文件的时候，首先遇到<code>import</code>，然后去找这个包在哪，找到相应的路径，然后验证一下这些东西还能不能用，最后把这个文件读进来，然后继续在这个文件里重复这个步骤 — 一直到所有的依赖都读完了。需要注意的是，这一切都是在<code>runtime</code>完成的，也就是在加载你的网页的时候。</p>\n<h2 id=\"webpack横空出世\"><a href=\"#webpack横空出世\" class=\"headerlink\" title=\"webpack横空出世\"></a>webpack横空出世</h2><p>之前我们提到过，一个NPM中的包可能是用的不同的module format，你不能说哪一种是不对的不能使用的，所以在面对不同的方法的时候你也需要使用不同的使用方法。而且需要说明的是，上面我们说的所有东西都只是关于JS的，别忘了一个web app还有CSS还有各种静态资源。我们需要的是一个支持所有module format，并且同时还能支持除了JS以外的别的文件的一个“系统”或者说工具。</p>\n<p>webpack是什么？ </p>\n<blockquote>\n<p>webpack is a module bundler lets you write any module format(mixed also), compiles then for the browser. And it supports static async bundling.</p>\n</blockquote>\n<p>很简单有很强大的定义对吧，它几乎解决了上面所有的问题，那么它是怎么被创造出来的呢？这是一个有意思的小故事。</p>\n<p>2012年，一个叫做Tobias的，在Newberg(美国一个城市)读master的德国人要写一片学位论文。他之前是写c#的，从来没有写过一个web界面。他在一些特定的场景需要用到Google Web Toolkit中的一个叫做code splitting的功能。而在他的论文中他需要写一个web app，他就想找一个包含这个功能的库来用。他找到的这个库叫webmake，这也是一个bundler。但是却没有code splitting这个功能，于是他提了一个<a href=\"https://github.com/medikoo/modules-webmake/issues/7\" target=\"_blank\" rel=\"noopener\">issue</a>，并且写了一堆如何实现这个功能的代码，希望维护者能够加入这个功能。在一番讨论过后维护者拒绝了他，于是在经过同意之后，他把这个库fork到了了过去并自己加上了这个功能，给新的库取名为webpack。</p>\n<p>2014年，Dan Abramov在Stack Overflow上提了一个关于<a href=\"https://stackoverflow.com/questions/24581873/what-exactly-is-hot-module-replacement-in-webpack\" target=\"_blank\" rel=\"noopener\">hot module replacement</a>的问题，Tobias用很大的篇幅给他介绍了这个还在开发的功能，详细解释了这个功能怎么在webpack里工作的，以及这个功能有多棒，你可以不用刷新浏览器了！</p>\n<p>2015年，这时在Instagram工作的Pete Hunt通过一次演讲告诉了世界他们是如何使用webpack打包发布他们的react app的。然后你懂得，webpack就火了。像Facebook这样的公司也开始使用webpack了。但是其实Tobias只是每周大概花5 6个小时在webpack中。</p>\n<p>是的，在这两个讨论中，webpack彻底火了，走向了世界。</p>\n<p>中国有句话叫做“以史为鉴，可以知兴替”。在了解这些历史的时候除了觉得很有意思，也会有一些思考：在历史的大潮里，有多少人是可以做那个改变方向的人？又有多少人死在了历史的长河里？要想不被淹死，只有奋力向上。</p>\n<p>下篇开始正式进入webpack，至于啥时候写，看我啥时候不懒吧。</p>\n","categories":["技术"],"tags":["webpack"]},{"title":"碎碎念","url":"https://teobler.com/20190219-new-journey.html","content":"<p>离开学校生活到成都工作半年多了，趁着春节，请了一个星期年假，放松自己的同时陪陪老妈，闲来无事打开荒废良久的博客，发现已经鸽了好久了，打算还是捡起来，记记笔记，写写琐事。</p>\n<p>为了调休早点回家过年，连续上两个星期十二天的班还是很酸爽的。回家这件事，心情挺复杂的，毕竟回家后需要面对一些我不想面对的人和事，妈妈和奶奶大概是我想要回家的唯一的理由了吧。想起这些，挺替我爸不值的，一辈子都在帮亲戚，大到生意人际，小到做B超这种破事，最后落得孤独一人，“我们谁都不欠他”，“我们也有自己的苦衷”，唯一能感受到的也就只有奶奶的爱了，果然妈妈的爱是永远都不会变质的。</p>\n<p>10月到西安与曾老师一聚，相谈甚欢。学业有成的曾老师表示可能马上就脱单了，那我心里想的就只有红包了。后来听他谈起与父亲的各种趣事与谈话，竟然差点忍不住自己的眼泪。也是，二十多岁的年纪，正有了自己懵懂的思想，急于在自己心目中高大的父亲面前证明自己，交流交流见解。我也畅想过是不是有机会在家中的院子里沏一壶热茶，甚至热一碗热酒，父子两交流交流男人之间的话题。告诉他我为什么想要离开他为我打造好根基的家乡，听听他这些年的坎坷，不时炫耀一下自己那些不大不小的成就。</p>\n<p>我是一个完全不会或者说懒社交的人，我几乎不会主动去联系谁，所以理所当然的也不会有人联系我了。不过还好有个了解我的灰灰，也是一件很庆幸的事情了。陆陆续续了解到当年很久没有联系的朋友同学们的近况：大部分人进了各个市区县城的烟厂，或者是考上了公务员，领着一份相当不错的薪水，过着远比我轻松的生活，吃住工作都会有家里人照应。也有人在准备着各种考试，为了谋求一份好工作。也有一位老友在二战，不知道是不是为了心中的梦想，祝你今年远远出线吧。当然，灰灰也要加油呀，祝你如愿以偿去大理，么么哒(口区)！</p>\n<p>想着大家不差甚至相当不错的生活我在想我当初是不是错了，我是不是也应该听家里的，留下来。在家里呆了快两个星期后，在几个翻来覆去的夜里，我想明白了，我没错。这座小城，我太熟悉了，以致于我不知道应该去哪里才能娱乐，几天后我甚至找不到一个让我觉得好吃的小店了，因为我想吃的已经又吃遍了。还有人说不知道拿这么多工资该花到哪里去。我也想过有周末呀，我可以开车去别的地方，回头再一想，我真的会有精力嘛？</p>\n<p>或许把妈妈“扔”在这的确不妥，出去也的确受苦受累。但是真正让我出去的，可能是我不想过一眼能够看到头的人生，我也不想在一些人如鱼得水的编制内阿谀奉承，人生是我自己的，我想出去走走，我在这里已经生活了18年了，够久了，我想认识更多更棒更有趣的人，到处走走可能是我这辈子一直没有变过的”理想”了。从TWU回来，再见证了去西班牙transfer的同事，后又听闻去澳洲出差归来同事的趣事，这颗种子早已茁壮成长。可能从出生那刻我就是一个自私自利的人吧。</p>\n<p>一直都很庆幸以我这样的歪把子以各种机缘巧合歪打正着进了TW，不出意外的头上挂了一个大大的risk(虽然到现在我也没弄清楚这个risk的原因，大概是面试的时候不行吧)。</p>\n<p>我是带着紧张激动各种复杂的心情到骚窝报道的，可喜的是迎接我们的是应届生培训，至少以后在公司里能有一群能约饭的小伙伴了，一个月的培训很是充(xin)实(lei)，紧张的培训安排能让你快速从学生状态转换到工程师状态。至今记得林老师说:”我们布置的作业做到一点就行了，不然影响我们第二天上课。”幸运又不幸的是，第二周我就被越姐”带”走了。幸运是因为在组里的这两个月是我成长最快的两个月，不幸是因为我没能上完我想要上完的培训课。</p>\n<p>在这里是我成长最快的两个月，用蹩脚的英语跟客户站会，每天的codereview有三个大佬盯着我一行一行过代码。每天上午没有一分钟可以做卡，全都用来改昨天下午codereview的问题。这样的情况持续了一个月，我慢慢可以在10点、11点前改完codereview的问题了，也可以大概听懂客户说的啥了，也能说清楚自己的想法了。可以说一路磕磕绊绊渐渐从一个不会工作的小学生成长为一个差不多能出活的工程师。所以虽然没能上完应届生培训，但是也很庆幸遇上了一个自称有毒的组，带上了中毒的我，成为了一个有毒的骚客(这段有毒)。</p>\n<p>之后压着“项目要结束”的点去了西安TWU，这又是另外一段有趣的旅程了。对于我这种英语辣鸡的人来说压力是真的大，啥都听不懂，晚上回去打开agenda，勉强看懂，然后就是无尽的作业和任务活动，还有噩梦般的phechakucha，完全就是要我命了。不过你如果问我想不想再去一次，那我只能回答真香了。这种全世界的同学在一起工作讨论生活的经历，可能一辈子就只有一次了。</p>\n<p>回成都后不太想出差的我进了太阳写Java，恰逢组里transfer —— 组里本来就只有艳姐跟老刘，他们要去新的组，我跟王总换上去。这又是一个全新的挑战，之前工作是处于一种被保护的状态 —— 站会遇到问题抬头，总会有人帮我接下来；遇到坑了，到处找找，找不到吼一声，大家就会说你这样这样试试看看，然后基本就解决了；做完了就去要卡，kick off一下接着做。两个人的组(特别是两个前端来写Java的组)你需要自己面对很多事情，业务逻辑你需要自己理清楚，遇到坑了慢慢爬，会自己找事情做，学会独立面对客户。还好王总比我厉害太多，难题都被王总hold住了，还经常带着我理业务逻辑，填坑，科普知识。就像在一条荆棘丛生的小路上有人给你在前面开路，你只要小心处理剩下的枝丫就好了。当然还要感谢老刘和艳姐把我从零基础带入Java和devops。</p>\n<p>刚进组的时候懒过一段时间，希望自己重新立起flag，在接下来的工作中好好加油。</p>\n<p>实习的时候moma说，一个人经不起几个折腾；还有人说，你还是太年轻，幼稚，不成熟。自私甚至恶心一点说，正因为我年轻，我还有大把时间，退一万步来说，在外面我废了，回到那个小城，找一份能让我吃饱的工作，我的下半生依然不会太差。啥？生娃？能吃吗？韭菜吗？</p>\n<p>感谢所有我遇到的和给我帮助的人们，感谢愿意一直陪着我的牙牙。</p>\n<p>2019也要加油呀，过去的都过去了，给大家拜个晚年~</p>\n","categories":["随笔"],"tags":["总结"]},{"title":"TW之旅","url":"https://teobler.com/20180929-first-in-tw.html","content":"<p>一切的开始源于一份“天龙八部”，拿到自己之前计划攒钱买的mac。</p>\n<h2 id=\"新手村\"><a href=\"#新手村\" class=\"headerlink\" title=\"新手村\"></a>新手村</h2><p>没能跟完入职后培训算是进入TW的第一个小小的遗憾，虽然可能以后回过头来看并没有什么，但是对于我这样自认为基础不太牢靠的人来说一次系统的训练可能能给我带来不少好处。</p>\n<p>在培训中得到的第一个就是压力，在之前入职前线上培训的一周作业，现在是一天的量，按照林老师的话来说是“一点钟做不完就睡觉吧，不然第二天没精神上课”，于是我就成了那批1点左右睡觉做不完作业的人。现在想来，基础不牢是一回事，效率低下也有关系，总结起来主观因素占绝大部分—— 菜是原罪。</p>\n<p>第二点就是公司文化与日常。“在敏捷实践方面，公司在世界范围内是能够处于金字塔顶端引领行业潮流的”。初次听这句话说实话我抱怀疑态度，随着进入项目组，结合之前实习的经验还有同学们的聊天来看，此话不假。大多数公司想要制定敏捷规范，而在TW敏捷已经成了日常，在项目中的一切实践都有敏捷的影子—— 从公司布局，到工位位置；从日常站会，到每天的codereview；再从卡墙，到项目管理；代码规范，到项目部署，敏捷无处不在。</p>\n<p>第三点是学习方法和实践。授人以鱼不如授人以渔，如何学习永远是在学习中摆在重要位置的。思维可视化，以教代学，session，tasking，timebox，PDCA，富兰克林写作法，刻意练习，概念图等等方法。虽然在后面的工作中并没有全部用到，但是这些方法如果运用得当肯定能够在以后的学习中发挥很大的作用。</p>\n<h2 id=\"等级不够半路出村\"><a href=\"#等级不够半路出村\" class=\"headerlink\" title=\"等级不够半路出村\"></a>等级不够半路出村</h2><p>回头一想其实还觉得又有点小幸运，在一个恰好的时间，进入了一个恰好的项目组，遇到了一群（哪里有一群）恰好的人。组里的技术栈恰好是自己想要发展的方向，虽然可能工作的时间并不很长，自己的技术深度也并没有那么深，深层的技术问题自己无能为力，但是自己总是有进步的，也能为组里带来一些微小的贡献。</p>\n<h2 id=\"新手任务\"><a href=\"#新手任务\" class=\"headerlink\" title=\"新手任务\"></a>新手任务</h2><p>第一张卡第一个task是一个巨简单的proxy api，大概就是简单的将前端的query params format以后发送请求到AS24API，拿到response之后再发回给前端。怎奈从来没有接触过后端的我首先是看不懂代码，其次是逻辑稍显混乱，一个简单的api在有各种提示的pair中做了整整一个下午。半路也是磕磕绊绊，写出来的代码也几乎都是之前现成的代码换了个样子。</p>\n<p>仔细思考，其实这张卡对我挺重要的，首先这是我的第一张卡，虽然并没有独立完成，甚至说只是将核心问题串联了起来，但是其中暴露了我比较多的问题。首先是自己之前瞎点技能点，虽然什么都会一点，但是就真的是一点。技术栈是符合项目的技术栈，但是深度远远不够。举例来说就是react我会吗，会，但仅仅是会，遇到问题我需要花大量时间查阅文档，各种论坛，最后可能还需要就具体问题请教组里的人。不夸张的说，要是一直维持这个样子，我只会是组里的拖油瓶。不过还好，刚出新手村时，系统派了一位认领我的师父，虽然师父之前不是与我同门同派，但是转到我派时日也不短，给我在前行的路上许多帮助。</p>\n<p>任务在师父帮助下勉强完成，任务难度低，收获经验多，走出新手村第一步。</p>\n<h2 id=\"打怪升级\"><a href=\"#打怪升级\" class=\"headerlink\" title=\"打怪升级\"></a>打怪升级</h2><p>后来的卡都是关于静态页面的，倒也不难，但是对于当时的我来说，还是有些难度，前端问题倒还好，虽然还是会出现代码风格、算法、非最佳实践等等的各种问题，但是兜兜转转在指引下还是能够完成。这些卡更多的可能还是让我了解了后端的基本原理，换句话说算是让我对node的后端有了一个基本的了解，至少能够看得懂代码在干嘛。虽然这只是一层bff，大概真正的后端代码的数据处理还有与数据库的交互会复杂得多，但是总是让我从一个纯前端dev一只脚跨入了后端的大门。</p>\n<p>这些卡让我提升的方面比较广，算是让我能够理解或者是跟得上大家工作的节奏。做完这部分卡后我能够明白和体会一整个工作的流程。往大了说，从写卡、开卡、工作、测试、sign off，其中还有关跟客户的沟通交流，寻求技术支持等等，到日常的站会，组内合作；往小了说，对代码的阅读，组件的复用，代码的组织结构，到对整个项目的理解都有了从零到一的进步，算是迈出了自己重要的一步。</p>\n<p>任务在大家的帮助下顺利完成，任务难度适中，收获大量经验，成为合格新人一枚。</p>\n<h2 id=\"野外生存第一课\"><a href=\"#野外生存第一课\" class=\"headerlink\" title=\"野外生存第一课\"></a>野外生存第一课</h2><p>第一张算是我独立完成卡应该是在tulip和glacer的搜索条件中添加一个新的字段，与之前的卡相同，难度并不大。但是这张卡特殊在是添加一个全新的字段，需要对taxonomy进行更新，然后在后端api添加新的字段，之后在前端添加相关的view界面，也就是说，这张卡需要对整个项目理一条清晰的线出来，如果做一步想一步，如果不是对整个项目结构比较熟悉的话，会举步维艰。虽然过程中也是出了许多问题，寻求了组内大家的很多帮助，但总算是独立完成的第一步。</p>\n<p>这张卡让我明白了计划或者说是task的重要性，写代码与做很多事情其实是一个道理，需要有一个比较合理的计划，虽然每一步的task我没能保证严格在20分钟左右，但是相比直接上手而言阻碍会小的多。不过这还是只刚刚掌握了task的第一步，其中有许多事情还是没有考虑周全，tasking混乱，导致其中走了许多弯路。</p>\n<p>在寻求帮助中完成任务，难度适中，获得新技能tasking。</p>\n<h2 id=\"精英怪\"><a href=\"#精英怪\" class=\"headerlink\" title=\"精英怪\"></a>精英怪</h2><p>后面的卡进入了orithyia，前面的XMLserver还好，可以说是对数据的format，难度不大。后面的难度来自于新站的car detail页面。客观来讲，是因为整个页面从“零”开始，自己第一次面对这样的卡，有些无所适从。主观来说，是因为自己的tasking并没有做好，做页面时陷入了无关紧要的细节，卡住了大量的时间，时间消耗远远超过预期。后来还是因为大家及时点醒自己，提了很多关键性的建议，才让自己从新着手于整体框架的搭建，最后再重新回来实现细节。最后一步步完善功能和页面。</p>\n<p>这一张卡让自己更加认识到了tasking的重要性，一个合理的task能够让工作事半功倍，而一个失败的task却又会让工作事倍功半，往往出力不讨好。往往越复杂的功能越需要在开始前做好tasking，否则如果没有强大的技术能力支撑，将很难实现。</p>\n<p>艰难完成任务，难度略大，技能tasking等级提升。</p>\n<h2 id=\"新征程\"><a href=\"#新征程\" class=\"headerlink\" title=\"新征程\"></a>新征程</h2><p>还有不久就要前往TWU了，在项目上的两个月对自己来说提升很大，不仅仅是技术上，更多的其实是工作的方式方法，解决问题的办法，与客户的沟通交流。能够切身的感受到，自己与刚上项目时完全不同，那时的自己可以说是什么都不懂，现在至少可以算是一个入门级工程师了—— 起码能干杂活了不是。</p>\n<p>努力前行，未来可期。</p>\n","categories":["职业"],"tags":["总结"]},{"title":"实习总结","url":"https://teobler.com/20180201-internship-summary.html","content":"<p>去年10月开始了在成都一个月的校招之旅，最终在11月加入了yh，开始了为期两个月的实习。如方方所说，一般初创级别的公司给不了你太好的成长环境，所有的提升都需要你去主动自学，主动发问，主动提升，幸运的是遇到了一位非常热心的同事 victor ，帮我解决了非常多工作上的困难。还有一位非常棒的leader moma ，教给了我一些可能你要工作好几年才能悟出来的道理，在这里对他们非常感谢。</p>\n<h2 id=\"氛围\"><a href=\"#氛围\" class=\"headerlink\" title=\"氛围\"></a>氛围</h2><p>首先来说公司的氛围，可能是成都分公司的原因，公司的氛围让我出乎意料的觉得轻松，与想象中的严肃认真完全不一样。大家工作时该认真认真，工作之余也能开各种小玩笑活跃气氛，整个工作氛围很轻松活跃，工作进度也能按时跟上。</p>\n<p>至于公司的技术氛围，不能说是浓厚，但也绝对不淡薄。工作中没有解决的问题，会被延伸到饭桌上，路上。对于我这样一个刚毕业的小海绵来说，还是能收益不少的。但是由于组里大多数人都是后端程序员，所以在前端问题的讨论上就不是很深入，作为一个前端入门的我来说，居然能解决大家的一些问题是让我始料未及的，我没有为我能解决大家的问题而感到高兴，反而觉得组里的前端技术不是很深入的样子，毕竟这些问题是一些很基础的问题，这也是让我心里有点膈应的地方。</p>\n<p>自己是一个不善言辞的人，所以有的时候会感觉融入不到大家的讨论之中，虽然这是我一直在努力改变的问题，但是至今没有令我满意，希望以后我也能成为那个能够创造技术氛围而不是努力融入的那一个人。</p>\n<h2 id=\"我遇到与解决的一些问题\"><a href=\"#我遇到与解决的一些问题\" class=\"headerlink\" title=\"我遇到与解决的一些问题\"></a>我遇到与解决的一些问题</h2><ol>\n<li><p>在公司大部分人是后端程序员，但是现在在写前端，而我是一个纯前端，当有一个任务需要我和后端进行配合时，会出现一个问题，他也懂前端，但是思路跟我的不一定一样，就会对我造成干扰，思路混乱，同时他能把控前后端。所以在有类似任务出现时，需要定下一个前后端交互的规范，最好有文档，后端不想写，我可以写，大致内容如下：</p>\n<ul>\n<li>交互方式，在公司的话大概就是，是使用ajax还是firereq？reqid是多少？idx是多少？约定url是多少？交互方式是get还是post还是别的？</li>\n<li>数据交互是json还是啥？字段名称是啥？我要从哪去取</li>\n<li>一定要在开发前做好约定，写出文档，可以极大提升开发效率</li>\n</ul>\n</li>\n<li><p>父组件更新state，传递新属性进入子组件，更新props，生命周期函数刷新，换句话说，这是父子组件通信问题</p>\n<p>该问题发生于父组件将state作为子组件的props传入子组件，此时子组件再将此props赋值给子组件的state，之后再子组件中执行一个父组件传入的setState回调，但是此时本应该重新渲染的子组件却没有重新渲染，原因很简单，你并没有重新渲染子组件，只是更新了父组件。解决办法也很简单，我们不将这个值设置成子组件的state就好，在改变时调用一个父组件传递的回调函数来控制父组件的状态，从而从新渲染父组件，更新子组件。<br>这个错误也让我重新审视自己之前随便糊弄看了看的react生命周期问题，算是进入公司后对自己不扎实的react基础问题的一次小小的警示吧。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000006792687\" target=\"_blank\" rel=\"noopener\">React组件生命周期</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006792687\" target=\"_blank\" rel=\"noopener\">react接收到新的props时，怎么重新渲染</a></li>\n<li><a href=\"http://react-china.org/t/react/1740\" target=\"_blank\" rel=\"noopener\">React组件生命周期过程说明</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28591538\" target=\"_blank\" rel=\"noopener\">React父子组件之间的通信问题</a></li>\n</ul>\n</li>\n<li><p>setState异步怎么拿到实时更新的数据，刷新dom的机制到底是什么，前后相同还会刷新吗</p>\n<ul>\n<li>要拿到更新后的state，可以在setState函数中传入第二个回调函数，该函数在setState结束后进行调用，就能拿到更新后的state</li>\n<li>setState执行后，默认情况下（shouldComponentUpdate默认返回true），一定会重新渲染视图，无论state状态更新与否</li>\n</ul>\n</li>\n<li><p>注意创造健壮的代码，生产环境不像自己随便玩小项目一样，应该让代码拥有足够的健壮性，如果一份代码能被自己轻易搞崩，那么就是及其不合格的代码，换言之，我们在写代码的时候需要做异常处理，即考虑特殊情况，例如</p>\n<ul>\n<li>发送请求接收参数时，参数为空咋办？</li>\n<li>发送请求时，用户不当操作参数为空咋办？</li>\n<li>用户输入时前端简单的校验问题</li>\n</ul>\n<p>程序要能正确抛出错误而不是莫名其妙崩溃是最基本的要求</p>\n</li>\n<li><p>图片上传问题</p>\n<p>图片上传问题算是一个古老的前端问题了，发展到现在已经有了很多成熟的解决方案，公司内前后端交互是公司内自己封装了一个ajax，然后使用这个封装后的ajax。所以在解决这个问题时，我用了input（type=”file”），之后将其dom隐藏，用了另外一个自己写的dom结构达到美化和同一的目的。然后new了一个FormData对象，再将该对象用ajax发送到了后台。</p>\n</li>\n<li><p>剩下的问题基本都是一些通病了，大概问题在于各个对象的方法使用不够熟练，像是调用数组方法来处理诸如：删除数组中符合条件的元素；删除指定index的元素；元素换位；一个数组是否包含另外一个数组中的元素等等之类的问题</p>\n</li>\n</ol>\n<p>当然，由于自己略微有点懒，一些问题没有及时记录下来，导致现在忘得都差不多了，就没能记录下来，这个问题就比较大了，以后改正。</p>\n<h2 id=\"我学到的\"><a href=\"#我学到的\" class=\"headerlink\" title=\"我学到的\"></a>我学到的</h2><p>leader时常会在工作中或者周会上与我们分享他作为一位老程序员得到的一些职场经验，作为一个还没有真正进入职场的半学生来说，有些问题真的是收益匪浅，遗憾的是没有能够全部记录下来</p>\n<h3 id=\"尝试站在你的上司角度提出和解决问题\"><a href=\"#尝试站在你的上司角度提出和解决问题\" class=\"headerlink\" title=\"尝试站在你的上司角度提出和解决问题\"></a>尝试站在你的上司角度提出和解决问题</h3><p>作为一名企业员工，多多站在管理层来考虑和解决问题，做这些事情所得到的收益一般情况下都是你远远想不到的，像是与其他员工增进感情，提升自己在公司的地位，提升自己的技能，扩展自己的技能树等等。想象这样一个场景，公司后端同事在接触前端开发，举步维艰，然后你作为资深前端，写了个贴合公司业务逻辑的前端框架给他们使用，解决了他们的问题，也提升了公司的效率，同时你自己也获益良多。</p>\n<h3 id=\"自动化流程\"><a href=\"#自动化流程\" class=\"headerlink\" title=\"自动化流程\"></a>自动化流程</h3><p>工作中一些繁琐却又简单，毫无技术含量的工作，赶紧想办法将它们自动化吧，不然浪费的是你自己的时间和精力，这些节省下来的时间和精力，可以让你做很多事情了。如果不能自动化，叫上产品和其他开发的同事，有没有办法能够最大化的简化流程呢？办法总比问题多。</p>\n<h3 id=\"做一个owner而不是worker\"><a href=\"#做一个owner而不是worker\" class=\"headerlink\" title=\"做一个owner而不是worker\"></a>做一个owner而不是worker</h3><p>我们组负责的架构是那一部分，我能负责哪一部分。主动担起自己的责任，主动负责一项内容，当一涉及到某个领域，同事们首先想到的就是来寻求你的帮助，虽然你自己还有点繁琐，但是你在公司里的地位肯定会有所不同。当然了，千万不要主动承担一些毫无水平，毫无难度的领域，得不偿失。这是你走在“成为公司重要的人”的路上的第一步。</p>\n<h3 id=\"严于律己\"><a href=\"#严于律己\" class=\"headerlink\" title=\"严于律己\"></a>严于律己</h3><p>说实话写逻辑代码很简单，随便找个人来写都能写出来，可是一份能跑的代码和一份优美而快速的代码显然是不一样的。写完这部分代码，有没有优化的余地？有没有垃圾代码不需要？那么下一次写出来的代码能不能比这一次好呢？多多坚持，你自己的改变，你自己能看出来的。</p>\n<h3 id=\"就差一点\"><a href=\"#就差一点\" class=\"headerlink\" title=\"就差一点\"></a>就差一点</h3><p>其实每一件工作你做80-90%就可以交工了，也看不出什么大问题，但是最后这一点真的那么难吗？其实最后这一点可能是最重要的，它们大部分时候看起来可有可无，但是却有着锦上添花的作用，补上去这10%，有意想不到的好处。（例子我是真的想不起来了，但是在工作中大家可以细细体会，会理解的  =。=）</p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p>yh是一家很不错的公司，特别在投入了tx的阵营之后，我是看好yh以后的发展的，但是yh作为一家自称为创业期的公司来说，对于我的提升和提升速度都太慢了，我不知道自己的自制力能够坚持多久，我需要入职的前两年给我大的提升，趁我还是一个能吸水的海绵，我想多吸水，感谢yh带给我的，也感谢各个同事给我的帮助</p>\n<p>江湖有缘再见~</p>\n","categories":["职业"],"tags":["总结","实习"]},{"title":"flex布局整理","url":"https://teobler.com/20171124-flex-grammar.html","content":"<p>flex 布局是 CSS3 中提出的一个能够简便、完整、响应式地实现各种页面布局的解决方案，之前在学习 CSS 的时候也有过对flex布局的接触，但是考虑到兼容性问题，并没有广泛使用 flex 布局，来到公司实习，发现公司不用考虑兼容性问题，在线同事们会“建议”客户使用 chrome 或者 firefox。简直美滋滋，赶紧花了一个下午复习了下 flex 布局，然后凭着记忆写了下基本语法以及作用，趁热整理出来，算是以后查询有个地方，配合 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">阮大的教程（1）</a>、<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">阮大的教程（2）</a> 食用更佳。</p>\n<h2 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container\"></a>container</h2><ol>\n<li>display: flex | inline-flex</li>\n<li>flex-direction: <strong>row</strong> | row-reverse | column | column-reverse</li>\n<li>flex-warp: <strong>nowarp</strong> | warp | warp-reverse<ul>\n<li>warp-reverse — 换行后第一行在下面，自下往上换行</li>\n</ul>\n</li>\n<li>justify-content: <strong>flex-start</strong> | flex-end | center | space-between | space-around<ul>\n<li>space-between — 两端对齐，即边缘与项目紧贴，然后项目间间隙相等</li>\n<li>space-around — 每个项目两侧间隔相等，所以中间项目间隔是边缘项目与边缘间隔的两倍</li>\n</ul>\n</li>\n<li>align-items: <strong>stretch</strong> | flex-start | flex-end | center | baseline | <ul>\n<li>stretch — 默认值，占满整个容器的高度</li>\n<li>baseline — 项目第一行文字的基线对齐（即文字底部）</li>\n</ul>\n</li>\n<li>align-content: <strong>stretch</strong> | flex-start | flex-end | center | space-between | space-around<ul>\n<li>用于多轴线对齐方式，在flex-warp设置为warp项目换行后就会产生多轴线</li>\n<li>stretch — 多条轴线会在交叉轴上平均分布</li>\n<li>flex-start — 轴线全部在交叉轴起点对齐</li>\n<li>其他属性以此类推</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"item\"><a href=\"#item\" class=\"headerlink\" title=\"item\"></a>item</h2><ol>\n<li>order: [integer]<ul>\n<li>取值为整数，规定了在容器中的排序顺序，值越小的排序越靠前，初始值为0，可以取负值</li>\n</ul>\n</li>\n<li>flex-basis: <strong>auto</strong> | [length or height]<ul>\n<li>定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余的空间。</li>\n<li>当主轴为水平轴时，如果设置了这个属性，那么项目的宽度就会失效，主轴为交叉轴时亦然。</li>\n</ul>\n</li>\n<li>flex-basis需要搭配flex-grow和flex-shrink使用<ul>\n<li>当flex-basis为0%时，则把该项目设置为0尺寸</li>\n<li>当取值为auto时，则根据宽高进行设置，则该值不会纳入剩余空间</li>\n</ul>\n</li>\n<li>flex-grow: [number]<ul>\n<li>该值定义了项目的放大比例，当所有的项目按照flex-basis的值进行排列后如果<strong>还有剩余空间</strong>，那么设置了该值的项目就会进行相应的大小调整。</li>\n<li>初始值为0，即就算存在剩余空间，也不进行放大；如果所有项目的值设为1，则所有项目<strong>等分剩余空间</strong>；如果某个项目此时值为2，则该项目<strong>所占的剩余空间是其他项目的2倍</strong>。</li>\n</ul>\n</li>\n<li>flex-shrink: [number]<ul>\n<li>默认值为1，即如果空间不足，该项目将缩小；如果该值为0，则不缩小。</li>\n</ul>\n</li>\n<li>flex: flex-grow flex-shrink flex-basis<ul>\n<li>flex的默认值是上述三个值的组合，有两个特殊的取值：auto（1 1 auto） none（0 0 auto）<br>默认取值 1 1 0%（有任何值传入时）</li>\n</ul>\n</li>\n</ol>\n<p>同时有许多默认组合(优先赋值flex-grow)：</p>\n<ul>\n<li>当只有一个非负数字时，该值是flex-grow，剩下为1 0%</li>\n<li>当只有一个长度（或高度）或百分比时，该值是flex-basis，剩下为 1 1</li>\n</ul>\n<p>等等等</p>\n<p>同时需要注意在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用</p>\n<p>align-self: <strong>auto</strong> | stretch | flex-start | flex-end | center | baseline</p>\n<p>align-self允许项目设置自己的对齐方式，默认为auto，为继承父亲的align-items。</p>\n<p>该属性所起的作用与align-items相同</p>\n","categories":["技术"],"tags":["CSS"]},{"title":"方应杭前端live","url":"https://teobler.com/20171119-frankfang-zhihu-live.html","content":"<p>总结了下方老师在知乎的live内容，所有图片和资料均来自该live，这篇文章也是大量加入了我自己的主观见解，以我刚刚入职实习的角度来总结的，要听原版请前往知乎搜索live</p>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"实习-gt-基础\"><a href=\"#实习-gt-基础\" class=\"headerlink\" title=\"实习 =&gt; 基础\"></a>实习 =&gt; 基础</h3><p>在实习期间是夯实自己基础，抓紧时间查缺补漏的一个比较好的时机。如果公司是中大型公司，有人带的话，不要放不下面子，多问多交流，能够比自己看书钻研快速掌握一些知识点。同时勇于暴露自己的错误，让同事多多指出，这是只有在实习期间才会不会很是尴尬的交流。</p>\n<p>同时对于应届毕业生，在进入大公司之前需要过面试关，往往更注重你的编程基础，而不是很在意你会什么框架。在基础知识过关的情况下，公司更在意你能否在2个月实习期内快速学会公司技术架构，进行协同开发。</p>\n<p>实习期间最好能够将一些经典的基础书籍能够过一下，正式入职之后，你的时间会更加少。</p>\n<h3 id=\"工作-gt-提升\"><a href=\"#工作-gt-提升\" class=\"headerlink\" title=\"工作 =&gt; 提升\"></a>工作 =&gt; 提升</h3><h4 id=\"小公司的学习\"><a href=\"#小公司的学习\" class=\"headerlink\" title=\"小公司的学习\"></a>小公司的学习</h4><p>在小公司工作的话，需要你主动去汲取知识，而不是被动的等待知识来找你，因为公司规模的限制，可能你接触不了很多比较广且深的知识，这就需要你主动利用业余时间进行学习实践。</p>\n<h4 id=\"side-project\"><a href=\"#side-project\" class=\"headerlink\" title=\"side project\"></a>side project</h4><p>其中有一个比较重要的东西就是side project，用中文来说就是业余项目，用你的业余时间来自己组织一个项目，自己做技术选型。side project的好处有很多：</p>\n<ul>\n<li>技能提升：只有少数情况公司的业务会让你的技能得到提升，大部分时间我们需要自己想办法提升自己的技能</li>\n<li>跳槽时候的加分：业余时间有自己的项目，不管有没有人关注你，这都是你努力提升自己的证明</li>\n<li>新技术：技术选型完全由你自己来决定，可以自由实践你认为最新的最有用的新技术新框架</li>\n</ul>\n<p>####跳槽的建议<br>在我们选择下一家公司跳槽时可以不必只看薪水，如果这家公司能够给你带来一些别样的技能提升的话，可以降低薪资的要求，选择能给你带来的其他方面的提升（比如大部分外企的英语技能的提升，部分公司的远程开发等）</p>\n<p>跳槽面试的时候可以说是社招，面试大概就是</p>\n<ul>\n<li>基础知识</li>\n<li>项目情况和项目知识</li>\n<li>协作情况，例如前后端的协作，与产品设计的沟通等</li>\n</ul>\n<h4 id=\"造轮子\"><a href=\"#造轮子\" class=\"headerlink\" title=\"造轮子\"></a>造轮子</h4><p>工作中还有一个提升自己的方法是造轮子，在初期可以自己做一些轮子自己用，比如一些简单的轮播组件，滚动组件等，这些组件可以缩短你的项目完成时间，在加班的时候进行自己的学习提升。</p>\n<p>有能力了可以维护一些常用组件，给其他人员一起使用，也可以适当的借鉴一些开源的写法，融入到自己维护的组件中，更好的完成工作</p>\n<p>终极目标可以维护自己的内部框架，在项目组或者公司内使用</p>\n<h4 id=\"小领悟\"><a href=\"#小领悟\" class=\"headerlink\" title=\"小领悟\"></a>小领悟</h4><p>工作中不要止步于前端，也不可能止步于前端，所以不要抵触写后端的代码，语言也不必局限，触类旁通，自己的提升才能更快更高</p>\n<p>适当的也可以接触一些测试相关的知识或者是交互设计规则之类，总之一句话，不要只会前端，只会前端的人，肯定会被淘汰</p>\n<h2 id=\"前端的历史\"><a href=\"#前端的历史\" class=\"headerlink\" title=\"前端的历史\"></a>前端的历史</h2><p>为什么要了解历史呢，古人云：以史为镜，可以知兴衰。了解前端的历史，可以让我们了解哪些知识有用，哪些没用，从而能够自己判断出以后哪些知识可能会有前景</p>\n<p><strong>ps.该整理没有严格按照时间顺序</strong></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/frankfang-live-fe-history-1.jpg\" alt=\"\"></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/frankfang-live-fe-history-2.jpg\" alt=\"\"></p>\n<ul>\n<li>远古时期java，C#，php程序员写的table布局，不存在前端的概念</li>\n<li>用户觉得太丑，有了美工（ps + div&amp;css）</li>\n<li>04年4月1号，gmail发布，ajax被发扬光大（微软发明的），js兴起</li>\n<li>后端程序员开始学习js（其中大量java程序员），此时的页面就是后端+js+美工</li>\n<li>乔布斯推广用户体验，推广拟物化，之前的前端没有用户体验可言，此时需要复杂的js，后端不想写，有人开始专门学习js，前端兴起，此时网页=（前端+后台+设计师</li>\n<li>之前的数据都放在标签里，而且前端代码里没有html，因为后端框架要求要有html（jsp），前端的工作就很不爽（想象一下没有html的前端），开始前后端分离：<ol>\n<li>html交给了前端</li>\n<li>数据分离到了后台，按照接口的形式传到前台</li>\n<li>不允许一个人同时写前后端（人员分离）</li>\n</ol>\n</li>\n<li>前后端分离后，后端管数据和功能，前端只管页面的样式和特效，显得不那么重要，不如后端，前端晋升困难（目前还没有解决这个问题），你没有办法证明自己很厉害</li>\n<li>后来移动端兴起，初期网速贼慢，需要页面性能优化。还需要手机页面。所以又出现了响应式（CSS媒体查询）。前端又有了一部分领域前端可以涉足，又稍微重要了一点</li>\n<li>后来需求变多，只靠js没办法搞定，需要自动化处理，比如压缩代码，压缩资源。nodejs出现，使js能够在浏览器之外运行，自动化得以实现，同时js不再局限于浏览器，地位再次提升</li>\n<li>后面又出现了模块化各种标准（都不是官方的，会死，学习js模块就行）</li>\n<li>同时期各个开源社区迅速活跃，出现了很多转译语言，例如coffeescript、sass等，极大的推进了前端语言的发展，之后语言大升级，陆续出现了html5，css3，es6等</li>\n<li>语言变强，随之带来的就是性能提升，性能提升之后开始不满足于现状，于是前端也开始模仿后端的组织架构，例如mvc，C#的mvvm等。于是开始出现像angular和vue等的框架类库。之后facebook团队在实践中觉得两者都有缺点，于是借鉴游戏开发的一些经验搞出了react，搭配上统一体系的各种全家桶。一句话：<strong>前端性能得到提升后，开始往各个方向抄袭</strong></li>\n<li>nodejs社区开始活跃，随着TJ等人加入nodejs社区，几乎写编了nodejs的库，像是expressjs，koajs等。有了这些基础工具和框架，前端可以写后端应用了，前端地位再次提升</li>\n<li>后来一个中国人写了nodewebkit（前台用webkit，后台用node），这个东西将前端应用放进了桌面端像是一开始的微信、vscode、钉钉以及后来的atom（atom用的不是这个技术，类似）</li>\n<li>react-native的出现又将js放进了移动端，成为一个程序。至此，facebook实现了react的理念，前端覆盖了可能的所有端，达到了一次学习，处处使用</li>\n</ul>\n<h2 id=\"前端职业现状\"><a href=\"#前端职业现状\" class=\"headerlink\" title=\"前端职业现状\"></a>前端职业现状</h2><h3 id=\"薪资\"><a href=\"#薪资\" class=\"headerlink\" title=\"薪资\"></a>薪资</h3><p>从整体情况来看，从最近四五年来说，对于前端职业的需求虽然没有明显增长，但是也是没有减少过的，因为互联网产品的特性：需要快速发布，快速迭代。能够符合这一需求的只有前端，这一秒上线，下一秒用户就能看到，所以只要互联网在火，前端就不会熄火</p>\n<p>对于初级前端的薪资待遇来说</p>\n<ul>\n<li>一线城市（北上广深杭州）：<strong>6-12k</strong>，中位数就是8k，也就是8k你就勉强入门，还行的样子</li>\n<li>二线城市（武汉西安都重庆）：80%</li>\n<li>三线城市（贵州沈阳等）：60%</li>\n</ul>\n<p>对于中高级（3-5年）前端来说，差距就会比较大，此时的薪资水平跟你的技能水平密切相关，所以时间年限只是衡量你能力的一个方面，像是 100offer 提供的链接来看，有的前端能拿到300k的年薪，下面是链接：</p>\n<ul>\n<li><a href=\"https://cn.100offer.com/blog/posts/123\" target=\"_blank\" rel=\"noopener\">2015</a></li>\n<li><a href=\"https://cn.100offer.com/blog/posts/131\" target=\"_blank\" rel=\"noopener\">2016-1</a></li>\n<li><a href=\"https://cn.100offer.com/blog/posts/216\" target=\"_blank\" rel=\"noopener\">2016-2</a> </li>\n</ul>\n<h3 id=\"等级\"><a href=\"#等级\" class=\"headerlink\" title=\"等级\"></a>等级</h3><p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/frankfang-live-fe-dever-rank.jpg\" alt=\"\"></p>\n<h4 id=\"门外汉（正在入门）\"><a href=\"#门外汉（正在入门）\" class=\"headerlink\" title=\"门外汉（正在入门）\"></a>门外汉（正在入门）</h4><p>首先从人数来说，远不如java和php</p>\n<p>这部分人会自学，也会培训，但是在中国来说质量比较差，数量却又很多，要走这条路需要慎重选择机构</p>\n<h4 id=\"小型公司\"><a href=\"#小型公司\" class=\"headerlink\" title=\"小型公司\"></a>小型公司</h4><p>缺点明显：基本不会有人带你。</p>\n<p>基本会有一群后端，对应一两个前端，相对的要求也比较低，但是提升速度很慢，所以<strong>side project很重要</strong>，这是你提升最关键的东西</p>\n<h4 id=\"中型公司\"><a href=\"#中型公司\" class=\"headerlink\" title=\"中型公司\"></a>中型公司</h4><p>一个业务会有一个组，但是可能没有那么完善的开发体系，有些东西没有准备周全，比如需要你自己去申请一个域名，去买服务器这样的工作，需要你学习一切前端之外的东西。</p>\n<p>好处也就是你需要学习，所以提升上来说会比小型公司好的多</p>\n<h4 id=\"大型公司\"><a href=\"#大型公司\" class=\"headerlink\" title=\"大型公司\"></a>大型公司</h4><p>首先要进入公司，会有学历要求，像是学历要求本科。同时你的知识需要有深度，不能仅仅停留在表面，比如某个东西怎么用，你得知道为什么要这样用，它是怎么工作的，源码怎么写的</p>\n<p>同时提升速度快，毕竟你周围的人会有大规模网站的经验</p>\n<h2 id=\"学习路径\"><a href=\"#学习路径\" class=\"headerlink\" title=\"学习路径\"></a>学习路径</h2><h3 id=\"本科在校扎实型\"><a href=\"#本科在校扎实型\" class=\"headerlink\" title=\"本科在校扎实型\"></a>本科在校扎实型</h3><p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/frankfang-live-learning-path-1.jpg\" alt=\"\"></p>\n<p>从底层基础知识开始学习，逐步向上</p>\n<p>编程基础（通识） =&gt; 前端基础</p>\n<p>一个关键词一本砖头书，所以需要2-3年</p>\n<h3 id=\"赶紧入门实战型\"><a href=\"#赶紧入门实战型\" class=\"headerlink\" title=\"赶紧入门实战型\"></a>赶紧入门实战型</h3><p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/frankfang-live-learning-path-2.jpg\" alt=\"\"></p>\n<p>从树根网上走，每一个树枝是一个项目，也能有项目交叉覆盖各个树枝</p>\n<ol>\n<li>html基础标签、css2、js…</li>\n<li>数据库、ajax、http、动态加载、懒加载、预加载…</li>\n<li>css3、响应式…</li>\n<li>webpack、es6、框架…</li>\n<li>面向对象、库…</li>\n<li>对话框、下拉列表、拖拽div、按钮、设计模式、api的调用…</li>\n</ol>\n<h3 id=\"资料推荐\"><a href=\"#资料推荐\" class=\"headerlink\" title=\"资料推荐\"></a>资料推荐</h3><ul>\n<li>入门指导<ul>\n<li>书籍推荐<ul>\n<li>javascript.ruanyifeng.com</li>\n<li>es6.ruanyifeng.com</li>\n<li>你不知道的 JavaScript</li>\n<li>CSS 揭秘</li>\n</ul>\n</li>\n<li>项目推荐<ul>\n<li>原生 JS 仿网易云音乐、饿了么（后端使用 leanCloud）</li>\n<li>Vue 或 React 再实现一遍</li>\n</ul>\n</li>\n<li>网站推荐<ul>\n<li>MDN</li>\n<li>CSS Tricks</li>\n<li>Codrops</li>\n<li>优质的中文前端博客    （1.4k）<a href=\"https://github.com/FrankFang/best-chinese-front-end-blogs\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankFang/best-chinese-front-end-blogs</a></li>\n</ul>\n</li>\n<li>学习思路推荐<ul>\n<li>仿你看到的所有东西：hao123、知乎、微信</li>\n<li>Follow 我的 GitHub <ul>\n<li><a href=\"https://github.com/FrankFang/resume-15-3\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankFang/resume-15-3</a></li>\n<li><a href=\"https://github.com/FrankFang/nav-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankFang/nav-demo</a></li>\n<li><a href=\"https://github.com/FrankFang/canvas-demo-2017\" target=\"_blank\" rel=\"noopener\">https://github.com/FrankFang/canvas-demo-2017</a></li>\n</ul>\n</li>\n<li>看完任意一本教程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><h3 id=\"一年\"><a href=\"#一年\" class=\"headerlink\" title=\"一年\"></a>一年</h3><ul>\n<li>从 60 分到 80 分，关注用户体验</li>\n<li>模仿组件</li>\n<li>不要重复自己</li>\n<li>不要满足于调用 API</li>\n</ul>\n<p>首先是心态：比如你已经工作一年了，那么你很容易做出来能用的东西，这个时候你要想的是能不能更进一步，做一些更深层次的，你需要去网上找来用的东西，这些深入可以从关注用户体验与优化开始逐步深入</p>\n<p>模仿组件：要有意识的去写组件，比如工作上用到了一个组件，你可以先去看看，不要直接搬过来用，看了之后模仿写一个，写好之后比较比较，差在哪，然后推翻重写，最终目标是能给别人用，不管是公司里的前端还是后端</p>\n<p>不要重复做事情：比如你第一年是切页面，第二年你就不能再切页面了，要么你把它做成自动化，要么你就跳槽，不然你会被公司毁掉</p>\n<p>不要满足调用api：你要成为创造api得人，而不是一直是一个使用api的人</p>\n<h3 id=\"三年\"><a href=\"#三年\" class=\"headerlink\" title=\"三年\"></a>三年</h3><ul>\n<li>关注工作效率</li>\n<li>做份外的事情：后端、设计、产品</li>\n<li>管理上级、拢络平级</li>\n<li>变成重要的人</li>\n<li>坚持写博客</li>\n<li>模仿框架</li>\n</ul>\n<p>工作效率：作为一个三年前端，你要做到的是尽量不加班，要达到这个目标，你可以组件给自己用，写博客做一些常用经验总结防止忘记再去找</p>\n<p>做分外的事情：比如你能不能学学后端，了解一下深层次的后端工作原理；设计师是怎么设计出这些东西的，设计理念是什么；产品对这个需求怎么理解的，尽量做到知己知彼</p>\n<p>管理上级：利用上级职位，使另外一个人来跟你合作。比如对方也是一个三年后端，凭什么听你的来做事，这时候你就要会从上级那边迂回一下，达成一个愉快的合作</p>\n<p>笼络同级：平时跟同事打理好关系，吃个饭喝个酒什么的，在你升级的时候也就很少会出现不服管理的尴尬局面</p>\n<p>变成重要的人：对公司整个产品做一个深入的了解，比如为什么要有这个按钮，按钮怎么用的。这样你就能成为唯一能解决问题的人，让公司离不开你，别人有问题来问你</p>\n<p>坚持写博客：觉得重要的东西就写进去，比如一些工作方法的记录；产品需求的记录等等，方便备存</p>\n<p>模仿写框架：作为一年的前端要有能写组件的能力，而作为一个三年的前端，需要开始摸索写一个符合内部需求的框架，可以使借鉴的，可以使自己原创的</p>\n<h3 id=\"跟对人\"><a href=\"#跟对人\" class=\"headerlink\" title=\"跟对人\"></a>跟对人</h3><p>跟人（榜样）学，而不是跟视频、书学</p>\n<ul>\n<li>社区里的人</li>\n<li>公司里的人</li>\n<li>互联网上的人</li>\n</ul>\n<p>推崇自学都是有问题的，没有哪一门学科是推崇自学的，有一个好的引路人，会让你的学习事半功倍</p>\n<h2 id=\"QA\"><a href=\"#QA\" class=\"headerlink\" title=\"QA\"></a>QA</h2><h3 id=\"基础过关的标准\"><a href=\"#基础过关的标准\" class=\"headerlink\" title=\"基础过关的标准\"></a>基础过关的标准</h3><p>进亚马逊图书页面，搜索你想要检验的知识，比如JavaScript，之后你会得到一堆书，从这些书里找到那些高评价的经典书目（至少3本），看它们的目录，看着章节标题说出下面有什么知识，然后对照书本，看某个章节自己漏了什么，错了什么，这些内容就是需要你弥补的</p>\n<h3 id=\"学习形式\"><a href=\"#学习形式\" class=\"headerlink\" title=\"学习形式\"></a>学习形式</h3><ol>\n<li>看书</li>\n<li>总结（总结博客，笔记）</li>\n<li>输出<ul>\n<li>写代码 — 体现细节</li>\n<li>写教程类型文章 — 体现大概</li>\n<li>讲授</li>\n</ul>\n</li>\n</ol>\n<p>学习效果从上到下依次递增</p>\n<h3 id=\"科班生非科班生区别\"><a href=\"#科班生非科班生区别\" class=\"headerlink\" title=\"科班生非科班生区别\"></a>科班生非科班生区别</h3><p>科班生在大学四年最无所事事的时间里被学校逼着学习了很多计算机的基础知识，像是硬件知识、计算机组成原理、网络、操作系统、汇编之类的课程。这些知识虽然在刚开始编程时不会立马用到，但是当遇到一些编译问题或是一些底层相关知识时，可能在了解过后，能突然回忆起一些点，去翻翻书，能够快速捡起这些知识，触类旁通，梳理清楚很多知识。</p>\n<p>例如webpack中的各种loader就是编译原理中的抽象语法树。</p>\n<p>同时在大学里还会接触到系统的语言学习，再下一次上手一个不熟悉的语言时能够快速找到相似点，理解相对较快。</p>\n<p>那么是不是就一定不如科班生呢？答案是否定的。</p>\n<p>首先对于初级前端来说，不用担心科班与非科班的差别，这个阶段你只需要关心api会不会用，有没有一个良好的代码组织习惯，有没有解决问题的能力和交流问题的能力等。</p>\n<p>对于中级以上的前端来说，需要的是一定的抽象能力和设计能力等，这时候就会有所差别，你去要去了解相关东西，最好还是问人，至少让他给你指方向，之后再仔细看书，静静心，逼自己看，毕竟人家在本科阶段也是静静看完过来的。</p>\n<h3 id=\"前端需要对后台的熟悉程度\"><a href=\"#前端需要对后台的熟悉程度\" class=\"headerlink\" title=\"前端需要对后台的熟悉程度\"></a>前端需要对后台的熟悉程度</h3><p>搞清楚http的原理和使用，这是前后端最重要的交互方式像是刷新页面，ajax等等</p>\n<p>怎么了解呢，side project，技术语言无所谓，东西也可以很简单，像是一个需要登录的留言板之类。这样就能了解到后端的一些你需要了解的东西</p>\n<h3 id=\"如何学一个内容\"><a href=\"#如何学一个内容\" class=\"headerlink\" title=\"如何学一个内容\"></a>如何学一个内容</h3><p>快速看一遍文档，在脑子里留一个大概的内容，写失败一个项目（side project），总结，然后开始上项目，你就慢慢开始会了</p>\n","categories":["职业"],"tags":["职业规划"]},{"title":"我的笔试与面试题目","url":"https://teobler.com/20171105-interview-questions.html","content":"<p>8月9月发生了很多事，一度停止了所有活动，包括学习。</p>\n<p>10月份来到成都寻找自己人生中的第一份工作。这一个月里跑了成都几乎所有的大学，电子科大清水河校区很大，但是现在我已经不需要导航了，感觉自己已经摸清了每一条达大道；川大望江校区古朴的校园景色可能我爸会很喜欢吧；西南交大安保很严，门口的小吃街很不错；成信感觉比电子科大还要远。</p>\n<p>这一个月最大的遗憾是被thoughtworks刷掉，追问个清楚之后只能说技不如人，甘拜下风。最后选择了没有大家那么夸张，但是可能是现在的自己能拿到的算是不错的offer。静下心来，回顾下这一个月来的得失，总结总结那些题目，好好沉淀，相信自己会有更好的提升。</p>\n<p>回忆下这一个月来遇到的有印象的所有笔试面试题，大概就是下面这些了，也附上自己后知后觉的答案，部分答案来自网络，如有侵权，请联系我，答案仅供参考。</p>\n<h2 id=\"前端相关\"><a href=\"#前端相关\" class=\"headerlink\" title=\"前端相关\"></a>前端相关</h2><p><strong>数组与字符串的操作中，slice、splice、split、join是干什么的，详细说明。</strong></p>\n<ul>\n<li><strong>slice方法</strong>接收一个或者两个参数。只有一个参数时，该方法返回该参数位置到数组末尾的所有项；两个参数时返回两个参数中间的所有项（不包括第二参数所在项）。该方法不影响原数组</li>\n<li><strong>splice方法</strong>用于数组的删除、插入和修改，splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组，该方法会影响原数组，其用法如下：<ul>\n<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项</li>\n<li>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数） 和要插入的项。 如果要插入多个项， 可以再传入第四、第五， 以至任意多个项。 例如， splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”</li>\n<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”</li>\n</ul>\n</li>\n<li><strong>split方法</strong>接收两个参数，第一个参数为字符串或正则，将字符串按照相应的字符串或正则划分成若干个元素的数组，第二个参数为该数组的元素个数，默认为划分全部</li>\n<li><strong>join方法</strong>接收一个参数，以该参数来分隔数组中的每一个元素，使其成为一个字符串，该方法不会影响原数组</li>\n</ul>\n<p><strong>水平居中与垂直居中你知道哪些方法，以及如何居中一个浮动元素？</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*水平居中*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: n px;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: fit-content;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">  </span><br><span class=\"line\">  target &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline-block</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.grandfather</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  </span><br><span class=\"line\">  .father &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span><span class=\"selector-pseudo\">:50</span>%</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-class\">.target</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">      <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">      <span class=\"attribute\">right</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.grandfather</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\"></span><br><span class=\"line\">  .father &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">absolute</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span>: 50%;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-class\">.target</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">      <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">      <span class=\"attribute\">right</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.father</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  justify-content: center;//水平方向</span><br><span class=\"line\">  align-items: center; //垂直方向</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"selector-class\">.target</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*垂直*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: table;</span><br><span class=\"line\">  </span><br><span class=\"line\">  .target&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">table-cell</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">vertical-align</span>: <span class=\"selector-tag\">middle</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.target</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: n px;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -n/<span class=\"number\">2</span> px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.target</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>; <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.target</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>创建一个对象的几种方法</strong></p>\n<ul>\n<li>工厂模式</li>\n<li>构造函数模式</li>\n<li>原型模式</li>\n<li>构造函数和原型组合模式</li>\n<li>动态原型模式</li>\n<li>寄生构造模式</li>\n<li>稳妥构造模式</li>\n</ul>\n<p><a href=\"https://juejin.im/entry/58291447128fe1005cd41c52\" target=\"_blank\" rel=\"noopener\">实在不想总结代码了</a></p>\n<p><strong>清除浮动的几种方法</strong></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  .left &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.clear</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  zoom: 1;  //兼容IE</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"selector-class\">.left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">zoom</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  .left &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block; </span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both; </span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>: hidden; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>position的各个属性</strong></p>\n<ul>\n<li>static:默认值，元素按照默认的块级或内联样式进行显示</li>\n<li>relative:相对定位，设置了该属性后，元素会根据具体的top、bottom、left、right进行偏移，但是原位置仍保留</li>\n<li>absolute:绝对定位，设置了该属性后，元素脱离文档流，原位置也就不保留，根据相应的top、bottom、left、right进行定位，同时会被加上一个块级框</li>\n<li>fixed:相对于浏览器窗口进行定位，展现方式类似于absolute</li>\n</ul>\n<p>需要注意的是，relative的元素，其包含块是其第一个块级父元素；而absolute元素的包含块为第一个position不是static的祖先元素，没有的话就是根元素；相应的fixed元素的包含块则为浏览器窗口。</p>\n<p>他们的偏移都是相对于其包含块进行偏移的。</p>\n<p><strong>display的常用属性</strong></p>\n<ul>\n<li>block:块级显示。一个块级元素会新开一行并尽可能的撑满容器</li>\n<li>inline:行内显示。一个行内元素可以在段落中包裹一些内容而不打乱段乱的布局，宽高无用。例如 a 标签</li>\n<li>none:隐藏显示，不会保留该元素的占位。visibility 属性则保留</li>\n<li>inline-block:行内块元素，同时具有块元素的宽高属性和行内元素的同行属性</li>\n<li>table:此元素会作为块级表格来显示（类似table），表格前后带有换行符</li>\n<li>inline-table:此元素会作为内联表格来显示（类似table），表格前后没有换行符</li>\n</ul>\n<p><strong>说说你对盒子模型的理解</strong></p>\n<ul>\n<li>块级元素：html文档中的每个元素都被描绘成矩形盒子，这些矩形盒子通过一个模型来描述其占用空间，这个模型称为盒模型。盒模型通过四个边界来描述：margin（外边距），border（边框），padding（内边距），content（内容区域）</li>\n<li>行内元素：<ol>\n<li>对于非替换元素，比如a，span标签等<br> （1）可以设置margin-left和margin-right属性，无法设置margin-top和margin-bottom属性<br> （2）行内元素border和padding可以设置，但是border-top和padding-top到页面顶部后就不再增加</li>\n<li>对于替换元素，比如input，img标签，margin，padding，border都有效果</li>\n</ol>\n</li>\n<li>IE盒模型：IE的盒模型有一点不同的是，其width等于content + padding；而标准盒模型width等于content</li>\n</ul>\n<p><strong>cookie、sessionStorage、localStorage的区别</strong></p>\n<ul>\n<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递；cookie 数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie 数据不能超过4k，同时因为每次http请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识</li>\n<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li>\n<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>\n<li>作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便</li>\n</ul>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/store-in-fe.png\" alt=\"\"></p>\n<p><strong>cookie 和session 的区别</strong>：</p>\n<ul>\n<li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li>\n<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</li>\n<li>所以如果考虑到安全应当使用session</li>\n<li>但是session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>\n<li>所以如果考虑到减轻服务器性能方面，应当使用COOKIE</li>\n<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</li>\n</ul>\n<p><strong>H5新增标签有哪几个</strong></p>\n<ul>\n<li><code>&lt;article&gt;</code>标签定义外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容</li>\n<li><code>&lt;aside&gt;</code>标签定义 article 以外的内容。aside 的内容应该与 article 的内容相关</li>\n<li><code>&lt;audio&gt;</code> 标签定义声音，比如音乐或其他音频流</li>\n<li><code>&lt;canvas&gt;</code> 标签定义图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上</li>\n<li><code>&lt;command&gt;</code> 标签定义命令按钮，比如单选按钮、复选框或按钮</li>\n<li><code>&lt;datalist&gt;</code> 标签定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表</li>\n<li><code>&lt;details&gt;</code> 标签定义元素的细节，用户可进行查看，或通过点击进行隐藏。与 <code>&lt;legend&gt;</code> 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail</li>\n<li><code>&lt;embed&gt;</code> 标签定义嵌入的内容，比如插件</li>\n<li><code>&lt;figcaption&gt;</code> 标签定义 figure 元素的标题。”figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置</li>\n<li><code>&lt;figure&gt;</code> 标签用于对元素进行组合。使用 <code>&lt;figcaption&gt;</code> 元素为元素组添加标题</li>\n<li><code>&lt;footer&gt;</code> 标签定义 section 或 document 的页脚。典型地，它会包含创作者的姓名、文档的创作日期以及/或者联系信息</li>\n<li><code>&lt;header&gt;</code> 标签定义 section 或 document 的页眉</li>\n<li><code>&lt;hgroup&gt;</code> 标签用于对网页或区段（section）的标题进行组合</li>\n<li><code>&lt;keygen&gt;</code> 标签定义生成密钥</li>\n<li><code>&lt;mark&gt;</code>主要用来在视觉上向用户呈现那些需要突出的文字。<code>&lt;mark&gt;</code>标签的一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词</li>\n<li><code>&lt;meter&gt;</code> 标签定义度量衡。仅用于已知最大和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义</li>\n<li><code>&lt;nav&gt;</code> 标签定义导航链接的部分</li>\n<li><code>&lt;output&gt;</code> 标签定义不同类型的输出，比如脚本的输出</li>\n<li><code>&lt;progress&gt;</code> 标签运行中的进程。可以使用 <code>&lt;progress&gt;</code> 标签来显示 JavaScript 中耗费时间的函数的进程</li>\n<li><code>&lt;rp&gt;</code> 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容</li>\n<li><code>&lt;rt&gt;</code> 标签定义字符（中文注音或字符）的解释或发音</li>\n<li><code>&lt;ruby&gt;</code> 标签定义 ruby 注释（中文注音或字符）</li>\n<li><code>&lt;section&gt;</code> 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</li>\n<li><code>&lt;source&gt;</code> 标签为媒介元素（比如 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>）定义媒介资源</li>\n<li><code>&lt;summary&gt;</code> 标签包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。”summary” 元素应该是 “details” 元素的第一个子元素</li>\n<li><code>&lt;time&gt;</code> 标签定义日期或时间，或者两者</li>\n<li><code>&lt;video&gt;</code> 标签定义视频，比如电影片段或其他视频流</li>\n</ul>\n<p>转自<a href=\"http://www.daqianduan.com/2857.html\" target=\"_blank\" rel=\"noopener\">大前端</a></p>\n<p><strong>从输入URL到网页渲染的过程</strong></p>\n<ul>\n<li>DNS解析:将URL地址解析为IP地址</li>\n<li>TCP连接:三次握手</li>\n<li>发送HTTP请求</li>\n<li>服务器处理请求并返回HTTP报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束:四次挥手</li>\n</ul>\n<p><strong>http请求头与响应头的内容</strong></p>\n<ul>\n<li>请求头：Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent</li>\n<li>响应头：Server, Connection…</li>\n</ul>\n<p><strong>跨域问题与jsonp原理</strong></p>\n<p>浏览器的同源策略会导致跨域，这里同源策略又分为以下两种：</p>\n<ol>\n<li>DOM同源策略：禁止对不同源页面DOM进行操作。主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li>\n<li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</li>\n</ol>\n<p>同时解决跨域问题一般也有两种：</p>\n<ol>\n<li>跨域资源共享：<ul>\n<li>对于客户端，需要设置ajax请求的xhr属性withCredentials = true</li>\n<li>对于服务器端，需要在 response header中设置如下两个字段:<br>Access-Control-Allow-Origin: <a href=\"http://www.yourhost.com\" target=\"_blank\" rel=\"noopener\">http://www.yourhost.com</a><br>Access-Control-Allow-Credentials:true</li>\n</ul>\n</li>\n<li>jsonp实现跨域：基本原理就是通过动态创建script标签,然后利用src属性进行跨域，例如：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个fun函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">fata</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个脚本，并且告诉后端回调函数名叫fun</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> body = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'body'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.gerElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">script.type = <span class=\"string\">'text/javasctipt'</span>;</span><br><span class=\"line\">script.src = <span class=\"string\">'demo.js?callback=fun'</span>;</span><br><span class=\"line\">body.appendChild(script);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回的脚本会直接执行，我们也就拿到了想要的数据</span></span><br><span class=\"line\">fun(&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"name\"</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>什么是闭包，闭包的作用是什么</strong></p>\n<p>浅显点来说，闭包指的是定义在函数内部的函数，它能够访问函数外部无法访问到的变量，那么如果将其返回到外部作用域，则我们就能够在外部作用域访问到函数内的变量了。换句话说，所谓闭包函数，即这个<strong>函数</strong>封闭了它自己的定义时的<strong>环境</strong>，形成了一个闭包。当然这样的说法是很不严谨的，具体请看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<p>作用：访问内部变量、实现封装(私有方法)、保存某个变量的值</p>\n<p><strong>typeof返回的类型</strong></p>\n<ul>\n<li>object</li>\n<li>string</li>\n<li>number</li>\n<li>function</li>\n<li>symbol</li>\n<li>undefined</li>\n<li>boolean</li>\n</ul>\n<p><strong>谈谈你对作用域链的理解</strong></p>\n<p>我们先来看一段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">hobby</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'小明'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> age = <span class=\"string\">'12'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name, age, hobby);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>person定义以后生成函数对象，函数对象有一个[[scope]]属性指向定义person时的作用域空间，也就是person定义时所在的变量对象</li>\n<li>person运行时生成当前变量对象，变量对象会把传参和内部定义的局部变量和函数全部设置为自己的属性</li>\n<li>比如person(‘打羽毛球’)运行时要查找name，就是去当前变量对象查找name属性，如果查找不到，就查找person函数对象的[[scope]]属性引用的变量对象</li>\n<li>综上，函数运行时查找资源，是先查当前变量对象，查找不到就找该函数对象[[scope]]属性引用的变量对象，以此类推，一直向上找，直到全局对象，如果还查找不到，就报出语法错误</li>\n</ol>\n<p><strong>你对前端性能优化有什么看法</strong></p>\n<p>这个比较多了，请移步<a href=\"https://teobler.com/20170721-performance-optimization.html\">我的另一篇文章</a></p>\n<p><strong>谈谈你对原型链的理解</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age=age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype=&#123;</span><br><span class=\"line\">    <span class=\"string\">\"constructor\"</span>:Person,</span><br><span class=\"line\">    <span class=\"string\">\"showName\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"showAge\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> newPerson=<span class=\"keyword\">new</span> Person(<span class=\"string\">'小明'</span>,<span class=\"number\">21</span>);</span><br></pre></td></tr></table></figure>\n<p>代码中我们通过new构造函数Person，生成实例化对象newPerson，那么newPerson就有一个隐形属性<code>__proto__</code>指向Person.prototype原型对象。</p>\n<ol>\n<li>现在访问newPerson.name,因为newPerson对象上有name属性，值为“小明”，这个可以直接访问到</li>\n<li>现在我们访问newPerson.showName方法呢，newPerson对象上并没有直接定义showName方法，访问不到，然后newPerson就会通过<code>__proto__</code>属性找到Person.prototype，也就是Person的原型对象，看看能不能访问到showName方法，现在是可以访问到了。</li>\n<li>如果Person.prototype对象里面也没有showName方法呢？那就通过Person.prototype对象的<code>__proto__</code>继续找，在原型链查找中，一般到Object.prototype.<code>__proto__</code>还查找不到时，就会终止查找，因为ECMA规范里说明Object.prototype.<code>__proto__</code>是原型链终点，值为null，而这个时候那个没有访问到的属性值设置为undefined，并不爆出语法错误，这是原型链查找和作用域链查找的一个显著区别</li>\n</ol>\n<p><strong>什么是ajax</strong></p>\n<p>简单来说ajax就是一种在不刷新整个网页的前提下向服务器发送请求，并接收数据填充页面的一种技术。关键在于<strong>异步请求数据，局部刷新页面内容</strong>。我们来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ajax基于XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当请求成功后监听状态变化</span></span><br><span class=\"line\">request.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.readyState == <span class=\"number\">4</span> &amp;&amp; <span class=\"keyword\">this</span>.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(request.responseText) <span class=\"comment\">// 此处为返回内容</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置请求参数</span></span><br><span class=\"line\">request.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"filename\"</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送请求</span></span><br><span class=\"line\">request.send();</span><br></pre></td></tr></table></figure>\n<p><strong>谈谈你对webpack的看法</strong></p>\n<p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p>\n<p>webpack的两大特色：</p>\n<ol>\n<li>code splitting（可以自动完成）</li>\n<li>loader 可以处理各种类型的静态文件，并且支持串联操作<br>webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li>\n</ol>\n<p>webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：</p>\n<ol>\n<li>对 CommonJS 、 AMD 、ES6的语法做了兼容</li>\n<li>对js、css、图片等资源文件都支持打包</li>\n<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li>\n<li>有独立的配置文件webpack.config.js</li>\n<li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li>\n<li>支持 SourceUrls 和 SourceMaps，易于调试</li>\n<li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</li>\n<li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li>\n</ol>\n<h2 id=\"安全相关\"><a href=\"#安全相关\" class=\"headerlink\" title=\"安全相关\"></a>安全相关</h2><p>这方面的知识说实话到写文章之前我没有经过任何实践，但是遇到了问题也没办法，只能先理解概念，日后有机会了慢慢实践吧</p>\n<p><strong>sql注入原理</strong></p>\n<p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。总的来说有以下几点：</p>\n<ol>\n<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等</li>\n<li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取</li>\n<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>\n<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息</li>\n</ol>\n<p><strong>XSS原理及防范</strong></p>\n<p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>\n<p>XSS防范方法：</p>\n<ul>\n<li>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>&lt; &gt; , ; , ’</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把 html、 tag 弄出来。这一个层面做好，至少可以堵住超过一半的 XSS 攻击</li>\n<li>其次，避免直接在cookie 中泄露用户隐私，例如email、密码等等</li>\n<li>再次，通过使 cookie 和系统 ip 绑定来降低 cookie 泄露后的危险。这样攻击者得到的 cookie 没有实际价值，不可能拿来重放</li>\n<li>如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上 HttpOnly 来防止javascript 代码直接获取cookie</li>\n<li>最后，尽量采用 POST 而非 GET 提交表单</li>\n</ul>\n<p><strong>XSS与CSRF有什么区别吗？</strong></p>\n<p>XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p>\n<p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p>\n<ol>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A的情况下，访问危险网站B。</li>\n</ol>\n<p>CSRF的防御：</p>\n<ul>\n<li>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>\n<li>通过验证码的方法</li>\n<li>Web Worker 和webSocket</li>\n</ul>\n<p>worker主线程：</p>\n<blockquote>\n<p>1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</p>\n<p>2.通过worker.postMessage( data ) 方法来向worker发送数据。</p>\n<p>3.绑定worker.onmessage方法来接收worker发送过来的数据。</p>\n<p>4.可以使用 worker.terminate() 来终止一个worker的执行。</p>\n</blockquote>\n<p>WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p>\n<p><strong>HTTP和HTTPS有什么区别，为什么HTTPS要安全</strong></p>\n<p>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。</p>\n<p>默认HTTP的端口号为80，HTTPS的端口号为443。</p>\n<p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tsl协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>\n<h2 id=\"网络相关\"><a href=\"#网络相关\" class=\"headerlink\" title=\"网络相关\"></a>网络相关</h2><p><strong>TCP协议的三次握手与四次挥手你知道吗</strong></p>\n<p>TCP连接作为一种可靠的连接协议，为了保证连接的可靠性，在连接和断开连接时分别进行了3次和4次连接和断开确定，具体内容如下：</p>\n<p>三次握手：</p>\n<ol>\n<li>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</li>\n<li>服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</li>\n<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</li>\n</ol>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/TCP-connection.png\" alt=\"\"></p>\n<p>四次挥手：</p>\n<ol>\n<li>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）</li>\n<li>主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）</li>\n<li>主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段</li>\n<li>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放</li>\n</ol>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/TCP-disconnection.jpg\" alt=\"\"></p>\n<p>一些标志位的解释：</p>\n<ul>\n<li>SYN：同步标志。同步序列编号（Synchronize Sequence Numbers）栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号</li>\n<li>ACK：确认标志。确认编号（Acknowledgement Number）栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1，Figure：1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据</li>\n<li>FIN：结束标志。带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。<br>服务端处于监听状态，客户端用于建立连接请求的数据包(IP packet）按照TCP/IP协议堆栈组合成为TCP处理的分段（segment）</li>\n</ul>\n<p><strong>OSI七层模型是哪七层，TCP、IP、http协议分别在哪层，数据包在里边是怎么传输的</strong></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/OSI-model.png\" alt=\"\"></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/network-protocol.png\" alt=\"\"></p>\n<p>数据包在协议层中一层层加上该层的数据头，之后在网络节点中寻找下一跳的目标，到达目标节点后解包到对应的协议传输层获取下一跳的目的地，之后重新打包发送，到达最后的目的地之后又层层解包，得到最初发送的数据。</p>\n<p><strong>TCP和UDP的区别</strong></p>\n<p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>\n<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去</p>\n<p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>\n<p><strong>关于Http 2.0 你知道多少？</strong></p>\n<ul>\n<li>HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能</li>\n<li>HTTP/2提供更多的加密支持</li>\n<li>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差</li>\n<li>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</li>\n</ul>\n<h2 id=\"编程通识\"><a href=\"#编程通识\" class=\"headerlink\" title=\"编程通识\"></a>编程通识</h2><p><strong>面向对象的理解，面向对象的三要素，是什么意思</strong></p>\n<p>首先我们需要明确的是，面向对象是相对于面向过程来讲的，我在知乎上看到过一个例子，说的很形象，这里分享下：</p>\n<p>假如你要充话费，那么你可以下个支付宝，然后绑定银行卡，然后在淘宝充值，这个叫做面向过程。然后你的女朋友也要充值话费了，但是她跟你想的是不一样的，她会想，谁会充话费呢？当然是你了，她就给你电话号码，然后你把之前的做了一遍，然后她就充值成功了。这就是面向对象。女的思维大部分是面向“对象”的！她不关心处理的细节，只关心谁可以，和结果。印证了面向对象的那句经典的话：<strong>你办事，我放心！</strong></p>\n<p>三要素：封装、继承、多态</p>\n<ul>\n<li>封装就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分</li>\n<li>继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力</li>\n<li>多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用（继承与多态是一个整体不可分割的概念，可以参考<a href=\"https://teobler.com/20170730-perfessional-JavaScript-notes-1.html#面向对象的程序设计\">我之前的这篇文章</a>）</li>\n</ul>\n<p><strong>栈和队列的区别?</strong></p>\n<ul>\n<li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的</li>\n<li>队列先进先出，栈先进后出</li>\n<li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li>\n<li>栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等</li>\n<li>堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收</li>\n<li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序</li>\n<li>栈（数据结构）：一种先进后出的数据结构</li>\n</ul>\n<p><strong>你所熟知的数据结构、差别、使用场景</strong></p>\n<ol>\n<li><p><strong>单向链表</strong>：典型的应用场合是各类缓冲池和栈的实现，适用于只从一端单向访问的场合，这种场合一般来说：</p>\n<ul>\n<li>删除时，只适合删除第一个元素</li>\n<li>添加时，只直接添加到最后一个元素的后面或者添加到第一个元素的前面</li>\n<li>属于单向迭代器，只能从一个方向走到头（只支持前进或后退，取决于实现），查找效率极差。不适合大量查询的场合。</li>\n</ul>\n</li>\n<li><p><strong>双向链表</strong>：这种典型的应用场景是各种不需要排序的数据列表管理，相比单向链表，拥有前向和后向两个指针地址，所以适合以下场合：</p>\n<ul>\n<li>删除时，可以删除任意元素，而只需要极小的开销</li>\n<li>添加时，当知道它的前一个或后一个位置的元素时，只需要极小的开销</li>\n<li>属于双向迭代器，可以从头走到尾或从尾走到头，但同样查找时需要遍历，效率与单向链表无改善，不适合大量查询的场合。</li>\n</ul>\n</li>\n<li><p><strong>数组</strong>：这种数据结构使用一段连续的空间来存贮元素，所以可以直接通过索引来获取到某个元素，而且可以通过对元素的内容进行排序，然后使用二分法查找，从而提供查找效率。其适合的场合主要是：</p>\n<ul>\n<li>不会频繁增删元素的场合，因为增删元素都牵涉到元素空间的重新分配，频繁的内存分配操作会大幅降低操作效率。但添加操作时，可以通过预分配足够的空间来优化添加时的效率</li>\n<li>属于随机迭代器，可以随机访问任意元素。对于已排序的元素查找起来效率较高</li>\n</ul>\n</li>\n<li><p><strong>二叉树</strong>：（含红黑树、平衡二叉树等）这个数据结构类似于双向链表，任意插入元素时都会自动排序，红黑树和平衡二叉树都使二叉树尽量平衡，从而使查询时和二分法类似。它适合的场合主要是：</p>\n<ul>\n<li>需要时刻保证列表元素的有序排列</li>\n<li>需要频繁的增删和查询操作</li>\n<li>属于双向迭代器，不能随机访问任意元素</li>\n</ul>\n</li>\n<li><p><strong>哈希桶</strong>：这个数据结构使用数组和链表来管理元素，在好的桶尺寸和哈希算法支持下，理想上可以达到接近数组的随机访问效率。其适合的场合主要是：</p>\n<ul>\n<li>不需要保证元素的顺序（因为它是按哈希值决定插入到那个桶里，与原始数据内容无关）</li>\n<li>需要频繁的增删和查询操作</li>\n<li>属于单向或双向迭代器（取决于具体实现），不能随机访问任意元素</li>\n</ul>\n</li>\n</ol>\n<p><strong>XML和JSON的区别？</strong></p>\n<ol>\n<li>数据体积方面，JSON相对于XML来讲，数据的体积小，传递的速度更快些</li>\n<li>数据交互方面，JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互</li>\n<li>数据描述方面，JSON对数据的描述性比XML较差</li>\n<li>传输速度方面，JSON的速度要远远快于XML</li>\n</ol>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p><strong>二叉树求和</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">preOrder = <span class=\"function\">(<span class=\"params\">Node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Node) &#123;</span><br><span class=\"line\">    sum += Node;</span><br><span class=\"line\">    preOrder(Node.children[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    preOrder(Node.children[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>数组去重</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 法1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'1'</span>,<span class=\"string\">'1'</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> newArr = <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 法2</span></span><br><span class=\"line\">unique = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = arr.filter(<span class=\"function\">(<span class=\"params\">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.indexOf(item) === index;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在记录了两个算法以后实在是觉得抛开一线互联网公司，一般的公司其实前端的算法题目在所有技术岗中算是比较“弱智”，而自己的实力实在是够不到一线的边，所以目前来说遇到的算法题目觉得没有太多记录的必要，需要的小伙伴建议刷刷《剑指offer》和 leetcode 好了，这里就不再记录我遇到的算法题目了。</p>\n","categories":["职业"],"tags":["面试","面试题"]},{"title":"JS高级程序设计读书笔记(下)","url":"https://teobler.com/20170817-professional-JavaScript-notes-3.html","content":"<h2 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h2><p>dom是文档对象模型的简称，dom将html语言描述成了一个拥有层次结构的树，允许开发人员对其进行操作，以达到使用js修改页面的行为</p>\n<h3 id=\"NODE类型\"><a href=\"#NODE类型\" class=\"headerlink\" title=\"NODE类型\"></a>NODE类型</h3><p>每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列 12 个数值常量来表示，任何节点类型必居其一：</p>\n<ul>\n<li>Node.ELEMENT_NODE(1)</li>\n<li>Node.ATTRIBUTE_NODE(2)</li>\n<li>Node.TEXT_NODE(3)</li>\n<li>Node.CDATA_SECTION_NODE(4)</li>\n<li>Node.ENTITY_REFERENCE_NODE(5)</li>\n<li>Node.ENTITY_NODE(6)</li>\n<li>Node.PROCESSING_INSTRUCTION_NODE(7)</li>\n<li>Node.COMMENT_NODE(8)</li>\n<li>Node.DOCUMENT_NODE(9)</li>\n<li>Node.DOCUMENT_TYPE_NODE(10)</li>\n<li>Node.DOCUMENT_FRAGMENT_NODE(11)</li>\n<li>Node.NOTATION_NODE(12)</li>\n</ul>\n<p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在 IE 中无效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Node is an element.\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。如果二者相等，则意味着 someNode 确实是一个元素。然而，由于 IE 没有公开 Node 类型的构造函数，因此上面的代码在 IE 中 会导致错误。为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适用于所有浏览器</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (someNode.nodeType == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Node is an element.\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点关系\"><a href=\"#节点关系\" class=\"headerlink\" title=\"节点关系\"></a>节点关系</h3><h4 id=\"父子节点\"><a href=\"#父子节点\" class=\"headerlink\" title=\"父子节点\"></a>父子节点</h4><p>每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。NodeList 是一种类数组 对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来 访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。NodeList 对象的 独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映 在 NodeList 对象中。</p>\n<p>下面的例子展示了如何访问保存在 NodeList 中的节点——可以通过方括号，也可以使用 item() 方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> firstChild = someNode.childNodes[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> secondChild = someNode.childNodes.item(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = someNode.childNodes.length;</span><br></pre></td></tr></table></figure>\n<p>父节点的 firstChild 和 lastChild 属性分别指向其 childNodes 列表中的第一个和最后一个节点。其中，someNode.firstChild 的值 始 终 等 于 someNode.childNodes[0] ， 而 someNode.lastChild 的 值 始 终 等 于 someNode. childNodes [someNode.childNodes.length-1]。在只有一个子节点的情况下，firstChild 和 lastChild 指向同一个节点。如果没有子节点，那么 firstChild 和 lastChild 的值均为 null。</p>\n<p>每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中 的所有节点都具有相同的父节点， 因此它们的 parentNode 属性都指向同一个节点。</p>\n<h4 id=\"兄弟节点\"><a href=\"#兄弟节点\" class=\"headerlink\" title=\"兄弟节点\"></a>兄弟节点</h4><p>包含在 childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性 值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null，如下面的例子所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (someNode.nextSibling === <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Last node in the parent’s childNodes list.\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (someNode.previousSibling === <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"First node in the parent’s childNodes list.\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"操作节点\"><a href=\"#操作节点\" class=\"headerlink\" title=\"操作节点\"></a>操作节点</h3><p><strong>appendChild()</strong>，用于向 childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增 节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后， appendChild() 返回新增的节点。</p>\n<p>如果传入到 appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置 转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出 现在文档中的多个位置上。因此，如果在调用 appendChild()时传入了父节点的第一个子节点，那么 该节点就会成为父节点的最后一个子节点，如下面的例子所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//someNode 有多个子节点 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> returnedNode = someNode.appendChild(someNode.firstChild); </span><br><span class=\"line\">alert(returnedNode == someNode.firstChild); <span class=\"comment\">//false </span></span><br><span class=\"line\">alert(returnedNode == someNode.lastChild); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>insertBefore()</strong>方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插 入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是 null，则 insertBefore()与 appendChild()执行相同的操作</p>\n<p><strong>replaceChild()</strong>方法接受的两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。在使用 replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。<strong>从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。</strong></p>\n<p><strong>removeChild()</strong>方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。与使用 replaceChild()方法一样，通过 removeChild()移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。</p>\n<p><strong>cloneNode()</strong>用于创建调用这个方法的节点的一个完全相同的副本。cloneNode()方法接受一个布尔值参数，表示是否执行深复制。在参数为 true 的情况下，执行深复制，也就是复制节点及其整个子节点树；在参数为 false 的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”。</p>\n<h3 id=\"Document类型\"><a href=\"#Document类型\" class=\"headerlink\" title=\"Document类型\"></a>Document类型</h3><p>JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个 属性，因此可以将其作为全局对象来访问。</p>\n<h4 id=\"文档子节点\"><a href=\"#文档子节点\" class=\"headerlink\" title=\"文档子节点\"></a>文档子节点</h4><p>虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingIn-struction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是 documentElement 属性，该属性始终指向 HTML 页面中的<code>&lt;html&gt;</code>元素。另一个就是通过 childNodes 列表访问文档元素， 但通过 documentElement 属性则能更快捷、更直接地访问该元素。</p>\n<p>文档中通常只包含一个子节点， 即 <code>&lt;html&gt;</code> 元素。 可以通过 documentElement 或 childNodes 列表来访问这个元素。作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向<code>&lt;body&gt;</code>元素(document.body)</p>\n<h4 id=\"文档信息\"><a href=\"#文档信息\" class=\"headerlink\" title=\"文档信息\"></a>文档信息</h4><p><strong>title</strong>包含着<code>&lt;title&gt;</code>元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的 标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改 title 属性的值不会改变<code>&lt;title&gt;</code> 元素。</p>\n<p><strong>URL</strong>属性中包含页面完整的 URL（即地址栏中显示的 URL）。</p>\n<p><strong>domain</strong>属性中只包含页面的域名。</p>\n<p><strong>referrer</strong>属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，referrer 属性中可能 会包含空字符串。</p>\n<p>所有这些信息都存在于请求的 HTTP 头部， 只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已</p>\n<h4 id=\"查找元素\"><a href=\"#查找元素\" class=\"headerlink\" title=\"查找元素\"></a>查找元素</h4><p><strong>getElementById()</strong>接收一个参数：要取得的元素的 ID。如果找到相应的元素则返回该元素，如果不存在带有相应 ID 的元素，则返回 null。注意，这里的 ID 必须与页面中元素的 id 特性（attribute）严格匹配，包括大小写。</p>\n<p><strong>getElementsByClass()</strong>接收一个参数：要取得的元素的class。返回一个类似数组的对象，包含了所有指定 class 名称的子元素。当调用发生在document对象上时, 整个DOM都会被搜索, 包含根节点。</p>\n<p><strong>getElementsByTagName()</strong>方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的 NodeList。在 HTML 文档中，这个方法会返回一 个 HTMLCollection 对象，作为一个“动态”集合，该对象与 NodeList 非常类似。</p>\n<p><strong>getElementsByName()</strong>方法会返回带有给定 name 特性的所有元素。最常使用 getElementsByName()方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的 name 特性。</p>\n<h3 id=\"Element类型\"><a href=\"#Element类型\" class=\"headerlink\" title=\"Element类型\"></a>Element类型</h3><p>Element 类型用 于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。像是我们取到的 div 节点都属于该类型</p>\n<h4 id=\"HTML元素\"><a href=\"#HTML元素\" class=\"headerlink\" title=\"HTML元素\"></a>HTML元素</h4><p>所有 HTML 元素都由 HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表 示。HTMLElement 类型直接继承自 Element 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。</p>\n<ul>\n<li>id，元素在文档中的唯一标识符</li>\n<li>title，有关元素的附加说明信息，一般通过工具提示条显示出来l</li>\n<li>lang，元素内容的语言代码，很少使用</li>\n<li>dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），也很少使用。</li>\n<li>className，与元素的 class 特性对应，即为元素指定的 CSS类。没有将这个属性命名为 class， 是因为 class 是 ECMAScript 的保留字</li>\n</ul>\n<p>所有的这些特性都可以通过 <strong>.</strong> 操作符来访问，就如同访问对象的属性一样</p>\n<p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的 DOM 方法主要有三个，分别是 getAttribute()、setAttribute()和 removeAttribute()，需要注意的是，特性的名称不区分大小写，同时根据HTML5的规范，自定义特性应该加上 data- 前缀以便验证。</p>\n<p>两个特殊点：使用上述方法访问style属性和onclick属性时，会返回相应的代码字符串，直接访问则会返回对应的对象</p>\n<p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作</p>\n<h2 id=\"代码最佳实践\"><a href=\"#代码最佳实践\" class=\"headerlink\" title=\"代码最佳实践\"></a>代码最佳实践</h2><h3 id=\"可维护的代码\"><a href=\"#可维护的代码\" class=\"headerlink\" title=\"可维护的代码\"></a>可维护的代码</h3><ul>\n<li><strong>可理解性</strong>——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释</li>\n<li><strong>直观性</strong>——代码中的东西一看就能明白，不管其操作过程多么复杂</li>\n<li><strong>可适应性</strong>——代码以一种数据上的变化不要求完全重写的方法撰写</li>\n<li><strong>可扩展性</strong>——在代码架构上已考虑到在未来允许对核心功能进行扩展</li>\n<li><strong>可调试性</strong>——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在</li>\n</ul>\n<h3 id=\"代码约定\"><a href=\"#代码约定\" class=\"headerlink\" title=\"代码约定\"></a>代码约定</h3><p>由于 JavaScript 的可适应性，代码约定对它也很重要。由于和大多数面向对象语言不同，JavaScript 并不强制开发人员将所有东西都定义为对象。语言可以支持各种编程风格，从传统面向对象式到声明式 到函数式。只要快速浏览一下一些开源 JavaScript 库，就能发现好几种创建对象、定义方法和管理环境的途径。</p>\n<p>因此一套成熟的代码约定能形成一份高可维护的代码，一般来说，代码约定有如下几个方面：</p>\n<ol>\n<li><strong>可读性</strong>：要让代码可维护，首先它必须可读。可读性的大部分内容都是和代码的缩进相关的。当所有人都使用一样的缩进方式时，整个项目中的代码都会更加易于阅读。通常会使用若干空格而非制表符来进行缩进，这是因为制表符在不同的文本编辑器中显示效果不同。可读性的另外一个方面是注释，一般来说，需要在以下地方有清晰的注释：<ul>\n<li><strong>函数和方法</strong>——每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法 </li>\n<li><strong>大段代码</strong>——用于完成单个任务的多行代码应该在前面放一个描述任务的注释</li>\n<li><strong>复杂的算法</strong>——如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的</li>\n<li><strong>Hack</strong>—- hack 所要应付的浏览器问题，请将这些信息放在注释中</li>\n</ul>\n</li>\n<li><strong>变量和函数命名</strong>：适当给变量和函数起名字对于增加代码可理解性和可维护性是非常重要的。一般的命名遵循以下原则：<ul>\n<li><strong>变量名应为名词</strong>，如 car 或 person</li>\n<li><strong>函数名应该以动词开始</strong>， 如 getName() 。返回布尔类型值的函数一般以 is 开头，如 isEnable()</li>\n<li><strong>变量和函数都应使用合乎逻辑的名字，不要担心长度</strong>。长度问题可以通过后处理和压缩来缓解</li>\n</ul>\n</li>\n<li><p><strong>变量类型透明</strong>：由于在 JavaScript 中变量是松散类型的，很容易就忘记变量所应包含的数据类型。有三种表示变量数据类型的方式：</p>\n<ul>\n<li><p>初始化</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过初始化指定变量类型 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>匈牙利标记法,JavaScript 中最传统的匈牙利标记法是用单个字符表示基本类型：”o”代表对象，”s”代表字符串，”i” 代表整数，”f”代表浮点数，”b”代表布尔型。如下所示：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于指定数据类型的匈牙利标记法 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bFound; <span class=\"comment\">//布尔型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iCount; <span class=\"comment\">//整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sName; <span class=\"comment\">//字符串</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oPerson; <span class=\"comment\">//对象</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类型注释</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于指定类型的类型注释 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> found <span class=\"comment\">/*:Boolean*/</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"comment\">/*:int*/</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name <span class=\"comment\">/*:String*/</span> = <span class=\"string\">\"Nicholas\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"comment\">/*:Object*/</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"尊重对象所有权\"><a href=\"#尊重对象所有权\" class=\"headerlink\" title=\"尊重对象所有权\"></a>尊重对象所有权</h3><p>简单来说就是你不能修改不属于你的对象。如果你不负责创建或维护某个对象、它的对象或它的方法，那么你就不应该对它进行修改，具体点来说：</p>\n<ul>\n<li>不要为实例或原型添加属性</li>\n<li>不要为实例或原型添加方法</li>\n<li>不要重定义已存在的方法</li>\n</ul>\n<p>这些规则不仅仅适用于自定义类型和对象，对于诸如 Object、String、document、window 等原生类型和对象也适用。此处潜在的问题可能更加危险，因为浏览器提供者可能会在不做宣布或者是不可预期的情况下更改这些对象</p>\n<p>值得注意的是，所谓拥有对象，就是说这个对象是你创建的，比如你自己创建的自定义类型或对象字面量。而 Array、document 这些显然不是你的，它们在你的代码执行前就存在了</p>\n<h3 id=\"避免全局变量\"><a href=\"#避免全局变量\" class=\"headerlink\" title=\"避免全局变量\"></a>避免全局变量</h3><p>有如下两段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"Nicholas\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(name); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MyApplication = &#123; </span><br><span class=\"line\">\tname: <span class=\"string\">\"Nicholas\"</span>, </span><br><span class=\"line\">\tsayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在第一段代码中，变量 name 覆盖了 window.name 属性，可能会与其他功能产生冲突；而重写之后的代码避免了这个问题，同时，它有助消除功能作用域之间的混淆。调用 MyApplication.sayName() 在逻辑上暗示了代码的任何问题都可以通过检查定义 MyApplication 的代码来确定。</p>\n<p>单一的全局量的延伸便是命名空间的概念，由 YUI（Yahoo! User Interface）库普及。命名空间包括创建一个用于放置功能的对象。在 YUI 的 2.x 版本中，有若干用于追加功能的命名空间。比如：</p>\n<ul>\n<li>YAHOO.util.Dom —— 处理 DOM 的方法</li>\n<li>YAHOO.util.Event —— 与事件交互的方法</li>\n<li>YAHOO.lang —— 用于底层语言特性的方法</li>\n</ul>\n<p>对于 YUI，单一的全局对象 YAHOO 作为一个容器，其中定义了其他对象。用这种方式将功能组合 在一起的对象，叫做命名空间。整个 YUI 库便是构建在这个概念上的，让它能够在同一个页面上与其他的 JavaScript 库共存</p>\n<h3 id=\"避免与null作比较\"><a href=\"#避免与null作比较\" class=\"headerlink\" title=\"避免与null作比较\"></a>避免与null作比较</h3><p>在与 null 作比较的时候，往往会发生我们不期望发生的结果。因为JavaScript是弱类型语言，类型比较不充分，如果需要进行类型比较，使用以下原则代替与 null 进行比较：</p>\n<ul>\n<li>如果值应为一个引用类型，使用 instanceof 操作符检查其构造函数</li>\n<li>如果值应为一个基本类型，使用 typeof 检查其类型</li>\n<li>如果是希望对象包含某个特定的方法名，则使用 typeof 操作符确保指定名字的方法存在于对象上</li>\n</ul>\n<h3 id=\"使用常量\"><a href=\"#使用常量\" class=\"headerlink\" title=\"使用常量\"></a>使用常量</h3><p>通过将数据抽取出来变成单独定义的常量的方式，将应用逻辑与数据修改隔离开来，这能够避免很多时候修改复杂逻辑中的数据带来的错误：</p>\n<ul>\n<li>重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变 的时候会造成的错误。这也包含了 CSS 类名</li>\n<li>用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化</li>\n<li>URLs —— 在 Web 应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的 URL</li>\n<li>任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量</li>\n</ul>\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><h3 id=\"避免全局查找\"><a href=\"#避免全局查找\" class=\"headerlink\" title=\"避免全局查找\"></a>避免全局查找</h3><p>在规模较大的web应用中，会创建出许多作用域，此时访问当前作用域以外的变量的时间也在增加。因为需要遍历作用域链，所以要尽量避免使用全局作用域下的变量</p>\n<h3 id=\"使用正确的方法\"><a href=\"#使用正确的方法\" class=\"headerlink\" title=\"使用正确的方法\"></a>使用正确的方法</h3><p>即在相应的问题下，采用正确的算法，尽量做到使用最优的时间复杂度和空间复杂度来解决当前问题，其中有一点需要注意<strong>使用变量和数组要比访问对象上的属性更有效率</strong>，前者是一个O(1)的操作，而后者是一个 O(n)操作</p>\n<h3 id=\"优化循环\"><a href=\"#优化循环\" class=\"headerlink\" title=\"优化循环\"></a>优化循环</h3><p>一个循环的基本优化步骤如下所示：</p>\n<ol>\n<li>减值迭代——大多数循环使用一个从 0 开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效</li>\n<li>简化终止条件——由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说 避免属性查找或其他 O(n)的操作</li>\n<li>简化循环体——循环体是执行最多的，所以要确保其被最大限度地优化。确保没有某些可以被 很容易移出循环的密集计算</li>\n<li>使用后测试循环——最常用 for 循环和 while 循环都是前测试循环。而如 do-while 这种后测试循环，可以避免最初终止条件的计算，因此运行更快</li>\n</ol>\n<p>此外，如果循环次数是确定的，那么展开循环，改用重复调用某个函数来解决问题，可能结果会更快</p>\n<h3 id=\"避免双重解释\"><a href=\"#避免双重解释\" class=\"headerlink\" title=\"避免双重解释\"></a>避免双重解释</h3><p>代码在运行之前需要经过解析，而如果在解析时遇到了 字符串中的代码 就会存在双重解释惩罚，例如：</p>\n<pre><code>var sayHi = new Function(&quot;alert(&apos;Hello world!&apos;)&quot;);\n</code></pre><p>在以上的例子中，要解析包含了 JavaScript 代码的字符串。这个操作是不能在初始的解析过程中完成的，因为代码是包含在字符串中的，也就是说在 JavaScript 代码运行的同时必须新启动一个解析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多</p>\n<h3 id=\"最小化语句数\"><a href=\"#最小化语句数\" class=\"headerlink\" title=\"最小化语句数\"></a>最小化语句数</h3><p>多个变量声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">5</span>,</span><br><span class=\"line\">\tcolor = <span class=\"string\">\"blue\"</span>,</span><br><span class=\"line\">\tvalues = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\">\tnow = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br></pre></td></tr></table></figure>\n<p>插入迭代值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = values[i]; </span><br><span class=\"line\">i++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = values[i++];</span><br></pre></td></tr></table></figure>\n<h3 id=\"优化DOM交互\"><a href=\"#优化DOM交互\" class=\"headerlink\" title=\"优化DOM交互\"></a>优化DOM交互</h3><p><strong>利用文档片段减少现场更新</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myList\"</span>),</span><br><span class=\"line\">    fragment = <span class=\"built_in\">document</span>.createDocumentFragment(), </span><br><span class=\"line\">    item, </span><br><span class=\"line\">    i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123; </span><br><span class=\"line\">\titem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>); </span><br><span class=\"line\">\tfragment.appendChild(item);</span><br><span class=\"line\">\titem.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i)); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">list.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p>上面这段代码插入了一个ul列表，如果每次单个插入，需要更新至少10次DOM结构，使用文档片段整合后，只需要更新一次</p>\n<p><strong>使用innerHTML</strong> — 有两种在页面上创建 DOM 节点的方法：使用诸如 createElement()和 appendChild()之类的 DOM 方法，以及使用 innerHTML。对于小的 DOM 更改而言，两种方法效率都差不多。然而，对于大的 DOM 更改，使用 innerHTML 要比使用标准 DOM 方法创建同样的 DOM 结构快得多。</p>\n<p>当把 innerHTML 设置为某个值时，后台会创建一个 HTML 解析器，然后使用内部的 DOM 调用来 创建 DOM 结构，而非基于 JavaScript 的 DOM 调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。</p>\n<p><strong>使用事件代理</strong></p>\n<p><strong>注意HTMLCollection</strong> — 例如 childNodes 的长度应该存入变量后再访问，而不是在 for 循环中每次都去访问</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>这个系列的文章初衷是为了让自己能够记录下啃红皮书的过程，虽然一遍阅读没有读的很完整，仅仅记录了一些自己觉得重要的东西，而且大篇幅是书中的内容，但是也有了自己以后供自己查阅的资料，算是一次小小的记录，再接再厉，砥砺前行。</p>\n","categories":["技术"],"tags":["JavaScript"]},{"title":"JS高级程序设计读书笔记(中)","url":"https://teobler.com/20170810-professional-JavaScript-notes-2.html","content":"<h2 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h2><h3 id=\"概念与特征\"><a href=\"#概念与特征\" class=\"headerlink\" title=\"概念与特征\"></a>概念与特征</h3><p>关于函数，我们知道定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。函数声明的语法是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">functionName</span>(<span class=\"params\">arg0, arg1, arg2</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//函数体 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于函数声明，它的一个重要特征就是函数声明提升，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHi(); </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    alert(<span class=\"string\">\"Hi!\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> functionName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg0, arg1, arg2</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//函数体 </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 functionName。 这种情况下创建的函数叫做匿名函数，因为 function 关键字后面没有标识符。匿名函数的 name 属性是空字符串。</p>\n<p>函数表达式没有变量提升，也就是说在使用前必须赋值，如果像上述函数声明那样直接使用的话，就会报错。</p>\n<p>有一点需要注意的是，在 ES5 中，严格模式下，函数的声明只能在全局作用域或者函数内，其他块（if, for）都会报错。但是函数表达式就没有这样的限制，究其原因，还是因为变量提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如下代码ES5中都会报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;……&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 报错，ES6中不报错，是因为ES6支持了块作用域，所以在块作用域中声明函数是合理的。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于递归\"><a href=\"#关于递归\" class=\"headerlink\" title=\"关于递归\"></a>关于递归</h3><p>在使用函数声明进行递归调用时，如果操作不当，可能会发生错误：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">num</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>)&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * factorial(num<span class=\"number\">-1</span>); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherFactorial = factorial;</span><br><span class=\"line\">factorial = <span class=\"literal\">null</span>; </span><br><span class=\"line\">alert(anotherFactorial(<span class=\"number\">4</span>)); <span class=\"comment\">//出错！</span></span><br></pre></td></tr></table></figure>\n<p>虽然可以在函数声明时使用arguments.callee解决这个问题，但是在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误，所以，我们可以用函数表达式来解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factorial = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">num</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &lt;= <span class=\"number\">1</span>)&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> num * f(num<span class=\"number\">-1</span>); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数 赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和 非严格模式下都行得通。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包这个概念总是让一部分开发人员摸不着头脑，不少开发人员也会搞混匿名函数与闭包的概念，因此经常混用。我们先来看一下高程是怎么解释闭包的概念的：</p>\n<blockquote>\n<p><strong>闭包</strong>是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数</p>\n</blockquote>\n<p>我们先来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createComparisonFunction</span>(<span class=\"params\">propertyName</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">object1, object2</span>)</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> value1 = object1[propertyName];</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> value2 = object2[propertyName];</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (value1 &lt; value2)&#123; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，value1 和 value2 是内部函数（一个匿名函数）中的代码，这两行代码访问了外部函数中的变量 propertyName。即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量 propertyName 。之所以还能够访问这个变量，是因为内部函数的作用域链中包含 createComparisonFunction()的作用域。</p>\n<p>而为了理解清楚闭包的原理，我们有必要理解清楚作用域与作用域链的问题</p>\n<h4 id=\"作用域与作用域链\"><a href=\"#作用域与作用域链\" class=\"headerlink\" title=\"作用域与作用域链\"></a>作用域与作用域链</h4><p>我们先理清几个概念：</p>\n<ul>\n<li>执行环境(执行上下文)</li>\n<li>执行环境栈(执行上下文栈)</li>\n<li>变量对象</li>\n<li>活动对象</li>\n<li>作用域链</li>\n</ul>\n<h5 id=\"执行环境-执行上下文\"><a href=\"#执行环境-执行上下文\" class=\"headerlink\" title=\"执行环境(执行上下文)\"></a>执行环境(执行上下文)</h5><p>每当浏览器在转到可执行代码的时候，就会创造一个执行上下文：</p>\n<p><strong>全局代码：</strong></p>\n<p>全局代码不包含任何函数体内的代码，这个执行环境是默认的执行环境，一旦代码被载入，引擎最先进入的就是这个环境</p>\n<p><strong>函数代码：</strong></p>\n<p>任何一个函数体内的代码都是函数代码，需要注意的是，具体的函数代码不会包含<strong>该函数内部</strong>函数的代码</p>\n<h5 id=\"执行环境栈-执行上下文栈\"><a href=\"#执行环境栈-执行上下文栈\" class=\"headerlink\" title=\"执行环境栈(执行上下文栈)\"></a>执行环境栈(执行上下文栈)</h5><p>我们看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'begin:'</span> + i);</span><br><span class=\"line\">  foo(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'end:'</span> + i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// begin:2</span></span><br><span class=\"line\"><span class=\"comment\">// begin:1</span></span><br><span class=\"line\"><span class=\"comment\">// begin:0</span></span><br><span class=\"line\"><span class=\"comment\">// end:0</span></span><br><span class=\"line\"><span class=\"comment\">// end:1</span></span><br><span class=\"line\"><span class=\"comment\">// end:2</span></span><br></pre></td></tr></table></figure>\n<p>由于js是单线程的，也就是说在同一时间内只会执行一行代码或者说一个函数，其他的后续代码会被放入执行栈中排队</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/ECS-1.jpeg\" alt=\"\"></p>\n<blockquote>\n<p>当浏览器首次载入你的脚本，它将默认进入全局执行上下文。如果，你在你的全局代码中调用一个函数，你程序的时序将进入被调用的函数，并创建一个新的执行上下文，并将新创建的上下文压入执行栈的顶部。</p>\n<p>如果你调用当前函数内部的其他函数，相同的事情会在此上演。代码的执行流程进入内部函数，创建一个新的执行上下文并把它压入执行栈的顶部。浏览器总会执行位于栈顶的执行上下文，一旦当前上下文函数执行结束，它将被从栈顶弹出，并将上下文控制权交给当前的栈。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。</p>\n</blockquote>\n<h5 id=\"变量对象\"><a href=\"#变量对象\" class=\"headerlink\" title=\"变量对象\"></a>变量对象</h5><p>JS的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标示符、形参、变量声明等。它们会被挂在这个对象上，对象的属性对应它们的名字，对象属性的值对应它们的值。但这个对象是规范上或者说是引擎实现上的不可在JS环境中访问到的</p>\n<h5 id=\"活动对象\"><a href=\"#活动对象\" class=\"headerlink\" title=\"活动对象\"></a>活动对象</h5><p>有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活，也就是该上下文中的函数标示符、形参、变量声明等就可以被访问到了，此时变量对象就变成了活动对象，活动对象在函数执行完毕后就会被销毁（闭包函数所引用的函数活动对象除外）</p>\n<h5 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h5><p>我们先看高程上的一个概念：</p>\n<blockquote>\n<p>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。 然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。</p>\n</blockquote>\n<p>一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compare(value1, value2)&#123; </span><br><span class=\"line\">\tif (value1 &lt; value2)&#123; </span><br><span class=\"line\">\t\treturn -1; </span><br><span class=\"line\">\t&#125; else if (value1 &gt; value2)&#123; </span><br><span class=\"line\">\t\treturn 1; </span><br><span class=\"line\">\t&#125; else &#123; </span><br><span class=\"line\">\t\treturn 0; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">var result = compare(5, 10);</span><br></pre></td></tr></table></figure>\n<p>以上代码先定义了一个compare函数，然后再全局作用域调用了它。当第一次调用compare()时，会创建一个包含this、arguments、valuel1 和value2的活动对象。全局执行环境的变量对象，其中又包含有：this、result、和compare。compare函数执行时，有这样一个作用域链，其中compare()自身的活动对象处于第一位，全局执行环境的变量对象处于第二位：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/compare-execution.png\" alt=\"\"></p>\n<p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像 compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建 compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用 compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中 compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>\n<h5 id=\"内存泄漏问题\"><a href=\"#内存泄漏问题\" class=\"headerlink\" title=\"内存泄漏问题\"></a>内存泄漏问题</h5><p>由于闭包在使用时会一直引用作用域链中的活动对象，如果不及时进行无用闭包的内存释放，同时又大量使用了闭包的话，就有可能造成内存泄漏，虽然大多数现代浏览器会引擎会尝试回收被闭包占用的内存，但是毕竟也还是会有回收不到的情况，况且还有一些比较蠢的浏览器是不会进行回收的。所以在使用闭包时需要程序员考虑是否必须使用闭包，是否有可以替代的方法，同时使用闭包过后需要及时进行内存回收。</p>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3><blockquote>\n<p>事件流描述的是从页面中接收事件的顺序</p>\n</blockquote>\n<p>需要注意的是，事件流有截然相反的两种概念，一个是事件冒泡流，一个是事件捕获流</p>\n<p><strong>事件冒泡</strong></p>\n<p>事件冒泡流的事件首先在具体事件上发生，之后事件沿DOM树向上传播，在每一级节点上都会发生，直至传播到document对象：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/event-bubbling.png\" alt=\"\"></p>\n<p><strong>事件捕获</strong></p>\n<p>事件捕获与事件冒泡截然相反，事件首先在document对象上发生，然后沿DOM树依次向下，一直传播到事件目标：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/event-capturing.png\" alt=\"\"></p>\n<p>由于老版本的浏览器不支持事件捕获，所以在兼容性上，事件冒泡要优于事件簿或</p>\n<p><strong>DOM事件流</strong></p>\n<p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获、处于目标、事件冒泡</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/DOM-event-stream.png\" alt=\"\"></p>\n<p>首先发生的是事件捕获，为事件的截取提供了机会，然后是目标事件发生，最后一个阶段是冒泡。需要注意的是，规范规定处于目标这个阶段被看做事件冒泡的一部分，在事件捕获阶段不会捕获到处于目标这个层级。但是各个浏览器的高版本都会在捕获阶段触发事件对象上的事件。结果就是有两次机会来处理目标事件。</p>\n<h3 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h3><h4 id=\"DOM0级事件处理程序\"><a href=\"#DOM0级事件处理程序\" class=\"headerlink\" title=\"DOM0级事件处理程序\"></a>DOM0级事件处理程序</h4><p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这 种为事件处理程序赋值的方法是在第四代 Web 浏览器中出现的，而且至今仍然为所有现代浏览器所支 持。原因一是简单，二是具有跨浏览器的优势。要使用 JavaScript 指定事件处理程序，首先必须取得一个要操作的对象的引用。</p>\n<p>每个元素（包括 window 和 document）都有自己的事件处理程序属性，这些属性通常全部小写， 例如 onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"string\">\"Clicked\"</span>); </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用 DOM0 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在 元素的作用域中运行；换句话说，程序中的 this 引用当前元素。来看一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span>.id); <span class=\"comment\">//\"myBtn\" </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理</strong></p>\n<h4 id=\"DOM2级事件处理程序\"><a href=\"#DOM2级事件处理程序\" class=\"headerlink\" title=\"DOM2级事件处理程序\"></a>DOM2级事件处理程序</h4><p>“DOM2 级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener() 和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处 理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获 阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p>\n<p>要在按钮上为 click 事件添加事件处理程序，可以使用下列代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span>.id); </span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Hello world!\"</span>); </span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>使用DOM2级事件的好处是可以同时添加多个事件，触发顺序为定义时的顺序</p>\n<p>通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除；移 除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 addEventListener()添加的匿名函数将无法移除，例如上面例子中的两个事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span>.id); </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">btn.addEventListener(<span class=\"string\">\"click\"</span>, handler, <span class=\"literal\">false</span>);</span><br><span class=\"line\">btn.removeEventListener(<span class=\"string\">\"click\"</span>, handler, <span class=\"literal\">false</span>); <span class=\"comment\">//有效！</span></span><br></pre></td></tr></table></figure>\n<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览 器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需 要，我们不建议在事件捕获阶段注册事件处理程序。</p>\n<h4 id=\"IE事件处理程序\"><a href=\"#IE事件处理程序\" class=\"headerlink\" title=\"IE事件处理程序\"></a>IE事件处理程序</h4><p>众所周知，IE有毒，所以在事件处理上也有体现，IE 实现了与 DOM 中类似的两个方法：attachEvent()和 detachEvent()。这两个方法接受相同 的两个参数：事件处理程序名称与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过 attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</p>\n<p>要使用 attachEvent()为按钮添加事件处理程序，可以使用以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\">btn.attachEvent(<span class=\"string\">\"onclick\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"string\">\"Clicked\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">btn.attachEvent(<span class=\"string\">\"onclick\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\talert(<span class=\"string\">\"Hello world!\"</span>); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里需要注意几个问题：</p>\n<ul>\n<li>attachEvent()的第一个参数是”onclick”，而非 DOM 的 addEventListener()方法中 的 “click”</li>\n<li>在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此 this 分别指向 当前元素 和 window。</li>\n</ul>\n<p>与 addEventListener()类似，attachEvent()方法也可以用来为一个元素添加多个事件处理程序，同样的，也无法取消一个匿名函数的事件</p>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的 信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件 对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有 浏览器都支持 event 对象，但支持方式不同。</p>\n<h4 id=\"DOM事件对象\"><a href=\"#DOM事件对象\" class=\"headerlink\" title=\"DOM事件对象\"></a>DOM事件对象</h4><p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什 么方法（DOM0 级或 DOM2 级），都会传入 event 对象。来看下面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\talert(event.type); <span class=\"comment\">//\"click\" </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在通过 HTML 特性指定事件处理程序时，变量 event 中保存着 event 对象。请看下面的例子。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Click Me\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"alert(event.type)\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>下图中列出了event对象的所有属性和说明</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/event-object-1.png\" alt=\"\"></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/event-object-2.png\" alt=\"\"></p>\n<p>其中需要重点区别三个属性</p>\n<ul>\n<li>currentTarget属性指的是事件处理程序正在处理的那个元素，即处理事件的元素，this将始终指向currentTarget</li>\n<li>target是指事件的目标，例如被点击的元素</li>\n</ul>\n<p>我们来看两个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">\talert(event.currentTarget === <span class=\"keyword\">this</span>);  <span class=\"comment\">//true </span></span><br><span class=\"line\">\talert(event.target === <span class=\"keyword\">this</span>);  <span class=\"comment\">//true </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果直接将事件处理程序指定给了目标元素，则 this、currentTarget 和 target 包含相同的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\talert(event.currentTarget === <span class=\"built_in\">document</span>.body); <span class=\"comment\">//true </span></span><br><span class=\"line\">\talert(<span class=\"keyword\">this</span> === <span class=\"built_in\">document</span>.body); <span class=\"comment\">//true </span></span><br><span class=\"line\">\talert(event.target === <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果事件处理程序存在于按钮的父节点中（例如 document.body），那么这些值是不相同的。当单击这个例子中的按钮时，this 和 currentTarget 都等于 document.body，因为事件处理程 序是注册到这个元素上的。然而，target 元素却等于按钮元素，因为它是 click 事件真正的目标。由 于按钮上并没有注册事件处理程序，结果 click 事件就冒泡到了 document.body，在那里事件才得到了处理。</p>\n<h4 id=\"IE中的事件对象\"><a href=\"#IE中的事件对象\" class=\"headerlink\" title=\"IE中的事件对象\"></a>IE中的事件对象</h4><p>在IE中使用DOM0级方法定义时，event对象作为window对象的一个属性存在：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">\talert(event.type); <span class=\"comment\">//\"click\" </span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果是通过 HTML特性指定的事件处理程序,则与之前的DOM事件相同</p>\n<p>下表列出了IE的event属性与方法：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/IE-event-object.png\" alt=\"\"></p>\n<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为 this 会始终等于事件目 标。故而，最好还是使用 event.srcElement 比较保险。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myBtn\"</span>); </span><br><span class=\"line\">btn.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"built_in\">window</span>.event.srcElement === <span class=\"keyword\">this</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">btn.attachEvent(<span class=\"string\">\"onclick\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\talert(event.srcElement === <span class=\"keyword\">this</span>);  <span class=\"comment\">//false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意 — 由于 IE 不支持事件捕获，因而只能取消事件冒泡</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><h4 id=\"UI事件\"><a href=\"#UI事件\" class=\"headerlink\" title=\"UI事件\"></a>UI事件</h4><p>UI 事件指的是那些不一定与用户操作有关的事件。这些事件在 DOM 规范出现之前，都是以这种或 那种形式存在的，而在 DOM 规范中保留是为了向后兼容。现有的 UI 事件如下：</p>\n<ul>\n<li>DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在 DOM3 级事件中被废弃，但 Firefox 2+和 Chrome 支持它。考虑到不同浏览器实现的差异，不建议使用这个事件</li>\n<li>load：当页面完全加载后在 window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在<code>&lt;img&gt;</code>元素上面触发，或者当嵌入的内容加载完毕时在<code>&lt;object&gt;</code>元素上面触发</li>\n<li>unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或 者当嵌入的内容卸载完毕后在<code>&lt;object&gt;</code>元素上面触发</li>\n<li>abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<code>&lt;object&gt;</code>元素上面触发</li>\n<li>error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在<code>&lt;img&gt;</code>元素上面触发，当无法加载嵌入内容时在<code>&lt;object&gt;</code>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发</li>\n<li>select：当用户选择文本框（<code>&lt;input&gt;</code>或<code>&lt;texterea&gt;</code>）中的一或多个字符时触发</li>\n<li>resize：当窗口或框架的大小变化时在 window 或框架上面触发</li>\n<li>scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<code>&lt;body&gt;</code>元素中包含所加载页面的滚动条</li>\n</ul>\n<h4 id=\"焦点事件\"><a href=\"#焦点事件\" class=\"headerlink\" title=\"焦点事件\"></a>焦点事件</h4><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus()方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪。</p>\n<ul>\n<li>blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它</li>\n<li>DOMFocusIn：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。只有 Opera 支持这个事件。DOM3 级事件废弃了 DOMFocusIn，选择了 focusin</li>\n<li>DOMFocusOut：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。只有 Opera 支持这个事件。DOM3 级事件废弃了 DOMFocusOut，选择了 focusout</li>\n<li>focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它</li>\n<li>focusin：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome</li>\n<li>focusout：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版本。支持这个事件 的浏览器有 IE5.5+、Safari 5.1+、Opera 11.5+和 Chrome</li>\n</ul>\n<p>这一类事件中最主要的两个是 focus 和 blur，它们都是 JavaScript 早期就得到所有浏览器支持的 事件。这些事件的最大问题是它们不冒泡。因此，IE 的 focusin 和 focusout 与 Opera 的 DOMFocusIn 和 DOMFocusOut 才会发生重叠。IE 的方式最后被 DOM3 级事件采纳为标准方式。 当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：</p>\n<ol>\n<li>focusout 在失去焦点的元素上触发；</li>\n<li>focusin 在获得焦点的元素上触发；</li>\n<li>blur 在失去焦点的元素上触发；</li>\n<li>DOMFocusOut 在失去焦点的元素上触发；</li>\n<li>focus 在获得焦点的元素上触发；</li>\n<li>DOMFocusIn 在获得焦点的元素上触发。</li>\n</ol>\n<h4 id=\"鼠标与滚轮事件\"><a href=\"#鼠标与滚轮事件\" class=\"headerlink\" title=\"鼠标与滚轮事件\"></a>鼠标与滚轮事件</h4><p>鼠标事件是 Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。DOM3 级事件中定 义了 9 个鼠标事件，简介如下：</p>\n<ul>\n<li>click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保 易访问性很重要，意味着 onclick 事件处理程序既可以通过键盘也可以通过鼠标执行</li>\n<li>dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不 是 DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以 DOM3 级事件将其纳入了标准</li>\n<li>mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件</li>\n<li>mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它 纳入了规范。IE、Firefox 9+和 Opera 支持这个事件</li>\n<li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且 在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但 DOM3 级事件将它 纳入了规范。IE、Firefox 9+和 Opera 支持这个事件</li>\n<li>mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件</li>\n<li>mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另 一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件</li>\n<li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件</li>\n<li>mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件</li>\n</ul>\n<p>只有在同一个元素上相继触发 mousedown 和 mouseup 事件， 才会触发 click 事件；如果 mousedown 或 mouseup 中的一个被取消，就不会触发 click 事件。类似地，只有触发两次 click 事 件，才会触发一次 dblclick 事件。如果有代码阻止了连续两次触发 click 事件（可能是直接取消 click 事件，也可能通过取消 mousedown 或 mouseup 间接实现），那么就不会触发 dblclick 事件了。这 4 个事件触发的顺序始终如下：</p>\n<ol>\n<li>mousedown</li>\n<li>mouseup</li>\n<li>click</li>\n<li>mousedown</li>\n<li>mouseup</li>\n<li>click</li>\n<li>dblclick </li>\n</ol>\n<p>显然，click 和 dblclick 事件都会依赖于其他先行事件的触发；而 mousedown 和 mouseup 则 不受其他事件的影响。 IE8 及之前版本中的实现有一个小 bug，因此在双击事件中，会跳过第二个 mousedown 和 click 事件，其顺序如下：</p>\n<ol>\n<li>mousedown</li>\n<li>mouseup</li>\n<li>click</li>\n<li>mouseup</li>\n<li>dblclick </li>\n</ol>\n<p>IE9 修复了这个 bug，之后顺序就正确了</p>\n<h4 id=\"键盘与文本事件\"><a href=\"#键盘与文本事件\" class=\"headerlink\" title=\"键盘与文本事件\"></a>键盘与文本事件</h4><p>“DOM3 级事件”为键盘事件制定了规范，IE9 率先完全实现了该规范。其他浏览器也在着手实现这 一标准，但仍然有很多遗留的问题。 有 3 个键盘事件，简述如下：</p>\n<ul>\n<li>keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件</li>\n<li>keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。 按下 Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发 keypress 事件</li>\n<li>keyup：当用户释放键盘上的键时触发</li>\n</ul>\n<p>只有一个文本事件：textInput。这个事件是对 keypress 的补充，用意是在将文本显示给用户之 前更容易拦截文本。在文本插入文本框之前会触发 textInput 事件。</p>\n<h4 id=\"复合事件\"><a href=\"#复合事件\" class=\"headerlink\" title=\"复合事件\"></a>复合事件</h4><p>复合事件（composition event）是 DOM3 级事件中新添加的一类事件，用于处理 IME 的输入序列。 IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。例如，使用拉 丁文键盘的用户通过 IME 照样能输入日文字符。IME 通常需要同时按住多个键，但最终只输入一个字 符。复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件：</p>\n<ul>\n<li>compositionstart：在 IME 的文本复合系统打开时触发，表示要开始输入了</li>\n<li>compositionupdate：在向输入字段中插入新字符时触发</li>\n<li>compositionend：在 IME 的文本复合系统关闭时触发，表示返回正常键盘输入状态。 复合事件与文本事件在很多方面都很相似。在触发复合事件时，目标是接收文本的输入字段。但它比文本事件的事件对象多一个属性 data，其中包含以下几个值中的一个<ul>\n<li>如果在 compositionstart 事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马 上替换的文本</li>\n<li>如果在 compositionupdate 事件发生时访问，包含正插入的新字符</li>\n<li>如果在 compositionend 事件发生时访问，包含此次输入会话中插入的所有字符。 与文本事件一样，必要时可以利用复合事件来筛选输入</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"变动事件\"><a href=\"#变动事件\" class=\"headerlink\" title=\"变动事件\"></a>变动事件</h4><p>DOM2 级的变动（mutation）事件能在 DOM 中的某一部分发生变化时给出提示。变动事件是为 XML 或 HTML DOM 设计的，并不特定于某种语言。DOM2 级定义了如下变动事件：</p>\n<ul>\n<li>DOMSubtreeModified：在 DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发 后都会触发</li>\n<li>DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发</li>\n<li>DOMNodeRemoved：在节点从其父节点中被移除时触发</li>\n<li>DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后 触发。这个事件在 DOMNodeInserted 之后触发</li>\n<li>DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移 除之前触发。这个事件在 DOMNodeRemoved 之后触发</li>\n<li>DOMAttrModified：在特性被修改之后触发</li>\n<li>DOMCharacterDataModified：在文本节点的值发生变化时触发</li>\n</ul>\n<h4 id=\"HTML5-事件（部分）\"><a href=\"#HTML5-事件（部分）\" class=\"headerlink\" title=\"HTML5 事件（部分）\"></a>HTML5 事件（部分）</h4><ul>\n<li><p>contextmenu 事件</p>\n<p>  Windows 95 在 PC 中引入了上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单。不久， 这个概念也被引入了 Web 领域。为了实现上下文菜单，开发人员面临的主要问题是如何确定应该显示 上下文菜单（在 Windows 中，是右键单击；在 Mac 中，是 Ctrl+单击），以及如何屏蔽与该操作关联的 默认上下文菜单。为解决这个问题，就出现了 contextmenu 这个事件，用以表示何时应该显示上下文 菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单</p>\n</li>\n<li><p>DOMContentLoaded 事件</p>\n<p>  window 的 load 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要 加载的外部资源过多而颇费周折。而 DOMContentLoaded 事件则在形成完整的 DOM 树之后就会触发， 不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。 与 load 事件不同，DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互</p>\n</li>\n<li><p>readystatechange 事件</p>\n<p>  IE 为 DOM 文档中的某些部分提供了 readystatechange 事件。这个事件的目的是提供与文档或 元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。支持 readystatechange 事件的 每个对象都有一个 readyState 属性，可能包含下列 5 个值中的一个</p>\n<ul>\n<li>uninitialized（未初始化）：对象存在但尚未初始化</li>\n<li>loading（正在加载）：对象正在加载数据</li>\n<li>loaded（加载完毕）：对象加载数据完成</li>\n<li>interactive（交互）：可以操作对象了，但还没有完全加载</li>\n<li>complete（完成）：对象已经加载完毕</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><p>对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事 件处理程序，就可以管理某一类型的所有事件。例如，click 事件会一直冒泡到 document 层次。也就 是说，我们可以为整个页面指定一个 onclick 事件处理程序，而不必给每个可单击的元素分别添加事 件处理程序。以下面的 HTML 代码为例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myLinks\"</span>&gt;</span> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">\"goSomewhere\"</span>&gt;</span>Go somewhere<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sayHi\"</span>&gt;</span>Say hi<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中包含 3 个被单击后会执行操作的列表项。按照传统的做法，需要像下面这样为它们添加 3 个事件处理程序:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> item1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"goSomewhere\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> item2 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"doSomething\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> item3 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"sayHi\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EventUtil.addHandler(item1, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\tlocation.href = <span class=\"string\">\"http://www.wrox.com\"</span>; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">EventUtil.addHandler(item2, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.title = <span class=\"string\">\"I changed the document's title\"</span>; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">EventUtil.addHandler(item3, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\talert(<span class=\"string\">\"hi\"</span>); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果在一个复杂的 Web 应用程序中，对所有可单击的元素都采用这种方式，那么结果就会有数不 清的代码用于添加事件处理程序。此时，可以利用事件委托技术解决这个问题。使用事件委托，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"myLinks\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EventUtil.addHandler(list, <span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">\tevent = EventUtil.getEvent(event); </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> target = EventUtil.getTarget(event);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(target.id)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"doSomething\"</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">document</span>.title = <span class=\"string\">\"I changed the document's title\"</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"goSomewhere\"</span>:</span><br><span class=\"line\">\t\tlocation.href = <span class=\"string\">\"http://www.wrox.com\"</span>; </span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"sayHi\"</span>:</span><br><span class=\"line\">\t\talert(<span class=\"string\">\"hi\"</span>); </span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果可行的话，也可以考虑为 document 对象添加一个事件处理程序，用以处理页面上发生的某种 特定类型的事件。这样做与采取传统的做法相比具有如下优点:</p>\n<ul>\n<li>document 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序 （无需等待 DOMContentLoaded 或 load 事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能</li>\n<li>在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 DOM 引用更少，所花的时间也更少</li>\n<li>整个页面占用的内存空间更少，能够提升整体性能</li>\n</ul>\n","categories":["技术"],"tags":["JavaScript"]},{"title":"JS高级程序设计读书笔记(上)","url":"https://teobler.com/20170730-professional-JavaScript-notes-1.html","content":"<p>这篇内容会比较杂比较长，纯属为了自己以后的复习查阅，也算是自己串一遍自己认为比较重要的知识点，复习复习</p>\n<h2 id=\"js基本的数据类型\"><a href=\"#js基本的数据类型\" class=\"headerlink\" title=\"js基本的数据类型\"></a>js基本的数据类型</h2><p>js有6中基本数据类型</p>\n<ol>\n<li>undefined </li>\n<li>null</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol</li>\n</ol>\n<p>再加上一种复杂数据类型 — object</p>\n<p>typeof操作符可以返回目标操作数的数据类型，分别为</p>\n<ol>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol</li>\n<li>function (从技术角度来讲函数也是对象，但是函数也有一些特殊的属性，所以有必要将其与一般的对象区别开来)</li>\n<li>object (null被看做是一个空对象的引用)</li>\n</ol>\n<h2 id=\"编程语言通性\"><a href=\"#编程语言通性\" class=\"headerlink\" title=\"编程语言通性\"></a>编程语言通性</h2><p>例如各种操作符，循环判断语句，函数等，列举几个js的特殊点</p>\n<h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符\"></a>相等操作符</h3><p>首先是 ‘==’ 与 ‘===’ 的区别，前者为相等操作符，后者为全等操作符。相等操作符进行判断时，会将等号两边不同类型的数据进行一系列转换后再进行比较，如果相等则返回true；后者则不进行转换直接进行比较，其只有在两个操作数未经转换就相等才会返回true(‘!=’与’!===’亦然)</p>\n<p>‘==’转换比较规则:</p>\n<ul>\n<li>如果两个操作数都是数值，则执行数值比较</li>\n<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li>\n<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较</li>\n<li>如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执 行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面 的规则执行比较</li>\n<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较</li>\n</ul>\n<p>也正是由于相等运算符这个特点，会造成一些我们不希望发生的意外比较，同时也让代码阅读和维护产生疑惑，所以<strong>大部分情况建议使用严格相等运算符</strong></p>\n<h3 id=\"位操作符\"><a href=\"#位操作符\" class=\"headerlink\" title=\"位操作符\"></a>位操作符</h3><p>js中的位操作与其他高级语言并没有太大的不同，需要注意的是js的数值存储方式：</p>\n<ul>\n<li>在js中，数值以<strong>64位</strong>进行存储，在进行位操作时。会先将64位的数<strong>转换成32位</strong>，操作结束后<strong>再转换成64位</strong></li>\n<li>对于有符号数来说，首位为符号位，0为正1为负，没有用到的位使用符号位的数值进行填充</li>\n<li>负数使用补码表示，即该数的绝对值求二进制，然后取反，只有加1</li>\n<li>位运算将 NaN 与 Infiniti 看做 0</li>\n<li>当直接输出二进制数时，js会向人们隐藏这些底层存储，转换为人们较为习惯的方式表现出来，如 将-18转换为二进制输出，为 -10010</li>\n</ul>\n<h3 id=\"关于函数\"><a href=\"#关于函数\" class=\"headerlink\" title=\"关于函数\"></a>关于函数</h3><ul>\n<li>在js中，参数在函数内部是使用<strong>类数组对象arguments</strong>来表示的。函数接收到的始终是这个数组，也不关心数组中包含哪些参数</li>\n<li>由于函数不关心传递参数的个数，所以在js中如果一个函数需要3个函数，如果你只传递了2个，js不会像java那样报错，而是会将未传递的参数默认设置为undefined</li>\n<li>也正是由于上述的原因，js的函数没有重载，如果一个函数被定义了两次，那么后定义的函数会覆盖掉前面定义的函数</li>\n</ul>\n<h2 id=\"变量、作用域与内存\"><a href=\"#变量、作用域与内存\" class=\"headerlink\" title=\"变量、作用域与内存\"></a>变量、作用域与内存</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><ul>\n<li>在js中，变量分为基本类型(undefined、null、boolean、number和string)和引用类型</li>\n</ul>\n<h4 id=\"存储类型\"><a href=\"#存储类型\" class=\"headerlink\" title=\"存储类型\"></a>存储类型</h4><ul>\n<li>在操作基本类型时，<strong>直接操作保存在变量中的值</strong>，即基本类型的变量值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 — 栈中。这样存储便于迅速查寻变量的值</li>\n<li>在操作引用类型时，操作的是<strong>对象的引用而不是实际的对象</strong>，即该对象保存的是对象在内存堆中的地址(因为js不允许直接访问内存中的位置)，而栈中保存的是该地址的一个指针(地址大小是固定不变的，对于变量性能无影响)</li>\n</ul>\n<h4 id=\"访问机制\"><a href=\"#访问机制\" class=\"headerlink\" title=\"访问机制\"></a>访问机制</h4><p>在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。而原始类型的值则是可以直接访问到的</p>\n<h4 id=\"复制变量\"><a href=\"#复制变量\" class=\"headerlink\" title=\"复制变量\"></a>复制变量</h4><ul>\n<li>基本类型：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，拥有两个完全独立的内存空间，他们只是拥有相同的value而已</li>\n<li>引用类型：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上(即复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量)</li>\n</ul>\n<h4 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h4><p>首先js中所有的函数的参数都是按照值传递的。但是为什么又会有引用传递呢？归根结底还是因为存储方式不同</p>\n<ul>\n<li>基本类型：与复制变量类似，只是把变量里的值传递给参数，之后参数和这个变量互不影响</li>\n<li>引用类型：对象变量中的值是这个对象在堆内存中的内存地址，因此在进行参数传递时，虽然进行的是值传递，但是它传递的值是这个变量的内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部，因为它们都指向同一个对象</li>\n</ul>\n<h3 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h3><p>首先要理解js中的作用域链，先要理解什么是执行环境</p>\n<p>执行环境定义了变量或函数有权访问的其他数据，决定了他们的行为。在每一个执行环境中，都有一个变量对象，环境中定义的所有变量和函数都保存在这个对象中。我们没有办法访问到这个对象。在web浏览器中，一般认为window对象是全局执行环境，因此所有的变量和函数都是作为window对象的属性和方法创建的。</p>\n<p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的</p>\n<p>需要注意的是，js中没有块级作用域，即for循环或if语句中创建的变量，在for循环结束后也依然能够被在同一执行环境中的其他变量或函数访问到</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><h3 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h3><p>js具有自动的辣鸡手机机制，一般情况下，开发人员不需要手动清理垃圾。而js使用的垃圾清理方式主要有两种：</p>\n<p><strong>标记清除（mark and sweep）</strong></p>\n<p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>\n<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>\n<p><strong>引用计数(reference counting)</strong></p>\n<p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>\n<p>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。</p>\n<h2 id=\"面向对象的程序设计\"><a href=\"#面向对象的程序设计\" class=\"headerlink\" title=\"面向对象的程序设计\"></a>面向对象的程序设计</h2><p>首先，我们来跳出书本，<strong>什么是面向对象的程序设计</strong>？</p>\n<p>知乎上有这么个例子：面向对象是相对于面向过程的，比如你要充话费，你会想，可以下个支付宝，然后绑定银行卡，然后在淘宝上买卡，自己冲，这就是面向过程。但是对于你女朋友就不一样了，她是面向“对象”的，她会想，谁会充话费呢？当然是你了，她把电话号码给你，然后你把之前的做了一遍，然后她收到到帐的短信。这就是面向对象！女的思维大部分是面向“对象”的！她不关心处理的细节，只关心谁可以，和结果！</p>\n<p>在理解了什么是面向对象之后，我们再理解它的三个特性：封装、继承和多态</p>\n<p><strong>封装</strong>：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项，或者叫接口。有了封装，就可以明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者；而外部调用者也可以知道自己不可以碰哪里。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。</p>\n<p><strong>继承+多态</strong>：继承和多态必须一起说。一旦割裂，就说明理解上已经误入歧途了。</p>\n<p>先说继承：继承同时具有两种含义 — 其一是继承基类的方法，并做出自己的改变和/或扩展——解决了代码重用问题；其二是声明某个子类兼容于某基类（或者说，接口上完全兼容于基类），外部调用者可无需关注其差别（内部机制会自动把请求派发[dispatch]到合适的逻辑）。</p>\n<p>再说多态：基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。很显然，多态实际上是依附于继承的两种含义的：“改变”和“扩展”本身就意味着必须有机制去自动选用你改变/扩展过的版本，故无多态，则两种含义就不可能实现。</p>\n<p>我们用典型的面向对象语言java来举个例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Money</span>  //基类</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> string bankName = <span class=\"string\">\"中国人民银行\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> string <span class=\"title\">getBankName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bankName; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteFiveYuan</span> <span class=\"keyword\">extends</span> <span class=\"title\">Money</span>  // 子类1</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">5</span>;    <span class=\"comment\">// 多态的体现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoteTenYuen</span> <span class=\"keyword\">extends</span> <span class=\"title\">Money</span>  // 子类2</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10</span>; <span class=\"comment\">// 多态的体现</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ArrayList&lt;Money&gt; wallet = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    wallet.Add(<span class=\"keyword\">new</span> NoteFiveYuan());</span><br><span class=\"line\">    wallet.Add(<span class=\"keyword\">new</span> NoteTenYuan());</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Money money : wallet)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        println(money.getBankName());</span><br><span class=\"line\">        println(money.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果Money的设计者把“中国人民银行”改成了“美国人民银行”，你会发现其他地方完全不需要修改，这就是封装的好处；尤其是如果getBankName里面有一些复杂操作的话，好处会更明显。</p>\n<p>如果没有继承和多态，你就做不到把两个类的实例全扔到同一个wallet里面，并且在面对每一个Money的时候，你还必须得去手动判断他到底是哪种Money。现在有了继承和多态，只要你采用覆盖虚函数的方法，根本不用操心。更关键的是，如果以后还有30元的货币类，只要也继承Money并重写value，那么主函数里面数钱的那一段根本就不用动。</p>\n<p>回到js中来，虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同 一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在 ECMAScript 中无法创建类，开发人员 就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.job = job;</span><br><span class=\"line\">    o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</span><br></pre></td></tr></table></figure>\n<p>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无 数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><p>可以使用构造函数模式将前面的例子重写如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job; </span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">\t&#125;; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意，函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个 大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了 区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>\n<p>同时要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：</p>\n<ol>\n<li>创建一个新对象</li>\n<li>将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象)</li>\n<li>执行构造函数中的代码(为这个新对象添加属性)</li>\n<li>返回新对象</li>\n</ol>\n<p>在前面例子的最后，person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都 有一个 constructor（构造函数）属性，该属性指向 Person，如下所示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(person1.constructor === Person); <span class=\"comment\">//true </span></span><br><span class=\"line\">alert(person2.constructor === Person); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>我们在这个例子中创建的所有对象既是 Object 的实例，同时也是Person 的实例，这一点通过 instanceof 操作符可以得到验证，这也就解决了工厂模式所遗留的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">alert(person1 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">//true</span></span><br><span class=\"line\">alert(person2 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">alert(person2 <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p><strong>缺点：</strong><br>这个在全局作用域中定义的函数其实只能被某个对象调用，让全局函数有点名不副实。同时如果对象需要定义很多方法的话，就需要定义很多全局函数，同时这个所谓的对象没有任何封装性可言</p>\n<h3 id=\"工厂模式-1\"><a href=\"#工厂模式-1\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>（）</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = ‘nico’</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span></span><br><span class=\"line\">Person.prototype.sex = ‘male’</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person()</span><br><span class=\"line\">\t</span><br><span class=\"line\">person1.sayName === person2.sayName <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在这里，我们将所有属性和方法都直接定义到了Person的prototype属性中，让Person构造函数变成了一个空函数。在创建实例时，所有实例都会从Person的原型对象‘引用’相应的属性和方法。</p>\n<p>那么问题来了，什么是原型对象呢？</p>\n<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说， Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象 添加其他属性和方法。</p>\n<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则 都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部 属性），指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问 [[Prototype]] ， 但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 <strong>proto</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就 是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>\n<p>以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，图 6-1 展示了各个对象之间的关系。<br><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/prototype-6-1.png\" alt=\"\"></p>\n<p>图 6-1 展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系。 在此，Person.prototype 指向了原型对象，而 Person.prototype.constructor 又指回了 Person。 原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。Person 的每个实例——person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们 与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName()。这是通过查找对象属性的过程来实现的。</p>\n<p>需要注意的是我们不能通过对象实例重写对象原型中的值，但是如果在实例中新增加了值，那么在访问实例时，实例中的值就会屏蔽掉对象实例中的值，如果只有删除了实例中的值，那么重新访问时就会又得到对象原型中的值。</p>\n<p>缺点：首先通过原型模式创造的实例会共享原型对象的所有值，也正是由于共享这一属性，假如某一个属性的值是引用类型的话，就会‘牵一发而动全身’，例如某个属性为数组，当你在某一个实例中push一个新值，那么所有实例都会一起‘push一个新值’，这显然不是我们希望看到的。</p>\n<p>为了解决这个问题，又衍生出了下面的几种方法</p>\n<p><strong>组合使用构造函数模式和原型模式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, sex</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = sex</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.friends = [‘Shelby’, ‘Court’]  <span class=\"comment\">// 通过构造函数构造的实例为单独实例，互不影响</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person </span><br><span class=\"line\">    // 使用大括号声明时，本质上完全重写了prototype，使得<span class=\"keyword\">constructor</span>属性不再指向Person，而是指向了Object，为了防止使用该属性发生错误，可将其重新改写</span><br><span class=\"line\">    sayName: function() &#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于这样的写法可能会使有其他oo经验的人感到困惑，于是产生了<br><strong>动态原型模式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, sex</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.sex = sex</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (thpeof <span class=\"keyword\">this</span>.sayName !== ‘<span class=\"function\"><span class=\"keyword\">function</span>’)</span>&#123;</span><br><span class=\"line\">   \t\tPerson.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   \t\talert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意if语句中的代码，这里只有在sayName（）方法不存在的情况下才会将他添加到原型中。也就是说，这部分代码只有在第一次执行创建实例时才会使用，也就避免了构造函数每一次都创建新的实例。</p>\n<h3 id=\"关于继承\"><a href=\"#关于继承\" class=\"headerlink\" title=\"关于继承\"></a>关于继承</h3><h4 id=\"原型链与原型继承\"><a href=\"#原型链与原型继承\" class=\"headerlink\" title=\"原型链与原型继承\"></a>原型链与原型继承</h4><p>说到继承，我们需要说清楚什么是原型链，而关于原型链，高程上有比较书面的解释：</p>\n<blockquote>\n<p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。</p>\n</blockquote>\n<p>看不懂？没关系，我们来看一段高程上的代码示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subproperty = <span class=\"literal\">false</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//继承了 SuperType </span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">\t</span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subproperty; </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\">alert(instance.getSuperValue());    <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>以上代码先定义了一个构造函数 SuperType ，并定义了一个属性 property 为 true ，一个方法 getSuperValue 返回该属性的值；之后又定义了一个构造函数 SubType，之后把 SuperType 的一个实例赋值给了 SubType 的原型，使得 SubType 的所有实例都能够拥有 SuperType 的属性和方法，这就是原型继承的原理。</p>\n<p><strong>需要注意的是</strong>，这里的原型链其实是少了一环的，所有的对象都继承自 Object 对象，所以上述的两个函数都算是继承自 Object。</p>\n<p>一句话，SubType 继承了 SuperType，而 SuperType 继承了 Object。这就是通过原型的继承，也叫做原型继承。</p>\n<p>最后关于原型继承，还有一点需要注意的是给原型添加方法的代码一定要放在替换原型的语句之后。重写父类的方法将会屏蔽原来的那个方法，换句话说，父类的实例调用该方法时使用的是父类的方法，子类的实例调用时使用的是子类中重写的方法。同时在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>最主要的问题来自包含引用类型值的原型。前面介绍过包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了</li>\n<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上， 应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</li>\n</ul>\n<h4 id=\"借用构造函数的继承\"><a href=\"#借用构造函数的继承\" class=\"headerlink\" title=\"借用构造函数的继承\"></a>借用构造函数的继承</h4><p>为了弥补原型继承的缺点，开发人员使用一种叫做借用构造函数的技术。即 在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//继承了 SuperType </span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>); </span><br><span class=\"line\">alert(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\">alert(instance2.colors); <span class=\"comment\">//\"red,blue,green\"</span></span><br></pre></td></tr></table></figure>\n<p>代码中继承的那一部分“借调”了超类型的构造函数。通过使用 call()方法（或 apply()方法 也可以），我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p>\n<p><strong>优点：</strong>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函 数传递参数。看下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承了 SuperType，同时还传递了参数 </span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>, <span class=\"string\">\"Nicholas\"</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">//实例属性 </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\">alert(instance.name);   <span class=\"comment\">//\"Nicholas\";</span></span><br><span class=\"line\">alert(instance.age);    <span class=\"comment\">//29</span></span><br></pre></td></tr></table></figure>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了</li>\n<li>在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式</li>\n</ul>\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数 复用，又能够保证每个实例都有它自己的属性。下面来看一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承属性 </span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//继承方法 </span></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType(); </span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">\t</span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.age); </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>); </span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>); </span><br><span class=\"line\">alert(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\" </span></span><br><span class=\"line\">instance1.sayName(); <span class=\"comment\">//\"Nicholas\"; </span></span><br><span class=\"line\">instance1.sayAge(); <span class=\"comment\">//29</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>); </span><br><span class=\"line\">alert(instance2.colors); <span class=\"comment\">//\"red,blue,green\" </span></span><br><span class=\"line\">instance2.sayName(); <span class=\"comment\">//\"Greg\"; </span></span><br><span class=\"line\">instance2.sayAge(); <span class=\"comment\">//27</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，SuperType 构造函数定义了两个属性：name 和 colors。SuperType 的原型定义 了一个方法 sayName()。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着 又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型 上定义了方法 sayAge()。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包 括 colors 属性，又可以使用相同的方法了</p>\n<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>\n","categories":["技术"],"tags":["JavaScript"]},{"title":"前端性能优化","url":"https://teobler.com/20170721-performance-optimization.html","content":"<p>性能优化一直是程序猿中讨论的比较多的一个问题，不论是算法的优化，代码逻辑的优化，还是各种各样的优化，都是在每一个程序中非常重要的一环。在前端开发中，性能优化能够给用户带来更好的用户体验，同时能够缓解服务器的压力，与日常开发密不可分，今天对性能优化做了一个比较系统全面的整理。</p>\n<p>说到前端的性能优化，就不得不提<strong>CRP(关键路径渲染)</strong>，那么什么是CRP呢？要了解CRP首先我们需要知道，一个网页是如何渲染出来的。</p>\n<h2 id=\"浏览器的页面渲染\"><a href=\"#浏览器的页面渲染\" class=\"headerlink\" title=\"浏览器的页面渲染\"></a>浏览器的页面渲染</h2><h3 id=\"DOM-文档对象模型-构建\"><a href=\"#DOM-文档对象模型-构建\" class=\"headerlink\" title=\"DOM(文档对象模型)构建\"></a>DOM(文档对象模型)构建</h3><p>首先，渲染一个页面需要构建该页面的DOM模型，需要经过以下四个步骤：</p>\n<ol>\n<li><strong>转换：</strong>浏览器从磁盘或网络读取HTML的原始字节，然后根据指定的文件编码格式（例如 UTF-8）将其转换为相应字符，即从网络传输字节流到HTML字符的转换</li>\n<li><strong>令牌化：</strong>浏览器把字符转化成 W3CHTML5标准 指定的各种确切的令牌，比如 <code>&lt;html&gt;</code>、<code>&lt;body&gt;</code> 以及其他在尖括号内的字符串。每个令牌都有特殊的含义以及它自己的一套规则</li>\n<li><strong>词法分析：</strong>生成的令牌转化为对象，这个对象定义了它们的属性及规则</li>\n<li><strong>DOM构建：</strong>最后，由于HTML标记定义了不同标签之间的关系（某些标签嵌套在其他标签中），创建的对象在树状的数据结构中互相链接，树状数据结构也捕获了原始标签定义的父子关系：html对象是body对象的父对象，body是p对象的父对象等等</li>\n</ol>\n<p>经过上面的流程之后，浏览器就会在本地构建好一个DOM模型，下面这张图描述了这个过程：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/DOM-building.png\" alt=\"\"></p>\n<p>打开Chrome DevTools =&gt; performance，录制时间轴，上述过程对应Loading事件中的Parse HTML事件，可以查看到执行这一过程所需要的时间。</p>\n<p>那么DOM模型构建好之后就直接渲染了么？当然不是，我们还缺少一个CSSOM来告诉浏览器，DOM模型需要渲染成什么样子。</p>\n<h3 id=\"CSSOM-CSS对象模型-构建\"><a href=\"#CSSOM-CSS对象模型-构建\" class=\"headerlink\" title=\"CSSOM(CSS对象模型)构建\"></a>CSSOM(CSS对象模型)构建</h3><p>当浏览器构建上述网页DOM的时候，在head里面碰到一个link标签，这个标签引用了一个外部的CSS样式表。浏览器预测会需要这个资源来渲染页面，因此会立即发出一个该资源的请求。</p>\n<p>与DOM模型构建相似，我们这里直接上图看结果：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/CSSOM-build-1.png\" alt=\"\"></p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/CSSOM-build-2.png\" alt=\"\"></p>\n<p>想要查看CSS处理过程所花费的时间，可以在录制的时间轴中查看Rendering事件中的Recalculate Style事件：与DOM解析不同，timeline不显示单独的“Parse CSS”条目，而是在Recalculate Style事件下一同捕获CSS解析、CSSOM构建以及computed styles的递归计算。</p>\n<h3 id=\"渲染树构建\"><a href=\"#渲染树构建\" class=\"headerlink\" title=\"渲染树构建\"></a>渲染树构建</h3><p>此时我们已经有了DOM模型跟CSSOM模型，接下来浏览器要做的是将两个模型树进行合并，构建成一个我们最终需要的渲染树，构建渲染树时浏览器将DOM和CSSOM的每个节点一一对应进行合并，大致过程如下：</p>\n<ol>\n<li>从DOM树的根节点开始，遍历每个可见的节点<ul>\n<li>某些节点不可见（例如 script 标签、meta 标签等），因为它们不会体现在渲染结果中，所以会被忽略</li>\n<li>某些通过 CSS 隐藏的节点在渲染树中也会被忽略，比如应用了 display:none 规则的节点</li>\n</ul>\n</li>\n<li>为每一个可见的节点匹配并应用对应的CSSOM规则</li>\n<li>生成有内容和计算样式的可见节点</li>\n</ol>\n<p>最终输出的就是一个包含了所有可见节点的内容及样式信息的渲染树：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/rendering-tree.png\" alt=\"\"></p>\n<p>现在我们已经有了目标渲染树了，但是我们还不知道应该以多大的宽高来进行页面的渲染，所以浏览器需要进行布局，也就是重排。</p>\n<h3 id=\"布局与绘制\"><a href=\"#布局与绘制\" class=\"headerlink\" title=\"布局与绘制\"></a>布局与绘制</h3><p>为了计算出页面中每个对象的准确大小和位置，浏览器从渲染树的根节点开始遍历，计算页面上每个对象的几何信息。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Critial Path: Hello world!<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>布局过程浏览器需要做的就是捕获每个节点在视口中的准确位置以及尺寸的大小，并且输出这个“盒子模型”；同时需要注意的是，所有相对度量单位都会被转换为屏幕上的绝对像素。</p>\n<p>以上面的例子来说，页面的 body 包含两个嵌套 div：第一个 div（父元素）将节点尺寸大小设置为视口宽度的 50%，第二个 div 的宽度为父元素的 50%，即视口宽度的 25%。则最终结果如下：</p>\n<p><img src=\"https://teobler-image.s3-us-west-1.amazonaws.com/CRP-layout.png\" alt=\"\"></p>\n<p>在得到了这些“盒子模型”之后，最后需要做的当然就是按照规则将渲染树与“盒子模型“相”结合“，把渲染树上的每一个节点都转化成设备上的像素点，进行最后的绘制，之后我们就能看到我们的页面了。</p>\n<h3 id=\"CRP\"><a href=\"#CRP\" class=\"headerlink\" title=\"CRP\"></a>CRP</h3><p>那么，我们经过了哪些步骤呢？</p>\n<ul>\n<li>处理 HTML 标记，构建 DOM 树</li>\n<li>处理 CSS 标记，构建 CSSOM 树</li>\n<li>将 DOM 树和 CSSOM 树融合成渲染树</li>\n<li>根据渲染树进行布局，计算每个节点的几何信息</li>\n<li>在屏幕上绘制各个节点</li>\n</ul>\n<p>上面的5个步骤是渲染一个页面必不可少的步骤，所以也称作<strong>CRP(Critical Rendering Path，关键渲染路径)</strong></p>\n<p>而前端优化最主要的就是做到尽可能缩短这些步骤的时间</p>\n<h2 id=\"CRP优化\"><a href=\"#CRP优化\" class=\"headerlink\" title=\"CRP优化\"></a>CRP优化</h2><p>那么优化是不是直接上手，胡乱优化一通呢？当然不是，为了做到有的放矢，我们再引入一个概念</p>\n<h3 id=\"CRP性能\"><a href=\"#CRP性能\" class=\"headerlink\" title=\"CRP性能\"></a>CRP性能</h3><p>我们先定义三个用于描述CRP性能的词汇：</p>\n<ul>\n<li><strong>关键资源：</strong>能够阻止网页首次渲染的资源</li>\n<li><strong>关键路径长度：</strong>往返过程的数量，或者获取所有关键资源所需的总时间</li>\n<li><strong>关键字节：</strong>网页首次渲染所需的总字节数，是所有关键资源的传输文件大小总和</li>\n</ul>\n<p>为了使用这些概念，我们举几个小例子：</p>\n<ol>\n<li>假如该网页只有HTML文件，且假设大小为3KB，那么我们就只需要请求一次HTML的文件，并进行接下来的步骤，此时有：<ul>\n<li>1个关键资源(HTML文件)</li>\n<li>1个关键路径长度(假设一次请求能拉下该文件)</li>\n<li>3KB关键字节 (该文件大小)</li>\n</ul>\n</li>\n<li>假设在上面的基础上加入了CSS文件(6KB)，则有：<ul>\n<li>2个关键资源</li>\n<li>最少2个关键路径长度(两次请求能拉下来就2个)</li>\n<li>9KB关键字节</li>\n</ul>\n</li>\n<li>在 <strong>2</strong> 的基础上加上js文件(6KB):<ul>\n<li>3个关键资源</li>\n<li>最少2个关键路径长度(可以异步请求CSS与JS)</li>\n<li>15KB关键字节</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"优化方法\"><a href=\"#优化方法\" class=\"headerlink\" title=\"优化方法\"></a>优化方法</h3><p>好了，在说了这么多前提之后，我们正式进入优化阶段，在这边我将优化分为4个部分：</p>\n<h4 id=\"关键资源\"><a href=\"#关键资源\" class=\"headerlink\" title=\"关键资源\"></a>关键资源</h4><h5 id=\"CSS与JS文件的加载\"><a href=\"#CSS与JS文件的加载\" class=\"headerlink\" title=\"CSS与JS文件的加载\"></a>CSS与JS文件的加载</h5><p>阻塞渲染的CSS</p>\n<p>CRP要求DOM和CSSOM两者融合在一起才能构建渲染树。这就导致了一个性能问题：HTML和CSS都是阻塞渲染的资源。HTML很显然，没有DOM就没有内容去渲染。CSS没有那么明显，但确实是阻塞渲染的资源。如果CSS不阻塞渲染，我们看到的很可能是这样的一个画面：页面刚加载出来的时候其丑无比，过了一会，页面又变漂亮了。</p>\n<p>既然CSS是阻塞渲染的资源，这就意味着在CSSOM构建完成之前，浏览器不会去渲染任何已处理的内容。要尽早、尽快地把CSS下载到客户端以优化首次渲染的时间。</p>\n<p>使用CSS“媒体类型”和“媒体查询”优化阻塞渲染的CSS：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"print.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"print\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"other.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"(min-width: 40em)\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一条声明阻塞渲染，匹配所有情况</li>\n<li>第二条声明只适用于打印（媒体类型），因此，页面在浏览器中首次加载时，不会阻塞渲染</li>\n<li>第三条声明提供了媒体查询，由浏览器判断：如果条件符合，则在该样式表下载并处理完以前，浏览器会阻塞渲染</li>\n</ul>\n<p>阻塞渲染的JS</p>\n<p>JS可以修改页面的内容、样式以及响应用户的交互，JS在DOM、CSSOM和JS执行之间引入了很多新的依赖关系，导致浏览器在处理和渲染页面上出现大幅延迟：</p>\n<ul>\n<li>当浏览器遇到<code>&lt;script&gt;</code>标签时，DOM构建会暂停，直到脚本执行完毕</li>\n<li>JavaScript 执行会暂停，直到CSSOM准备就绪</li>\n</ul>\n<p>默认情况下，JavaScript 执行会阻塞解析器：当浏览器在文档中遇到<code>&lt;script&gt;</code>标签时，DOM构建必须暂停，浏览器把控制权移交给JS引擎，JS引擎编译并执行脚本，脚本执行完毕后再继续构建DOM。</p>\n<p>事实上，内联脚本始终会阻塞解析器，除非你编写额外的代码来延迟它们的执行。那通过<code>&lt;script&gt;</code>引入的外联脚本呢？结果是一样的，浏览器都会暂停，然后执行脚本，脚本执行完毕之后再去处理文档的剩余部分。尽管如此，通过<code>&lt;script&gt;</code>引入外联脚本还是有一个很大的好处。</p>\n<p>默认情况下，所有 JS 均会阻塞解析器，因为浏览器不知道脚本想在页面上做什么，因此它必须假定最糟的情况并阻塞解析器。但是，如果我们能够有个信号告知浏览器，说脚本无需在文档中引用它的确切位置被执行呢？这样一来，浏览器就会继续构建DOM，并在脚本准备就绪后执行脚本。</p>\n<p>这个信号就是async——在script标签里面添加async关键字，其有两个特性：</p>\n<ul>\n<li>告诉浏览器当它碰到<code>&lt;script&gt;</code>标签时不用阻塞DOM构建，因此浏览器会忽略脚本请求，继续解析DOM</li>\n<li>JS执行不依赖CSSOM：如果在CSSOM就绪之前脚本已经就绪，脚本可以立即执行</li>\n</ul>\n<p>进行图片等资源的懒加载</p>\n<h4 id=\"关键路径长度\"><a href=\"#关键路径长度\" class=\"headerlink\" title=\"关键路径长度\"></a>关键路径长度</h4><ul>\n<li>减少http请求 — 减少了连接的时间(dns解析、三次握手、四次挥手)、减少了服务器压力(cpu相应)、减少了请求头释放了带宽<ul>\n<li>CSS/JS合并打包</li>\n<li>小图标使用iconfont 或 雪碧图</li>\n<li>多彩小图标无法使用iconfont可以使用base64格式直接嵌入到src中(需要注意的是base64无法缓存)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"关键字节\"><a href=\"#关键字节\" class=\"headerlink\" title=\"关键字节\"></a>关键字节</h4><ul>\n<li>压缩静态资源体积<ul>\n<li>CSS/JS文件压缩</li>\n<li>冗余代码去除</li>\n<li>图片压缩</li>\n<li>代码优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"非前端优化\"><a href=\"#非前端优化\" class=\"headerlink\" title=\"非前端优化\"></a>非前端优化</h3><p>除了在前端可以进行性能优化以外，在非前端也能进行优化，例如：</p>\n<ul>\n<li>服务器端开启<strong>gzip压缩</strong></li>\n<li>使用<strong>多域名</strong>，一方面为解决浏览器对相同域名的并发连接数限制(提高并发)；另一方面可做到互为backup。感兴趣的可以看下又拍云、阿里云联合云存储</li>\n<li><strong>CDN缓存</strong>，简单来讲就是在不同地点缓存内容，通过负载均衡，将用户请求定向到最合适的缓存服务器上获取内容。通过就近访问，加速用户对网站的访问；解决网络拥堵状况，提高用户访问网络的响应速度。使用cdn的时候有一点需要注意，即文件的缓存更新问题。实际上，若你的js/css文件缓存时间较长且是覆盖式发布，那需要注意，哪怕反复多次强刷cdn，它的刷新率也是很低的，做不到100%所有节点的缓存文件都被刷新。</li>\n</ul>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008550336\" target=\"_blank\" rel=\"noopener\">jasonintju的文章</a></li>\n<li><a href=\"https://cn.udacity.com/course/browser-rendering-optimization--ud860\" target=\"_blank\" rel=\"noopener\">udacity</a></li>\n</ul>\n","categories":["技术"],"tags":["performance","性能优化"]},{"title":"CSS菜鸟基础","url":"https://teobler.com/20170716-css-finishing.html","content":"<p>话不多说，这次罗列总结一下css基础知识，和我一样的菜鸟可以看看。</p>\n<h2 id=\"引入方式\"><a href=\"#引入方式\" class=\"headerlink\" title=\"引入方式\"></a>引入方式</h2><p>css的引入方式主要有以下几种：</p>\n<ul>\n<li><p>外部样式表</p>\n<p>通过在head标签中加入link标签来引入外部样式表，因为其良好的分离性和可维护性，大多数css样式都是通过这种方式引入的</p>\n</li>\n<li><p>内部样式表</p>\n<p>直接将css样式放入style标签置于head标签内</p>\n</li>\n<li><p>内联样式表</p>\n<p>直接将css样式写入html元素的style属性</p>\n</li>\n</ul>\n<h2 id=\"盒子模型与BFC\"><a href=\"#盒子模型与BFC\" class=\"headerlink\" title=\"盒子模型与BFC\"></a>盒子模型与BFC</h2><p>在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性 （颜色，背景，边框方面） 和位置是渲染引擎的目标。</p>\n<p>在CSS中，使用标准盒模型描述这些矩形盒子中的每一个。这个模型描述了元素所占空间的内容。每个盒子有四个边：外边距边（margin）, 边框边（border）, 内填充边（padding） 与 内容边（content）</p>\n<h3 id=\"行内元素和块级元素\"><a href=\"#行内元素和块级元素\" class=\"headerlink\" title=\"行内元素和块级元素\"></a>行内元素和块级元素</h3><h4 id=\"内联元素-inline\"><a href=\"#内联元素-inline\" class=\"headerlink\" title=\"内联元素(inline)\"></a>内联元素(inline)</h4><ul>\n<li>和相邻的内联元素在同一行</li>\n<li>padding和margin的left和right可以进行设置改变</li>\n<li>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，固定为里面文字或图片撑开的大小</li>\n</ul>\n<h4 id=\"块级元素-block\"><a href=\"#块级元素-block\" class=\"headerlink\" title=\"块级元素(block)\"></a>块级元素(block)</h4><ul>\n<li>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示</li>\n<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制</li>\n</ul>\n<h4 id=\"内联块元素（inline-block）\"><a href=\"#内联块元素（inline-block）\" class=\"headerlink\" title=\"内联块元素（inline-block）\"></a>内联块元素（inline-block）</h4><ul>\n<li>拥有内在尺寸，可设置高宽，但不会自动换行</li>\n<li>一些浏览器默认的inline-block元素： input 、img 、button 、textarea 、label</li>\n</ul>\n<h4 id=\"外边距重叠\"><a href=\"#外边距重叠\" class=\"headerlink\" title=\"外边距重叠\"></a>外边距重叠</h4><p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p>\n<p>折叠结果遵循下列计算规则：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和</li>\n</ul>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><h4 id=\"Formatting-context\"><a href=\"#Formatting-context\" class=\"headerlink\" title=\"Formatting context\"></a>Formatting context</h4><p>在说BFC之前，先解释一下Formatting context，即FC。其是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。</p>\n<h4 id=\"BFC定义\"><a href=\"#BFC定义\" class=\"headerlink\" title=\"BFC定义\"></a>BFC定义</h4><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box（块级元素）参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>\n<h4 id=\"BFC内部规则\"><a href=\"#BFC内部规则\" class=\"headerlink\" title=\"BFC内部规则\"></a>BFC内部规则</h4><ul>\n<li>内部的Box会在垂直方向，一个接一个地放置</li>\n<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>\n<li>每个box的margin-left，与内容块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>\n<li>BFC的区域不会与float box重叠</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ul>\n<h4 id=\"BFC的作用\"><a href=\"#BFC的作用\" class=\"headerlink\" title=\"BFC的作用\"></a>BFC的作用</h4><p>BFC的常用功能如下</p>\n<ul>\n<li>文档布局</li>\n<li>清除浮动</li>\n<li>清除重叠外边距</li>\n</ul>\n<h4 id=\"触发BFC的条件\"><a href=\"#触发BFC的条件\" class=\"headerlink\" title=\"触发BFC的条件\"></a>触发BFC的条件</h4><ul>\n<li>根元素</li>\n<li>float属性不为none</li>\n<li>overflow不为visible</li>\n<li>position为absolute或fixed</li>\n<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>\n</ul>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><ul>\n<li>自适应两栏式布局</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">   <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.aside</span> &#123;</span><br><span class=\"line\">     <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#f66</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.main</span> &#123;</span><br><span class=\"line\">     <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#fcc</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://codepen.io/teobler/pen/pwMjdO?editors=1000\" target=\"_blank\" rel=\"noopener\">效果</a></p>\n<p>根据BFC第三条规则，虽然存在浮动元素aside，但是main元素的左边依然会跟包含块的border相接触，这时通过设置main元素的overflow：hidden触发产生一个新的BFC，便实现了简单的两栏自适应布局。</p>\n<p>更多例子可以<a href=\"http://www.jianshu.com/p/bf927bc1bed4\" target=\"_blank\" rel=\"noopener\">查看</a></p>\n<h2 id=\"选择器与优先级\"><a href=\"#选择器与优先级\" class=\"headerlink\" title=\"选择器与优先级\"></a>选择器与优先级</h2><h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>css通过选择器关联html标签，以达到控制html元素样式的效果，基本的选择器有以下几种：</p>\n<ul>\n<li>派生选择器： 直接用html标签进行选择</li>\n<li>类选择器： 使用html元素的class属性进行选择</li>\n<li>id选择器： 使用html元素的id属性进行选择</li>\n</ul>\n<p>以上三种选择器为css中最基本的选择器，其他选择器都是三者的延伸、扩展或者组合，例如：</p>\n<ul>\n<li><p>伪元素选择器： 利用 : 选择伪元素</p>\n</li>\n<li><p>后代选择器： 利用空格进行后代的选择</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.header .nav&#123;//选取header类中的nav类&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>兄弟选择器（猫头鹰选择器）： 使用+来选择两个紧接着的元素，且它们拥有相同的父元素，因为其样子酷似猫头鹰，所以又被称为猫头鹰选择器，猫头鹰选择器虽然冷门，但是应用在多个相同元素的排列的时候会自动帮你处理一些边缘问题，这里就不展开了<a href=\"http://www.zcfy.cc/article/spoooooky-css-selectors-1794.html\" target=\"_blank\" rel=\"noopener\">详情请戳</a></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.warp div + div&#123;//选取warp类下的所有兄弟div&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>群组选择器： 利用逗号进行多个元素的选取</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div, .avatar, a&#123;//选取所有div、avatar类和a标签&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性选择器： 利用中括号选择带有特定属性的元素</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[title]&#123;//选择所有带有title属性的a标签&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"优先级（特殊性）\"><a href=\"#优先级（特殊性）\" class=\"headerlink\" title=\"优先级（特殊性）\"></a>优先级（特殊性）</h3><p>一般来说，越复杂越精确的选择器优先级就越高，在css权威指南上，是这样来定义和区分优先级的：</p>\n<blockquote>\n<p>选择器的特殊性由选择器本身的组件确定。特殊性值表现为4个部分，如：0， 0， 0， 0</p>\n<p>一个选择器的具体特殊性如下确定：</p>\n<ul>\n<li>对于选择器中给定的各个ID属性值，加 0100</li>\n<li>对于选择器中给定的各个类属性值、属性选择或伪类，加 0010</li>\n<li>对于选择器中给定的各个元素或伪元素，加 0001。伪元素是否有特殊性？在这方面CSS2有些自相矛盾，但是在CSS2.1中明确指出，伪元素有特殊性，并且为0001</li>\n<li>结合符和统配选择器对特殊性没有任何贡献（后面还会更多地介绍这些值）</li>\n<li>内联样式的声明特殊性都是1000</li>\n<li>重要性：有时某个声明可能非常重要，超过了其他所有声明。CSS2.1称之为重要声明，并允许这些声明的结束分号之前插入 !important 来标志</li>\n</ul>\n</blockquote>\n<p>CSS的优先级还遵循叠加规则，即</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">span#xxx .songs li&#123;//这个选择器的特殊性为0112&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h4><ul>\n<li>号代表通配符，选取文档中的所有元素，一般不建议使用，首先过于暴力，其次影响渲染性能</li>\n</ul>\n<p>样式最后的渲染效果与样式定义在文件中的先后顺序有关，即后面的覆盖前面的，与在html文档中的先后关系无关。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.A</span>&#123; <span class=\"attribute\">color</span>:blue;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.B</span>&#123; <span class=\"attribute\">color</span>:red;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &lt;p class='B A'&gt; 123 &lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>最后“123”的颜色是 red</p>\n<h2 id=\"CSS-Hack\"><a href=\"#CSS-Hack\" class=\"headerlink\" title=\"CSS Hack\"></a>CSS Hack</h2><h3 id=\"什么是CSS-Hack\"><a href=\"#什么是CSS-Hack\" class=\"headerlink\" title=\"什么是CSS Hack\"></a>什么是CSS Hack</h3><p>由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack</p>\n<h3 id=\"CSS-Hack的方法\"><a href=\"#CSS-Hack的方法\" class=\"headerlink\" title=\"CSS Hack的方法\"></a>CSS Hack的方法</h3><ul>\n<li>条件注释法</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"selector-tag\">--</span><span class=\"selector-attr\">[if IE]</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">这段文字只在<span class=\"selector-tag\">IE</span>浏览器显示</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!<span class=\"selector-attr\">[endif]</span><span class=\"selector-tag\">--</span>&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类内属性前缀法</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.hack</span>&#123; </span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>:red; <span class=\"comment\">/* All browsers */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>:blue <span class=\"meta\">!important</span>;<span class=\"comment\">/* All browsers but IE6 */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  *background-color:black; /* IE6, IE7 */  </span><br><span class=\"line\"></span><br><span class=\"line\">  +<span class=\"selector-tag\">background-color</span><span class=\"selector-pseudo\">:yellow</span>;<span class=\"comment\">/* IE6, IE7*/</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">background-color</span><span class=\"selector-pseudo\">:gray</span>\\9; <span class=\"comment\">/* IE6, IE7, IE8, IE9, IE10 */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">background-color</span><span class=\"selector-pseudo\">:purple</span>\\0; <span class=\"comment\">/* IE8, IE9, IE10 */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">background-color</span><span class=\"selector-pseudo\">:orange</span>\\9\\0;<span class=\"comment\">/*IE9, IE10*/</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  _<span class=\"selector-tag\">background-color</span><span class=\"selector-pseudo\">:green</span>; <span class=\"comment\">/* Only works in IE6 */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>媒体查询</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">media</span> \\<span class=\"number\">0s</span>creen\\,screen\\<span class=\"number\">9</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.hack</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">/* IE 6 7 8 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">media</span> screen and (-webkit-min-device-pixel-ratio:<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">/* Webkit内核 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础布局\"><a href=\"#基础布局\" class=\"headerlink\" title=\"基础布局\"></a>基础布局</h2><h3 id=\"垂直居中\"><a href=\"#垂直居中\" class=\"headerlink\" title=\"垂直居中\"></a>垂直居中</h3><p>方法有很多，我大概罗列一下我用得比较多的</p>\n<ul>\n<li>包裹法</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"warpper\"</span>&gt;</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>Content here<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#warpper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  float: left;</span><br><span class=\"line\"></span><br><span class=\"line\">  height: 50%;</span><br><span class=\"line\"></span><br><span class=\"line\">  margin-bottom: -150px;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#content &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  clear: both;</span><br><span class=\"line\"></span><br><span class=\"line\">  height: 300px;</span><br><span class=\"line\"></span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法在需要垂直居中的div外再包裹一个div，并将其设置浮动，margin-bottom为内部div的 1/2 * height，之后content触发BFC，内部也能放元素。优点是兼容性比较好，缺点是增加了额外的元素，并且高度不能改变。</p>\n<ul>\n<li>flexbox</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"warpper\"</span>&gt;</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>Content here<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#warpper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\"></span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\"></span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用起来最舒服最简单的方法，但是，兼容性是个大问题，比如IE要IE11才兼容，很尴尬。</p>\n<h3 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h3><p>水平居中比较简单，一般不会问到，但是作为复习也说得过去</p>\n<ul>\n<li>margin</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>Content here<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">#content &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  margin: 0 auto;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>绝对定位</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>Content here<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">.content &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tposition: absolute;</span><br><span class=\"line\"></span><br><span class=\"line\">\twidth: 200px;</span><br><span class=\"line\"></span><br><span class=\"line\">\tleft: 50%;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmargin-left: -(width/2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flexbox</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"warpper\"</span>&gt;</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"content\"</span>&gt;</span>Content here<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#warpper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\"></span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"栅格布局\"><a href=\"#栅格布局\" class=\"headerlink\" title=\"栅格布局\"></a>栅格布局</h3><h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>一个栅格布局一般分为：容器（container）、行（row）、列（col）</p>\n<p>其中容器用于确定整体布局的宽度，设定了容器的宽度以后，再设置一个容器中容纳多少行，最后在在每一行中确定有多少列，同时列与列之间的间隔也被提前规定，这使得我们在布局的时候就很简单了，不用过多的考虑对齐问题。其中列是真正显示文档内容的元素。</p>\n<h4 id=\"列宽\"><a href=\"#列宽\" class=\"headerlink\" title=\"列宽\"></a>列宽</h4><p>一个能用的栅格系统，会提前准备一个声明列宽的类，将容器的宽度平分为几个等分，这个等分一般时3或4的倍数，这样比较容易排版，当然，分的越多排版越精确</p>\n<h4 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h4><p>栅格系统可以嵌套，即列也可以作为容器继续嵌套栅格，这便是嵌套栅格</p>\n<h4 id=\"列的换行与行的偏移\"><a href=\"#列的换行与行的偏移\" class=\"headerlink\" title=\"列的换行与行的偏移\"></a>列的换行与行的偏移</h4><p>一个完美支持响应式的栅格系统支持列的换行，即同一行的不同列之间的高度可以不相同，这种行为能够大大加强栅格系统的响应式能力。同时其还支持列的偏移，即可以不从第一列开始，将某几列作为空隙。</p>\n<p>具体的栅格系统可参考<a href=\"http://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">bootstrap官网</a></p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>作为一个菜鸟能罗列收集的东西大概也就那么多了，还有一些比较基础的由于篇幅原因就没有放上来，当然还有好多也很重要的东西没罗列出来，这要归结于自己还是太菜，要是对你有帮助的话，就点个赞咯。有问题的话也接受一切批评和建议，我会努力加油的。上一篇文章在本篇头部，所有文章收录于我的<a href=\"https://teobler.com\">博客</a>中。</p>\n","categories":["技术"],"tags":["CSS"]},{"title":"html基础知识整理","url":"https://teobler.com/20170616-html-finishing.html","content":"<p>这篇文章衔接上篇，主要罗列一些前端面试中可能问到的html中最基本的问题。</p>\n<h2 id=\"常用标签\"><a href=\"#常用标签\" class=\"headerlink\" title=\"常用标签\"></a>常用标签</h2><h3 id=\"容器标签\"><a href=\"#容器标签\" class=\"headerlink\" title=\"容器标签\"></a>容器标签</h3><ul>\n<li><p>div</p>\n<p>div标签本身无特殊意义，作为一个块级容器，主要用于组合其他html元素常用于页面的布局。</p>\n</li>\n<li><p>span</p>\n<p>span标签与div标签类似，本身无特殊意义，但它在结合诸如class,lang,或者dir属性时，可作为行内元素的容器。它起到描述（文档内容）的作用。</p>\n</li>\n</ul>\n<h3 id=\"文本标签\"><a href=\"#文本标签\" class=\"headerlink\" title=\"文本标签\"></a>文本标签</h3><ul>\n<li><p>h1-h6</p>\n<p>h标签用于设置网页标题或文章标题，为了符合语义化，尽量用h1作为整个网页或网站的标题，h2作下一级标题，以此类推</p>\n</li>\n<li><p>p</p>\n<p>p标签用于设置网页的文体，是大多数文字的主要标签，表示文章或某些文字的一个段落。</p>\n</li>\n<li><p>em 与 strong</p>\n<p>em标签的作用是强调内容，strong标签的作用是着重内容，在浏览器中都会被渲染成加粗字体，但是在英文文章中，表示强调的文字会用斜体，例如：专有名词、术语、外来名词等；而strong则使用粗体，表示需要着重表现的文字。同时，如果使用盲人阅读设备，strong标签中的内容会被重读。</p>\n</li>\n</ul>\n<h3 id=\"列表与表格标签\"><a href=\"#列表与表格标签\" class=\"headerlink\" title=\"列表与表格标签\"></a>列表与表格标签</h3><ul>\n<li><p>ul、ol 与 li</p>\n<p>ul标签代表多项无序列表，即无数值排序的集合；而ol标签代表多项有序列表，是有数值排序的集合。当li标签嵌套在ul标签中时，是无序列表中的列表项，此时li的顺序在列表中没有意义；而当li嵌套在ol标签中时，则是有序列表中的列表项，此时第一个li标签则排序为一，以此类推。</p>\n</li>\n<li><p>dl 与 dt、dd</p>\n<p>dl是一个定义列表，用来解释说明一些术语或特定词句。其中dt为术语部分（待解释部分），dd为dt的解释说明部分。</p>\n</li>\n<li><p>table</p>\n<p>table标签用于定义表格，在早期由于浏览器对css技术的不支持，人们大量利用table标签进行页面布局，在现代的前端开发中已经摒弃了这种布局方式。但是也不用一棒子打死，table布局在布局表单内容时还是要方便的多。</p>\n<p>在使用table标签时，tr标签定义行，th标签定义表头，td标签定义表格单元，更复杂的表格还会包含caption、col、colgroup、thead、tfoot 以及 tbody 元素。</p>\n<p>注意：在 HTML5 中，table标签仅支持 “border” 属性，并且只允许使用值 “1” 或 “”</p>\n</li>\n</ul>\n<h3 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h3><ul>\n<li><p>form</p>\n<p>form标签在文档中定义了一个表单，表单中有各种表单控件，最后浏览器会将表单中的信息提交到服务器。其中，form标签有几个常用的重要属性：</p>\n<ul>\n<li><p>name</p>\n<p>name标签可以让我们方便的用js找到某个特定的表单，从而找到此表单下的表单控件，这样就可以对表单中的各个部分进行控制了。（form表单中的表单控件也有name属性）</p>\n</li>\n<li><p>action</p>\n<p>action属性是当前表单所要提交到的服务器处理url，表单会被提交到action属性中的页面进行处理。</p>\n</li>\n<li><p>method</p>\n<p>提交表单到服务器的方法，可选GET和POST，两个方法的特点和作用可到网上查阅，今后我也会慢慢整理。</p>\n</li>\n</ul>\n</li>\n<li><p>input</p>\n<p>input标签用于接收用户的填写的信息，通过form表单提交到服务器，同时通过设置<strong>type属性</strong>的不同值可以赋予input标签不同的功能，常用功能如下：</p>\n<ul>\n<li>text（默认）: 用于接收文本信息如用户名等</li>\n<li>password: 用于接收密码</li>\n<li>radio: 单选按钮（使用value属性标注提交值）</li>\n<li>checkbox: 复选框（使用value属性标注提交值）</li>\n<li>file: 文件上传</li>\n<li>image: 图像上传</li>\n<li>data: 输入日期控件（年月日）</li>\n</ul>\n</li>\n<li><p>button</p>\n<p>将button标签归类到这里其实是不太合适的（但是我不知道怎么归了啊=。=）button标签在表单中主要是用于提交表单，当用户填写完成后点击按钮进行表单的提交等操作。通过设置<strong>type属性</strong>也有不同的作用：</p>\n<ul>\n<li>submit: 此按钮提交表单数据给服务器。未指定时，此值为默认值，或者如果此属性动态变为空值或无效值</li>\n<li>reset: 此按钮重置所有组件为初始值</li>\n<li>button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发</li>\n</ul>\n</li>\n<li><p>select 与 option</p>\n<p>select标签为下拉菜单，需要配合option标签一起使用，option标签为下拉菜单中的选项。通过指定select标签中的mutiple或size属性可设置select为下拉菜单或是列表框</p>\n</li>\n<li><p>textarea</p>\n<p>用于定义多行文本域，cols和rows属性是必须要填写的，他们用于指定文本域的宽度和高度。多行文本域比较特殊，除了普通的事件属性，他还可以指定onselect属性，用于表示文本域里面的内容被选中时候的事件。</p>\n</li>\n</ul>\n<h3 id=\"超链接（锚点）\"><a href=\"#超链接（锚点）\" class=\"headerlink\" title=\"超链接（锚点）\"></a><a href=\"#超链接（锚点）\" title=\"超链接（锚点）\"></a>超链接（锚点）</h3><ul>\n<li><p>a</p>\n<p>a标签用于创建一个到其他网页，文件，或同一页面内的位置，当然也可以是电子邮件地址或任何其他URL的超链接。下面是几个常用的属性：</p>\n<ul>\n<li><p>href</p>\n<p>这是一个必需属性为锚定义一个超文本链接来源。这表示链接目标的URL或URL片段</p>\n</li>\n<li><p>download</p>\n<p>此属性指示浏览器下载URL而不是导航到URL，因此将提示用户将其保存为本地文件。</p>\n<p>如果属性有一个值，它将在保存提示中用作预先填写的文件名 (用户仍然可以根据需要更改文件名)。对允许的值没有限制，但是 / 和 \\ 被转换为下划线。大多数文件系统限制文件名中的一些标点符号，浏览器会相应地调整建议的名称。</p>\n</li>\n<li><p>target</p>\n<p>该属性指定在何处显示链接的资源。 取值为标签（tab），窗口（window），或框架（iframe）等浏览上下文的名称或其他关键词。以下关键字具有特殊的意义:</p>\n<ul>\n<li><p>_self: 当前页面加载，会覆盖掉当前页面。此值是默认的，如果没有指定属性的话</p>\n</li>\n<li><p>_blank: 新窗口打开，根据浏览器的不同设置，会在新标签页或新的浏览器窗口中打开页面</p>\n</li>\n<li><p>_parent: 加载响应到当前框架的父框架或当前的HTML5浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self。</p>\n</li>\n<li><p>_top: IHTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图片标签\"><a href=\"#图片标签\" class=\"headerlink\" title=\"图片标签\"></a>图片标签</h3><ul>\n<li><p>img</p>\n<p>用来设置文档中的图像内容，主要属性如下：</p>\n<ul>\n<li><p>src: 图像的 URL，这个属性对  元素来说是必需的</p>\n</li>\n<li><p>alt: 这个属性定义了描述图像的替换文本。如果图像的URL是错误的，该图像不在支持的格式列表中，或者如果图像还没有被下载,用户将看到这个显示。</p>\n</li>\n</ul>\n<p>注意：在标准规范中，省略这个属性表明该图像是内容的关键部分，但没有等效的文本可用。把这个属性设置为空字符串，表明该图像不是内容的关键部分，非可视化浏览器在渲染的时候可能会忽略它。</p>\n</li>\n</ul>\n<h2 id=\"html5新增常用标签\"><a href=\"#html5新增常用标签\" class=\"headerlink\" title=\"html5新增常用标签\"></a>html5新增常用标签</h2><h3 id=\"3D效果与动画\"><a href=\"#3D效果与动画\" class=\"headerlink\" title=\"3D效果与动画\"></a>3D效果与动画</h3><ul>\n<li><p>canvas</p>\n<p>canvas 标签定义图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。</p>\n</li>\n</ul>\n<h3 id=\"音频视频\"><a href=\"#音频视频\" class=\"headerlink\" title=\"音频视频\"></a>音频视频</h3><ul>\n<li><p>audio</p>\n<p>audio 标签用于在文档中表示音频内容。它可以包含多个音频资源， 这些音频资源可以使用 src 属性或者source 元素来进行描述； 浏览器将会选择最合适的一个来使用。对于不支持 audio 元素的浏览器，audio 元素也可以作为浏览器不识别的内容加入到文档中。</p>\n</li>\n<li><p>video</p>\n<p>用于在文档中嵌入视频内容。</p>\n</li>\n</ul>\n<p>ps.对于html5来说，常用的标签大概就这么多，原因还是浏览器的兼容问题，大多数标签使用起来不方便。主要使用还是特定场景下的api调用，如摄像头，gps定位等。html5的具体特性可查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5\" target=\"_blank\" rel=\"noopener\">MDN:HTML5</a></p>\n<h2 id=\"特殊标签\"><a href=\"#特殊标签\" class=\"headerlink\" title=\"特殊标签\"></a>特殊标签</h2><ul>\n<li><p>&lt;!DOCTYPE&gt;</p>\n<p>准确的说，!DOCTYPE不应该算是一个html标签。&lt;!DOCTYPE&gt; 告知浏览器当前的 HTML (或 XML)文档是哪一个版本,应该用那种规范来解析当前文档. Doctype 是一条声明,而不是一个标签; 也可以把它叫做 “文档类型声明”, 或 简称为 “DTD”.</p>\n</li>\n<li><p>meta</p>\n<p>meta标签位于html文档头部中的head标签中。meta标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等元数据。这些数据将用于服务搜索引擎和其他网络服务.</p>\n<p>由于meta标签的属性实在太多，这里列举几个常用属性：</p>\n<ul>\n<li><p>name</p>\n<p>name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述。其中name属性有三个常用的取值，分别是：</p>\n<ul>\n<li>keyword: 告诉搜索引擎你网站的关键词</li>\n<li>description: 用于告诉搜索网站你网站的主要内容</li>\n<li>viewport: 移动设备窗口设置</li>\n</ul>\n<p>其中重点说下viewport的设置：</p>\n<p>width: 控制 viewport 的大小，可以指定的一个值，例如 600 或 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）</p>\n<p>height: 和 width 相对应，指定高度</p>\n<p>initial-scale: 初始缩放比例，也即是当页面第一次 load 的时候缩放比例</p>\n<p>maximum-scale: 允许用户缩放到的最大比例</p>\n<p>minimum-scale: 允许用户缩放到的最小比例</p>\n<p>user-scalable: 用户是否可以手动缩放</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http-equiv</p>\n<p>这个属性用于设置http请求相关参数。使用方法与name一样，需要配合content使用，先使用http-equiv定义，再使用content进行相关设置。</p>\n<ul>\n<li><p>content-Type: 设置字符集，在html5中已经修改为 charset，一般推荐设置成 utf-8 字符集</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>X-UA-Compatible: 设置浏览器采用何种版本渲染当前页面，一般选择最新版本</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"IE=edge,chrome=1\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cache-control: 指定请求和响应遵循的缓存机制</p>\n<p>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p>\n<p>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</p>\n<p>public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</p>\n<p>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</p>\n<p>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</p>\n<p>no-siteapp: 禁止自动转码。假设某网页没有进行移动端适配，在移动端进行浏览时，从某个入口（例如百度）进入该网页，可以防止该入口对网页进行移动设备转码。虽然转码的意图是好的，但是有的时候转码之后效果不尽人意，就可以设置这个属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Cache-Control\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no-siteapp\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["技术"],"tags":["HTML"]},{"title":"setTimeout-and-setInterval","url":"https://teobler.com/20170710-setTimeout-and-setInterval.html","content":"<p>这是一个老生常谈，新手掉坑的问题，算是一个比较经典的对于javascript运行机制的理解问题，由于好几次踩坑，决定好好理解下，我在这里粗浅的谈一下自己的理解，话不多说，进入正题：</p>\n<h2 id=\"两者表面上的区别\"><a href=\"#两者表面上的区别\" class=\"headerlink\" title=\"两者表面上的区别\"></a>两者表面上的区别</h2><ol>\n<li><p>setTimeout() 方法用于在指定毫秒数之后调用其中的函数</p>\n</li>\n<li><p>setInterval() 方法则是在间隔一定毫秒后重复调用其中的函数</p>\n</li>\n</ol>\n<h2 id=\"透过现象看本质\"><a href=\"#透过现象看本质\" class=\"headerlink\" title=\"透过现象看本质\"></a>透过现象看本质</h2><h3 id=\"时间精确问题\"><a href=\"#时间精确问题\" class=\"headerlink\" title=\"时间精确问题\"></a>时间精确问题</h3><p>由于js是运行在单线程的环境当中的，单线程就意味着任务的执行需要依赖任务队列。实际运行时是将两个方法的代码块移出当前运行环境（从任务队列移出到回调队列中），当执行完当前任务后，检查回调队列中有无需要执行的任务（对应这两个方法为是否已经到执行时间），可是如果时间到时恰好有别的任务在进行的话，由于其单线程的机制，该方法就只能等到当前任务结束之后才能运行。</p>\n<p>回到方法本身，这就相当于其他的正常任务在一个队列中，当遇到这两个方法时，就将他们移出队列，并开始计时，当时间到时，直接“插队”到队首，如果队首有正在执行的任务，则排在次队首，等待执行。也就是说，这仅仅是“计划”在未来某一个时间执行某个任务，并不能保证精确的时间。</p>\n<h3 id=\"setInterval重复执行问题\"><a href=\"#setInterval重复执行问题\" class=\"headerlink\" title=\"setInterval重复执行问题\"></a>setInterval重复执行问题</h3><p>这个方法执行时仅当没有该计时器的其他代码示例时才进行下一轮的执行。这样的规则就会导致某些间隔会被跳过，同时多个间隔可能比预期时间要短。所以为了避免setInterval所造成的问题，可以用setTimeout来通过循环代替setInterval方法，从而实现一个重复的定时器(除非必要，尽量避免代码中出现setInterval)</p>\n<h3 id=\"方法中使用this的问题\"><a href=\"#方法中使用this的问题\" class=\"headerlink\" title=\"方法中使用this的问题\"></a>方法中使用this的问题</h3><p>在两个方法中传入函数时(即第一个函数参数中含有另外一个函数)，此函数中的this会只想window对象。这是由于两个方法调用的代码在与所在函数完全分离的执行环境上(第一条中有讲到的两个方法的运行机制)，这就会导致这些代码中包含的this关键字会指向window(或全局)对象。</p>\n<p>但是要注意，如果this只是在两个方法中而不是在方法中的函数中时，this的指向符合我们的预期为当前对象。</p>\n<h4 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h4><p>1.将当前对象的this存为一个变量，定时器内的函数利用闭包来访问这个变量，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;    <span class=\"comment\">//将this存为一个变量，此时的this指向obj</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getNumLater = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(that.num);    <span class=\"comment\">//利用闭包访问that，that是一个指向obj的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Obj;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getNum();          <span class=\"comment\">//1　　打印的为obj.num，值为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getNumLater()      <span class=\"comment\">//1　　打印的为obj.num，值为1</span></span><br></pre></td></tr></table></figure>\n<p>2.利用bind()方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.num = <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getNum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getNumLater = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.num);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;.bind(<span class=\"keyword\">this</span>), <span class=\"number\">1000</span>)    <span class=\"comment\">//利用bind()将this绑定到这个函数上</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Obj;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.getNum();                 <span class=\"comment\">//1　　打印的为obj.num，值为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.getNumLater()             <span class=\"comment\">//1　　打印的为obj.num，值为1</span></span><br></pre></td></tr></table></figure>\n<p>bind()方法是在Function.prototype上的一个方法，当被绑定函数执行时，bind方法会创建一个新函数，并将第一个参数作为新函数运行时的this。在这个例子中，在调用setTimeout中的函数时，bind方法创建了一个新的函数，并将this传进新的函数，执行的结果也就是正确的了。关于bind方法可参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN bind</a></p>\n<h3 id=\"清除计时器\"><a href=\"#清除计时器\" class=\"headerlink\" title=\"清除计时器\"></a>清除计时器</h3><h4 id=\"clearTimeout\"><a href=\"#clearTimeout\" class=\"headerlink\" title=\"clearTimeout()\"></a>clearTimeout()</h4><p>在在使用setTimeout时，该方法会返回一个唯一的关于当前计时器的计时ID，在clearTimeout()方法中传入这个ID值即可取消对应的Timeout</p>\n<h4 id=\"clearInterval\"><a href=\"#clearInterval\" class=\"headerlink\" title=\"clearInterval()\"></a>clearInterval()</h4><p>同上</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>上面是我在使用过程中遇到问题后在网上查阅后自己的一些总结，希望对和我一样的新手有所帮助，其实还能透过这两个方法深入了解js的任务队列与调用栈，这里由于不是主题我就不深入讨论了，想要更深入了解他们的区别和js的一些运行机制，请入传送门：</p>\n<p><a href=\"http://javascript.ruanyifeng.com/advanced/timer.html\" target=\"_blank\" rel=\"noopener\">传送门1—阮大的剖析</a></p>\n<p><a href=\"http://www.cnblogs.com/zsqos/p/6188835.html\" target=\"_blank\" rel=\"noopener\">传送门2—this指向</a></p>\n<p><a href=\"http://www.cnblogs.com/dolphinX/archive/2013/04/05/2784933.html\" target=\"_blank\" rel=\"noopener\">传送门3—调用执行</a></p>\n","categories":["技术"],"tags":["JavaScript"]},{"title":"面试分享总结","url":"https://teobler.com/20170702-interview-sharing.html","content":"<p>今天在QQ群中大家分享交流了一下自己以前在各种面试中被问过或者问别人的一些问题，为了以后的面试积累，也为了防止忘记，特别写下作记忆。</p>\n<p>面试提问一般都会一环扣一环，逐步深入，直到你回答不上来，再往另外一个方向走，下面的问题也按照这个思路来列举。</p>\n<h2 id=\"见面\"><a href=\"#见面\" class=\"headerlink\" title=\"见面\"></a>见面</h2><ul>\n<li>html基础标签</li>\n<li>html5新增标签 -&gt; 几个常用标签都有啥作用</li>\n<li>meta标签一般什么时候用到，里面的东西有啥用</li>\n<li>引申出来的seo是什么，怎么优化</li>\n<li>css常用布局</li>\n<li>垂直居中问题</li>\n<li>兼容性问题</li>\n</ul>\n<h2 id=\"能聊（问题会夹杂例子）\"><a href=\"#能聊（问题会夹杂例子）\" class=\"headerlink\" title=\"能聊（问题会夹杂例子）\"></a>能聊（问题会夹杂例子）</h2><ul>\n<li>基本dom操作</li>\n<li>string与array的基本操作</li>\n<li>ajax的使用</li>\n<li>http的基本使用 -&gt; get、post、put、delete</li>\n<li>回调的使用 -&gt; promise</li>\n<li>闭包与变量提升 -&gt; es6对这两个问题的解决 -&gt; es6基本语法和使用</li>\n<li>git的基本使用，解决冲突等</li>\n</ul>\n<h2 id=\"还不错（夹杂实际项目）\"><a href=\"#还不错（夹杂实际项目）\" class=\"headerlink\" title=\"还不错（夹杂实际项目）\"></a>还不错（夹杂实际项目）</h2><ul>\n<li>自动化环境的搭建 -&gt; gulp + webpack</li>\n<li>项目组件和插件的bug怎么检查和排除</li>\n<li>你自己项目中的技术栈 -&gt; 怎么实际运用 -&gt;　都有啥特点 -&gt;　会遇到什么问题 -&gt; 要怎么解决（这个部分就要深入了解自己所做的东西，不要有任何自己写出来却不了解的地方）</li>\n</ul>\n<hr>\n<p>感谢群里大佬<a href=\"\">@畸心乱步</a>的总结和分享</p>\n<p>基本上上面的问题已经达到了一般公司对于初级前端的要求，你自己也达到了进公司干干杂活切切图的水准，想要有更大的提升，还是要不断学习和进步，加油</p>\n","categories":["职业"],"tags":["面试","面试题"]},{"title":"应聘前期准备","url":"https://teobler.com/20170606-interview-preparation.html","content":"<p>写在开头：在学期末最后的生产实习，实在无聊，搭建了自己的博客，目前虽然还没有特别美观，但至少算是能用的状态。从现在开始慢慢积累自己的知识，以后有时间会陆续把自己零散的知识都汇总到这边来。</p>\n<p>校招临近，打算总结一下自己掌握的应聘和面试的知识和技巧，给自己查阅的同时也算是做一次小小的分享吧，话不多说，进入正文。（ps.这边默认工作为fe）</p>\n<ul>\n<li><p>招聘时间:</p>\n<ul>\n<li>秋招 –&gt; 7月各大公司（BAT一级）开始内推 –&gt; 8月开始第一批公司的秋招 –&gt; 9月进入招聘高峰 –&gt; 10月各大高校招聘会 –&gt; 11月以后进行补招（到这还没找到基本就难了）</li>\n<li>春招 –&gt; 春节假期结束后开始内推 –&gt; 3月左右开始春招 –&gt; 4月高峰 –&gt; 5月结束（现在还没找到就gg）</li>\n</ul>\n</li>\n<li><p>招聘网站:</p>\n<ul>\n<li>拉勾</li>\n<li>实习僧</li>\n<li>脉脉</li>\n<li>boss直聘</li>\n<li>大街网</li>\n<li>应届生求职网</li>\n<li>应聘宝</li>\n<li>牛客</li>\n<li>推酷</li>\n</ul>\n</li>\n<li><p>内推渠道:</p>\n<ul>\n<li>学长学姐</li>\n<li>QQ群、微信群</li>\n<li>论坛</li>\n<li>牛客</li>\n</ul>\n</li>\n<li><p>面试准备:</p>\n<ul>\n<li>简历（多份针对不同公司、迭代、最重要）</li>\n<li>简历注重你做过什么，做成了什么，项目要熟悉，在其中担任了什么角色</li>\n<li>网申自荐信</li>\n<li>自我介绍（三分钟、一分钟）</li>\n<li>做一个表格记录下自己投过的公司，在哪面挂了，过了的有哪些，要不要再投一次，自己做好分析</li>\n<li>做一份纯文字版的简历，方便在网申的时候复制粘贴</li>\n<li>面试前花点时间了解下公司的文化，项目情况，优缺点之类，别问你啥都不知道</li>\n<li>每次面试过后，等结果的时候把题目和问题收集起来，想办法弄懂，好好总结</li>\n<li>一般是三轮面试居多，越好的公司面试轮次越多</li>\n</ul>\n</li>\n<li><p>笔试加技术面:</p>\n<ul>\n<li>基础知识<br>(包括但不限于)<br>网络、操作系统、数据结构、编译原理</li>\n<li>算法 –&gt; 基础 –&gt; 排序、动态规划、各经典算法等 –&gt; leetcode –&gt; 最低要求简单题全刷，中等题能做多少做多少</li>\n<li>前端知识<br>老三门（重点基本是js，然后原型链、正则表达式、事件委托、时间冒泡、AMD、CND），http，数据去重等</li>\n<li>远程面试的话，可能会有在线编程题，提前做好准备</li>\n<li>锻炼自己手写代码的能力</li>\n</ul>\n</li>\n<li><p>关于项目:</p>\n<ul>\n<li>有自己的技术博客最好</li>\n<li>github尽量全绿，但并不是随便绿，至少对你的技术提升要有意义，不管是总结还是小demo</li>\n<li>千万不要撒谎，自己的项目一定要熟悉，有新颖的技术最好</li>\n<li>简历上写的项目肯定是会被深挖，简历上的东西，自己一定要有十足的把握</li>\n<li>加分项stackoverflow和segmentfault</li>\n</ul>\n</li>\n<li><p>面试中:</p>\n<ul>\n<li>态度</li>\n<li>知行合一</li>\n<li>引领谈话，不要停止思考，不要怕否定自己</li>\n</ul>\n</li>\n<li><p>实习后</p>\n<ul>\n<li>实习总结</li>\n<li>自己得到了什么，学到了什么</li>\n<li>这个公司怎么样，多方面评价</li>\n</ul>\n</li>\n<li><p>资料</p>\n<ul>\n<li>程序员面试宝典</li>\n<li>剑指offer</li>\n</ul>\n</li>\n</ul>\n<p>祝各位能有一份自己理想的工作～加油～</p>\n","categories":["职业"],"tags":["校招","招聘","面试","内推"]},{"title":"about","url":"https://teobler.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://teobler.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"categories","url":"https://teobler.com/categories/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://teobler.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://teobler.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"https://teobler.com/tags/index.html","content":"","categories":[],"tags":[]}]